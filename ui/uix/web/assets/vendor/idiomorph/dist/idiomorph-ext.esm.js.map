{
  "version": 3,
  "sources": ["../../../../../../node_modules/idiomorph/dist/idiomorph-ext.esm.js"],
  "sourcesContent": ["import htmx from \"htmx.org\";\n\n/**\n * @typedef {object} ConfigHead\n *\n * @property {'merge' | 'append' | 'morph' | 'none'} [style]\n * @property {boolean} [block]\n * @property {boolean} [ignore]\n * @property {function(Element): boolean} [shouldPreserve]\n * @property {function(Element): boolean} [shouldReAppend]\n * @property {function(Element): boolean} [shouldRemove]\n * @property {function(Element, {added: Node[], kept: Element[], removed: Element[]}): void} [afterHeadMorphed]\n */\n\n/**\n * @typedef {object} ConfigCallbacks\n *\n * @property {function(Node): boolean} [beforeNodeAdded]\n * @property {function(Node): void} [afterNodeAdded]\n * @property {function(Element, Node): boolean} [beforeNodeMorphed]\n * @property {function(Element, Node): void} [afterNodeMorphed]\n * @property {function(Element): boolean} [beforeNodeRemoved]\n * @property {function(Element): void} [afterNodeRemoved]\n * @property {function(string, Element, \"update\" | \"remove\"): boolean} [beforeAttributeUpdated]\n */\n\n/**\n * @typedef {object} Config\n *\n * @property {'outerHTML' | 'innerHTML'} [morphStyle]\n * @property {boolean} [ignoreActive]\n * @property {boolean} [ignoreActiveValue]\n * @property {boolean} [restoreFocus]\n * @property {ConfigCallbacks} [callbacks]\n * @property {ConfigHead} [head]\n */\n\n/**\n * @typedef {function} NoOp\n *\n * @returns {void}\n */\n\n/**\n * @typedef {object} ConfigHeadInternal\n *\n * @property {'merge' | 'append' | 'morph' | 'none'} style\n * @property {boolean} [block]\n * @property {boolean} [ignore]\n * @property {(function(Element): boolean) | NoOp} shouldPreserve\n * @property {(function(Element): boolean) | NoOp} shouldReAppend\n * @property {(function(Element): boolean) | NoOp} shouldRemove\n * @property {(function(Element, {added: Node[], kept: Element[], removed: Element[]}): void) | NoOp} afterHeadMorphed\n */\n\n/**\n * @typedef {object} ConfigCallbacksInternal\n *\n * @property {(function(Node): boolean) | NoOp} beforeNodeAdded\n * @property {(function(Node): void) | NoOp} afterNodeAdded\n * @property {(function(Node, Node): boolean) | NoOp} beforeNodeMorphed\n * @property {(function(Node, Node): void) | NoOp} afterNodeMorphed\n * @property {(function(Node): boolean) | NoOp} beforeNodeRemoved\n * @property {(function(Node): void) | NoOp} afterNodeRemoved\n * @property {(function(string, Element, \"update\" | \"remove\"): boolean) | NoOp} beforeAttributeUpdated\n */\n\n/**\n * @typedef {object} ConfigInternal\n *\n * @property {'outerHTML' | 'innerHTML'} morphStyle\n * @property {boolean} [ignoreActive]\n * @property {boolean} [ignoreActiveValue]\n * @property {boolean} [restoreFocus]\n * @property {ConfigCallbacksInternal} callbacks\n * @property {ConfigHeadInternal} head\n */\n\n/**\n * @typedef {Object} IdSets\n * @property {Set<string>} persistentIds\n * @property {Map<Node, Set<string>>} idMap\n */\n\n/**\n * @typedef {Function} Morph\n *\n * @param {Element | Document} oldNode\n * @param {Element | Node | HTMLCollection | Node[] | string | null} newContent\n * @param {Config} [config]\n * @returns {undefined | Node[]}\n */\n\n// base IIFE to define idiomorph\n/**\n *\n * @type {{defaults: ConfigInternal, morph: Morph}}\n */\nvar Idiomorph = (function () {\n  \"use strict\";\n\n  /**\n   * @typedef {object} MorphContext\n   *\n   * @property {Element} target\n   * @property {Element} newContent\n   * @property {ConfigInternal} config\n   * @property {ConfigInternal['morphStyle']} morphStyle\n   * @property {ConfigInternal['ignoreActive']} ignoreActive\n   * @property {ConfigInternal['ignoreActiveValue']} ignoreActiveValue\n   * @property {ConfigInternal['restoreFocus']} restoreFocus\n   * @property {Map<Node, Set<string>>} idMap\n   * @property {Set<string>} persistentIds\n   * @property {ConfigInternal['callbacks']} callbacks\n   * @property {ConfigInternal['head']} head\n   * @property {HTMLDivElement} pantry\n   */\n\n  //=============================================================================\n  // AND NOW IT BEGINS...\n  //=============================================================================\n\n  const noOp = () => {};\n  /**\n   * Default configuration values, updatable by users now\n   * @type {ConfigInternal}\n   */\n  const defaults = {\n    morphStyle: \"outerHTML\",\n    callbacks: {\n      beforeNodeAdded: noOp,\n      afterNodeAdded: noOp,\n      beforeNodeMorphed: noOp,\n      afterNodeMorphed: noOp,\n      beforeNodeRemoved: noOp,\n      afterNodeRemoved: noOp,\n      beforeAttributeUpdated: noOp,\n    },\n    head: {\n      style: \"merge\",\n      shouldPreserve: (elt) => elt.getAttribute(\"im-preserve\") === \"true\",\n      shouldReAppend: (elt) => elt.getAttribute(\"im-re-append\") === \"true\",\n      shouldRemove: noOp,\n      afterHeadMorphed: noOp,\n    },\n    restoreFocus: true,\n  };\n\n  /**\n   * Core idiomorph function for morphing one DOM tree to another\n   *\n   * @param {Element | Document} oldNode\n   * @param {Element | Node | HTMLCollection | Node[] | string | null} newContent\n   * @param {Config} [config]\n   * @returns {Promise<Node[]> | Node[]}\n   */\n  function morph(oldNode, newContent, config = {}) {\n    oldNode = normalizeElement(oldNode);\n    const newNode = normalizeParent(newContent);\n    const ctx = createMorphContext(oldNode, newNode, config);\n\n    const morphedNodes = saveAndRestoreFocus(ctx, () => {\n      return withHeadBlocking(\n        ctx,\n        oldNode,\n        newNode,\n        /** @param {MorphContext} ctx */ (ctx) => {\n          if (ctx.morphStyle === \"innerHTML\") {\n            morphChildren(ctx, oldNode, newNode);\n            return Array.from(oldNode.childNodes);\n          } else {\n            return morphOuterHTML(ctx, oldNode, newNode);\n          }\n        },\n      );\n    });\n\n    ctx.pantry.remove();\n    return morphedNodes;\n  }\n\n  /**\n   * Morph just the outerHTML of the oldNode to the newContent\n   * We have to be careful because the oldNode could have siblings which need to be untouched\n   * @param {MorphContext} ctx\n   * @param {Element} oldNode\n   * @param {Element} newNode\n   * @returns {Node[]}\n   */\n  function morphOuterHTML(ctx, oldNode, newNode) {\n    const oldParent = normalizeParent(oldNode);\n    morphChildren(\n      ctx,\n      oldParent,\n      newNode,\n      // these two optional params are the secret sauce\n      oldNode, // start point for iteration\n      oldNode.nextSibling, // end point for iteration\n    );\n    // this is safe even with siblings, because normalizeParent returns a SlicedParentNode if needed.\n    return Array.from(oldParent.childNodes);\n  }\n\n  /**\n   * @param {MorphContext} ctx\n   * @param {Function} fn\n   * @returns {Promise<Node[]> | Node[]}\n   */\n  function saveAndRestoreFocus(ctx, fn) {\n    if (!ctx.config.restoreFocus) return fn();\n    let activeElement =\n      /** @type {HTMLInputElement|HTMLTextAreaElement|null} */ (\n        document.activeElement\n      );\n\n    // don't bother if the active element is not an input or textarea\n    if (\n      !(\n        activeElement instanceof HTMLInputElement ||\n        activeElement instanceof HTMLTextAreaElement\n      )\n    ) {\n      return fn();\n    }\n\n    const { id: activeElementId, selectionStart, selectionEnd } = activeElement;\n\n    const results = fn();\n\n    if (activeElementId && activeElementId !== document.activeElement?.id) {\n      activeElement = ctx.target.querySelector(`[id=\"${activeElementId}\"]`);\n      activeElement?.focus();\n    }\n    if (activeElement && !activeElement.selectionEnd && selectionEnd) {\n      activeElement.setSelectionRange(selectionStart, selectionEnd);\n    }\n\n    return results;\n  }\n\n  const morphChildren = (function () {\n    /**\n     * This is the core algorithm for matching up children.  The idea is to use id sets to try to match up\n     * nodes as faithfully as possible.  We greedily match, which allows us to keep the algorithm fast, but\n     * by using id sets, we are able to better match up with content deeper in the DOM.\n     *\n     * Basic algorithm:\n     * - for each node in the new content:\n     *   - search self and siblings for an id set match, falling back to a soft match\n     *   - if match found\n     *     - remove any nodes up to the match:\n     *       - pantry persistent nodes\n     *       - delete the rest\n     *     - morph the match\n     *   - elsif no match found, and node is persistent\n     *     - find its match by querying the old root (future) and pantry (past)\n     *     - move it and its children here\n     *     - morph it\n     *   - else\n     *     - create a new node from scratch as a last result\n     *\n     * @param {MorphContext} ctx the merge context\n     * @param {Element} oldParent the old content that we are merging the new content into\n     * @param {Element} newParent the parent element of the new content\n     * @param {Node|null} [insertionPoint] the point in the DOM we start morphing at (defaults to first child)\n     * @param {Node|null} [endPoint] the point in the DOM we stop morphing at (defaults to after last child)\n     */\n    function morphChildren(\n      ctx,\n      oldParent,\n      newParent,\n      insertionPoint = null,\n      endPoint = null,\n    ) {\n      // normalize\n      if (\n        oldParent instanceof HTMLTemplateElement &&\n        newParent instanceof HTMLTemplateElement\n      ) {\n        // @ts-ignore we can pretend the DocumentFragment is an Element\n        oldParent = oldParent.content;\n        // @ts-ignore ditto\n        newParent = newParent.content;\n      }\n      insertionPoint ||= oldParent.firstChild;\n\n      // run through all the new content\n      for (const newChild of newParent.childNodes) {\n        // once we reach the end of the old parent content skip to the end and insert the rest\n        if (insertionPoint && insertionPoint != endPoint) {\n          const bestMatch = findBestMatch(\n            ctx,\n            newChild,\n            insertionPoint,\n            endPoint,\n          );\n          if (bestMatch) {\n            // if the node to morph is not at the insertion point then remove/move up to it\n            if (bestMatch !== insertionPoint) {\n              removeNodesBetween(ctx, insertionPoint, bestMatch);\n            }\n            morphNode(bestMatch, newChild, ctx);\n            insertionPoint = bestMatch.nextSibling;\n            continue;\n          }\n        }\n\n        // if the matching node is elsewhere in the original content\n        if (newChild instanceof Element && ctx.persistentIds.has(newChild.id)) {\n          // move it and all its children here and morph\n          const movedChild = moveBeforeById(\n            oldParent,\n            newChild.id,\n            insertionPoint,\n            ctx,\n          );\n          morphNode(movedChild, newChild, ctx);\n          insertionPoint = movedChild.nextSibling;\n          continue;\n        }\n\n        // last resort: insert the new node from scratch\n        const insertedNode = createNode(\n          oldParent,\n          newChild,\n          insertionPoint,\n          ctx,\n        );\n        // could be null if beforeNodeAdded prevented insertion\n        if (insertedNode) {\n          insertionPoint = insertedNode.nextSibling;\n        }\n      }\n\n      // remove any remaining old nodes that didn't match up with new content\n      while (insertionPoint && insertionPoint != endPoint) {\n        const tempNode = insertionPoint;\n        insertionPoint = insertionPoint.nextSibling;\n        removeNode(ctx, tempNode);\n      }\n    }\n\n    /**\n     * This performs the action of inserting a new node while handling situations where the node contains\n     * elements with persistent ids and possible state info we can still preserve by moving in and then morphing\n     *\n     * @param {Element} oldParent\n     * @param {Node} newChild\n     * @param {Node|null} insertionPoint\n     * @param {MorphContext} ctx\n     * @returns {Node|null}\n     */\n    function createNode(oldParent, newChild, insertionPoint, ctx) {\n      if (ctx.callbacks.beforeNodeAdded(newChild) === false) return null;\n      if (ctx.idMap.has(newChild)) {\n        // node has children with ids with possible state so create a dummy elt of same type and apply full morph algorithm\n        const newEmptyChild = document.createElement(\n          /** @type {Element} */ (newChild).tagName,\n        );\n        oldParent.insertBefore(newEmptyChild, insertionPoint);\n        morphNode(newEmptyChild, newChild, ctx);\n        ctx.callbacks.afterNodeAdded(newEmptyChild);\n        return newEmptyChild;\n      } else {\n        // optimisation: no id state to preserve so we can just insert a clone of the newChild and its descendants\n        const newClonedChild = document.importNode(newChild, true); // importNode to not mutate newParent\n        oldParent.insertBefore(newClonedChild, insertionPoint);\n        ctx.callbacks.afterNodeAdded(newClonedChild);\n        return newClonedChild;\n      }\n    }\n\n    //=============================================================================\n    // Matching Functions\n    //=============================================================================\n    const findBestMatch = (function () {\n      /**\n       * Scans forward from the startPoint to the endPoint looking for a match\n       * for the node. It looks for an id set match first, then a soft match.\n       * We abort softmatching if we find two future soft matches, to reduce churn.\n       * @param {Node} node\n       * @param {MorphContext} ctx\n       * @param {Node | null} startPoint\n       * @param {Node | null} endPoint\n       * @returns {Node | null}\n       */\n      function findBestMatch(ctx, node, startPoint, endPoint) {\n        let softMatch = null;\n        let nextSibling = node.nextSibling;\n        let siblingSoftMatchCount = 0;\n\n        let cursor = startPoint;\n        while (cursor && cursor != endPoint) {\n          // soft matching is a prerequisite for id set matching\n          if (isSoftMatch(cursor, node)) {\n            if (isIdSetMatch(ctx, cursor, node)) {\n              return cursor; // found an id set match, we're done!\n            }\n\n            // we haven't yet saved a soft match fallback\n            if (softMatch === null) {\n              // the current soft match will hard match something else in the future, leave it\n              if (!ctx.idMap.has(cursor)) {\n                // save this as the fallback if we get through the loop without finding a hard match\n                softMatch = cursor;\n              }\n            }\n          }\n          if (\n            softMatch === null &&\n            nextSibling &&\n            isSoftMatch(cursor, nextSibling)\n          ) {\n            // The next new node has a soft match with this node, so\n            // increment the count of future soft matches\n            siblingSoftMatchCount++;\n            nextSibling = nextSibling.nextSibling;\n\n            // If there are two future soft matches, block soft matching for this node to allow\n            // future siblings to soft match. This is to reduce churn in the DOM when an element\n            // is prepended.\n            if (siblingSoftMatchCount >= 2) {\n              softMatch = undefined;\n            }\n          }\n\n          // if the current node contains active element, stop looking for better future matches,\n          // because if one is found, this node will be moved to the pantry, reparenting it and thus losing focus\n          if (cursor.contains(document.activeElement)) break;\n\n          cursor = cursor.nextSibling;\n        }\n\n        return softMatch || null;\n      }\n\n      /**\n       *\n       * @param {MorphContext} ctx\n       * @param {Node} oldNode\n       * @param {Node} newNode\n       * @returns {boolean}\n       */\n      function isIdSetMatch(ctx, oldNode, newNode) {\n        let oldSet = ctx.idMap.get(oldNode);\n        let newSet = ctx.idMap.get(newNode);\n\n        if (!newSet || !oldSet) return false;\n\n        for (const id of oldSet) {\n          // a potential match is an id in the new and old nodes that\n          // has not already been merged into the DOM\n          // But the newNode content we call this on has not been\n          // merged yet and we don't allow duplicate IDs so it is simple\n          if (newSet.has(id)) {\n            return true;\n          }\n        }\n        return false;\n      }\n\n      /**\n       *\n       * @param {Node} oldNode\n       * @param {Node} newNode\n       * @returns {boolean}\n       */\n      function isSoftMatch(oldNode, newNode) {\n        // ok to cast: if one is not element, `id` and `tagName` will be undefined and we'll just compare that.\n        const oldElt = /** @type {Element} */ (oldNode);\n        const newElt = /** @type {Element} */ (newNode);\n\n        return (\n          oldElt.nodeType === newElt.nodeType &&\n          oldElt.tagName === newElt.tagName &&\n          // If oldElt has an `id` with possible state and it doesn't match newElt.id then avoid morphing.\n          // We'll still match an anonymous node with an IDed newElt, though, because if it got this far,\n          // its not persistent, and new nodes can't have any hidden state.\n          (!oldElt.id || oldElt.id === newElt.id)\n        );\n      }\n\n      return findBestMatch;\n    })();\n\n    //=============================================================================\n    // DOM Manipulation Functions\n    //=============================================================================\n\n    /**\n     * Gets rid of an unwanted DOM node; strategy depends on nature of its reuse:\n     * - Persistent nodes will be moved to the pantry for later reuse\n     * - Other nodes will have their hooks called, and then are removed\n     * @param {MorphContext} ctx\n     * @param {Node} node\n     */\n    function removeNode(ctx, node) {\n      // are we going to id set match this later?\n      if (ctx.idMap.has(node)) {\n        // skip callbacks and move to pantry\n        moveBefore(ctx.pantry, node, null);\n      } else {\n        // remove for realsies\n        if (ctx.callbacks.beforeNodeRemoved(node) === false) return;\n        node.parentNode?.removeChild(node);\n        ctx.callbacks.afterNodeRemoved(node);\n      }\n    }\n\n    /**\n     * Remove nodes between the start and end nodes\n     * @param {MorphContext} ctx\n     * @param {Node} startInclusive\n     * @param {Node} endExclusive\n     * @returns {Node|null}\n     */\n    function removeNodesBetween(ctx, startInclusive, endExclusive) {\n      /** @type {Node | null} */\n      let cursor = startInclusive;\n      // remove nodes until the endExclusive node\n      while (cursor && cursor !== endExclusive) {\n        let tempNode = /** @type {Node} */ (cursor);\n        cursor = cursor.nextSibling;\n        removeNode(ctx, tempNode);\n      }\n      return cursor;\n    }\n\n    /**\n     * Search for an element by id within the document and pantry, and move it using moveBefore.\n     *\n     * @param {Element} parentNode - The parent node to which the element will be moved.\n     * @param {string} id - The ID of the element to be moved.\n     * @param {Node | null} after - The reference node to insert the element before.\n     *                              If `null`, the element is appended as the last child.\n     * @param {MorphContext} ctx\n     * @returns {Element} The found element\n     */\n    function moveBeforeById(parentNode, id, after, ctx) {\n      const target =\n        /** @type {Element} - will always be found */\n        (\n          (ctx.target.id === id && ctx.target) ||\n            ctx.target.querySelector(`[id=\"${id}\"]`) ||\n            ctx.pantry.querySelector(`[id=\"${id}\"]`)\n        );\n      removeElementFromAncestorsIdMaps(target, ctx);\n      moveBefore(parentNode, target, after);\n      return target;\n    }\n\n    /**\n     * Removes an element from its ancestors' id maps. This is needed when an element is moved from the\n     * \"future\" via `moveBeforeId`. Otherwise, its erstwhile ancestors could be mistakenly moved to the\n     * pantry rather than being deleted, preventing their removal hooks from being called.\n     *\n     * @param {Element} element - element to remove from its ancestors' id maps\n     * @param {MorphContext} ctx\n     */\n    function removeElementFromAncestorsIdMaps(element, ctx) {\n      const id = element.id;\n      /** @ts-ignore - safe to loop in this way **/\n      while ((element = element.parentNode)) {\n        let idSet = ctx.idMap.get(element);\n        if (idSet) {\n          idSet.delete(id);\n          if (!idSet.size) {\n            ctx.idMap.delete(element);\n          }\n        }\n      }\n    }\n\n    /**\n     * Moves an element before another element within the same parent.\n     * Uses the proposed `moveBefore` API if available (and working), otherwise falls back to `insertBefore`.\n     * This is essentialy a forward-compat wrapper.\n     *\n     * @param {Element} parentNode - The parent node containing the after element.\n     * @param {Node} element - The element to be moved.\n     * @param {Node | null} after - The reference node to insert `element` before.\n     *                              If `null`, `element` is appended as the last child.\n     */\n    function moveBefore(parentNode, element, after) {\n      // @ts-ignore - use proposed moveBefore feature\n      if (parentNode.moveBefore) {\n        try {\n          // @ts-ignore - use proposed moveBefore feature\n          parentNode.moveBefore(element, after);\n        } catch (e) {\n          // fall back to insertBefore as some browsers may fail on moveBefore when trying to move Dom disconnected nodes to pantry\n          parentNode.insertBefore(element, after);\n        }\n      } else {\n        parentNode.insertBefore(element, after);\n      }\n    }\n\n    return morphChildren;\n  })();\n\n  //=============================================================================\n  // Single Node Morphing Code\n  //=============================================================================\n  const morphNode = (function () {\n    /**\n     * @param {Node} oldNode root node to merge content into\n     * @param {Node} newContent new content to merge\n     * @param {MorphContext} ctx the merge context\n     * @returns {Node | null} the element that ended up in the DOM\n     */\n    function morphNode(oldNode, newContent, ctx) {\n      if (ctx.ignoreActive && oldNode === document.activeElement) {\n        // don't morph focused element\n        return null;\n      }\n\n      if (ctx.callbacks.beforeNodeMorphed(oldNode, newContent) === false) {\n        return oldNode;\n      }\n\n      if (oldNode instanceof HTMLHeadElement && ctx.head.ignore) {\n        // ignore the head element\n      } else if (\n        oldNode instanceof HTMLHeadElement &&\n        ctx.head.style !== \"morph\"\n      ) {\n        // ok to cast: if newContent wasn't also a <head>, it would've got caught in the `!isSoftMatch` branch above\n        handleHeadElement(\n          oldNode,\n          /** @type {HTMLHeadElement} */ (newContent),\n          ctx,\n        );\n      } else {\n        morphAttributes(oldNode, newContent, ctx);\n        if (!ignoreValueOfActiveElement(oldNode, ctx)) {\n          // @ts-ignore newContent can be a node here because .firstChild will be null\n          morphChildren(ctx, oldNode, newContent);\n        }\n      }\n      ctx.callbacks.afterNodeMorphed(oldNode, newContent);\n      return oldNode;\n    }\n\n    /**\n     * syncs the oldNode to the newNode, copying over all attributes and\n     * inner element state from the newNode to the oldNode\n     *\n     * @param {Node} oldNode the node to copy attributes & state to\n     * @param {Node} newNode the node to copy attributes & state from\n     * @param {MorphContext} ctx the merge context\n     */\n    function morphAttributes(oldNode, newNode, ctx) {\n      let type = newNode.nodeType;\n\n      // if is an element type, sync the attributes from the\n      // new node into the new node\n      if (type === 1 /* element type */) {\n        const oldElt = /** @type {Element} */ (oldNode);\n        const newElt = /** @type {Element} */ (newNode);\n\n        const oldAttributes = oldElt.attributes;\n        const newAttributes = newElt.attributes;\n        for (const newAttribute of newAttributes) {\n          if (ignoreAttribute(newAttribute.name, oldElt, \"update\", ctx)) {\n            continue;\n          }\n          if (oldElt.getAttribute(newAttribute.name) !== newAttribute.value) {\n            oldElt.setAttribute(newAttribute.name, newAttribute.value);\n          }\n        }\n        // iterate backwards to avoid skipping over items when a delete occurs\n        for (let i = oldAttributes.length - 1; 0 <= i; i--) {\n          const oldAttribute = oldAttributes[i];\n\n          // toAttributes is a live NamedNodeMap, so iteration+mutation is unsafe\n          // e.g. custom element attribute callbacks can remove other attributes\n          if (!oldAttribute) continue;\n\n          if (!newElt.hasAttribute(oldAttribute.name)) {\n            if (ignoreAttribute(oldAttribute.name, oldElt, \"remove\", ctx)) {\n              continue;\n            }\n            oldElt.removeAttribute(oldAttribute.name);\n          }\n        }\n\n        if (!ignoreValueOfActiveElement(oldElt, ctx)) {\n          syncInputValue(oldElt, newElt, ctx);\n        }\n      }\n\n      // sync text nodes\n      if (type === 8 /* comment */ || type === 3 /* text */) {\n        if (oldNode.nodeValue !== newNode.nodeValue) {\n          oldNode.nodeValue = newNode.nodeValue;\n        }\n      }\n    }\n\n    /**\n     * NB: many bothans died to bring us information:\n     *\n     *  https://github.com/patrick-steele-idem/morphdom/blob/master/src/specialElHandlers.js\n     *  https://github.com/choojs/nanomorph/blob/master/lib/morph.jsL113\n     *\n     * @param {Element} oldElement the element to sync the input value to\n     * @param {Element} newElement the element to sync the input value from\n     * @param {MorphContext} ctx the merge context\n     */\n    function syncInputValue(oldElement, newElement, ctx) {\n      if (\n        oldElement instanceof HTMLInputElement &&\n        newElement instanceof HTMLInputElement &&\n        newElement.type !== \"file\"\n      ) {\n        let newValue = newElement.value;\n        let oldValue = oldElement.value;\n\n        // sync boolean attributes\n        syncBooleanAttribute(oldElement, newElement, \"checked\", ctx);\n        syncBooleanAttribute(oldElement, newElement, \"disabled\", ctx);\n\n        if (!newElement.hasAttribute(\"value\")) {\n          if (!ignoreAttribute(\"value\", oldElement, \"remove\", ctx)) {\n            oldElement.value = \"\";\n            oldElement.removeAttribute(\"value\");\n          }\n        } else if (oldValue !== newValue) {\n          if (!ignoreAttribute(\"value\", oldElement, \"update\", ctx)) {\n            oldElement.setAttribute(\"value\", newValue);\n            oldElement.value = newValue;\n          }\n        }\n        // TODO: QUESTION(1cg): this used to only check `newElement` unlike the other branches -- why?\n        // did I break something?\n      } else if (\n        oldElement instanceof HTMLOptionElement &&\n        newElement instanceof HTMLOptionElement\n      ) {\n        syncBooleanAttribute(oldElement, newElement, \"selected\", ctx);\n      } else if (\n        oldElement instanceof HTMLTextAreaElement &&\n        newElement instanceof HTMLTextAreaElement\n      ) {\n        let newValue = newElement.value;\n        let oldValue = oldElement.value;\n        if (ignoreAttribute(\"value\", oldElement, \"update\", ctx)) {\n          return;\n        }\n        if (newValue !== oldValue) {\n          oldElement.value = newValue;\n        }\n        if (\n          oldElement.firstChild &&\n          oldElement.firstChild.nodeValue !== newValue\n        ) {\n          oldElement.firstChild.nodeValue = newValue;\n        }\n      }\n    }\n\n    /**\n     * @param {Element} oldElement element to write the value to\n     * @param {Element} newElement element to read the value from\n     * @param {string} attributeName the attribute name\n     * @param {MorphContext} ctx the merge context\n     */\n    function syncBooleanAttribute(oldElement, newElement, attributeName, ctx) {\n      // @ts-ignore this function is only used on boolean attrs that are reflected as dom properties\n      const newLiveValue = newElement[attributeName],\n        // @ts-ignore ditto\n        oldLiveValue = oldElement[attributeName];\n      if (newLiveValue !== oldLiveValue) {\n        const ignoreUpdate = ignoreAttribute(\n          attributeName,\n          oldElement,\n          \"update\",\n          ctx,\n        );\n        if (!ignoreUpdate) {\n          // update attribute's associated DOM property\n          // @ts-ignore this function is only used on boolean attrs that are reflected as dom properties\n          oldElement[attributeName] = newElement[attributeName];\n        }\n        if (newLiveValue) {\n          if (!ignoreUpdate) {\n            // https://developer.mozilla.org/en-US/docs/Glossary/Boolean/HTML\n            // this is the correct way to set a boolean attribute to \"true\"\n            oldElement.setAttribute(attributeName, \"\");\n          }\n        } else {\n          if (!ignoreAttribute(attributeName, oldElement, \"remove\", ctx)) {\n            oldElement.removeAttribute(attributeName);\n          }\n        }\n      }\n    }\n\n    /**\n     * @param {string} attr the attribute to be mutated\n     * @param {Element} element the element that is going to be updated\n     * @param {\"update\" | \"remove\"} updateType\n     * @param {MorphContext} ctx the merge context\n     * @returns {boolean} true if the attribute should be ignored, false otherwise\n     */\n    function ignoreAttribute(attr, element, updateType, ctx) {\n      if (\n        attr === \"value\" &&\n        ctx.ignoreActiveValue &&\n        element === document.activeElement\n      ) {\n        return true;\n      }\n      return (\n        ctx.callbacks.beforeAttributeUpdated(attr, element, updateType) ===\n        false\n      );\n    }\n\n    /**\n     * @param {Node} possibleActiveElement\n     * @param {MorphContext} ctx\n     * @returns {boolean}\n     */\n    function ignoreValueOfActiveElement(possibleActiveElement, ctx) {\n      return (\n        !!ctx.ignoreActiveValue &&\n        possibleActiveElement === document.activeElement &&\n        possibleActiveElement !== document.body\n      );\n    }\n\n    return morphNode;\n  })();\n\n  //=============================================================================\n  // Head Management Functions\n  //=============================================================================\n  /**\n   * @param {MorphContext} ctx\n   * @param {Element} oldNode\n   * @param {Element} newNode\n   * @param {function} callback\n   * @returns {Node[] | Promise<Node[]>}\n   */\n  function withHeadBlocking(ctx, oldNode, newNode, callback) {\n    if (ctx.head.block) {\n      const oldHead = oldNode.querySelector(\"head\");\n      const newHead = newNode.querySelector(\"head\");\n      if (oldHead && newHead) {\n        const promises = handleHeadElement(oldHead, newHead, ctx);\n        // when head promises resolve, proceed ignoring the head tag\n        return Promise.all(promises).then(() => {\n          const newCtx = Object.assign(ctx, {\n            head: {\n              block: false,\n              ignore: true,\n            },\n          });\n          return callback(newCtx);\n        });\n      }\n    }\n    // just proceed if we not head blocking\n    return callback(ctx);\n  }\n\n  /**\n   *  The HEAD tag can be handled specially, either w/ a 'merge' or 'append' style\n   *\n   * @param {Element} oldHead\n   * @param {Element} newHead\n   * @param {MorphContext} ctx\n   * @returns {Promise<void>[]}\n   */\n  function handleHeadElement(oldHead, newHead, ctx) {\n    let added = [];\n    let removed = [];\n    let preserved = [];\n    let nodesToAppend = [];\n\n    // put all new head elements into a Map, by their outerHTML\n    let srcToNewHeadNodes = new Map();\n    for (const newHeadChild of newHead.children) {\n      srcToNewHeadNodes.set(newHeadChild.outerHTML, newHeadChild);\n    }\n\n    // for each elt in the current head\n    for (const currentHeadElt of oldHead.children) {\n      // If the current head element is in the map\n      let inNewContent = srcToNewHeadNodes.has(currentHeadElt.outerHTML);\n      let isReAppended = ctx.head.shouldReAppend(currentHeadElt);\n      let isPreserved = ctx.head.shouldPreserve(currentHeadElt);\n      if (inNewContent || isPreserved) {\n        if (isReAppended) {\n          // remove the current version and let the new version replace it and re-execute\n          removed.push(currentHeadElt);\n        } else {\n          // this element already exists and should not be re-appended, so remove it from\n          // the new content map, preserving it in the DOM\n          srcToNewHeadNodes.delete(currentHeadElt.outerHTML);\n          preserved.push(currentHeadElt);\n        }\n      } else {\n        if (ctx.head.style === \"append\") {\n          // we are appending and this existing element is not new content\n          // so if and only if it is marked for re-append do we do anything\n          if (isReAppended) {\n            removed.push(currentHeadElt);\n            nodesToAppend.push(currentHeadElt);\n          }\n        } else {\n          // if this is a merge, we remove this content since it is not in the new head\n          if (ctx.head.shouldRemove(currentHeadElt) !== false) {\n            removed.push(currentHeadElt);\n          }\n        }\n      }\n    }\n\n    // Push the remaining new head elements in the Map into the\n    // nodes to append to the head tag\n    nodesToAppend.push(...srcToNewHeadNodes.values());\n\n    let promises = [];\n    for (const newNode of nodesToAppend) {\n      // TODO: This could theoretically be null, based on type\n      let newElt = /** @type {ChildNode} */ (\n        document.createRange().createContextualFragment(newNode.outerHTML)\n          .firstChild\n      );\n      if (ctx.callbacks.beforeNodeAdded(newElt) !== false) {\n        if (\n          (\"href\" in newElt && newElt.href) ||\n          (\"src\" in newElt && newElt.src)\n        ) {\n          /** @type {(result?: any) => void} */ let resolve;\n          let promise = new Promise(function (_resolve) {\n            resolve = _resolve;\n          });\n          newElt.addEventListener(\"load\", function () {\n            resolve();\n          });\n          promises.push(promise);\n        }\n        oldHead.appendChild(newElt);\n        ctx.callbacks.afterNodeAdded(newElt);\n        added.push(newElt);\n      }\n    }\n\n    // remove all removed elements, after we have appended the new elements to avoid\n    // additional network requests for things like style sheets\n    for (const removedElement of removed) {\n      if (ctx.callbacks.beforeNodeRemoved(removedElement) !== false) {\n        oldHead.removeChild(removedElement);\n        ctx.callbacks.afterNodeRemoved(removedElement);\n      }\n    }\n\n    ctx.head.afterHeadMorphed(oldHead, {\n      added: added,\n      kept: preserved,\n      removed: removed,\n    });\n    return promises;\n  }\n\n  //=============================================================================\n  // Create Morph Context Functions\n  //=============================================================================\n  const createMorphContext = (function () {\n    /**\n     *\n     * @param {Element} oldNode\n     * @param {Element} newContent\n     * @param {Config} config\n     * @returns {MorphContext}\n     */\n    function createMorphContext(oldNode, newContent, config) {\n      const { persistentIds, idMap } = createIdMaps(oldNode, newContent);\n\n      const mergedConfig = mergeDefaults(config);\n      const morphStyle = mergedConfig.morphStyle || \"outerHTML\";\n      if (![\"innerHTML\", \"outerHTML\"].includes(morphStyle)) {\n        throw `Do not understand how to morph style ${morphStyle}`;\n      }\n\n      return {\n        target: oldNode,\n        newContent: newContent,\n        config: mergedConfig,\n        morphStyle: morphStyle,\n        ignoreActive: mergedConfig.ignoreActive,\n        ignoreActiveValue: mergedConfig.ignoreActiveValue,\n        restoreFocus: mergedConfig.restoreFocus,\n        idMap: idMap,\n        persistentIds: persistentIds,\n        pantry: createPantry(),\n        callbacks: mergedConfig.callbacks,\n        head: mergedConfig.head,\n      };\n    }\n\n    /**\n     * Deep merges the config object and the Idiomorph.defaults object to\n     * produce a final configuration object\n     * @param {Config} config\n     * @returns {ConfigInternal}\n     */\n    function mergeDefaults(config) {\n      let finalConfig = Object.assign({}, defaults);\n\n      // copy top level stuff into final config\n      Object.assign(finalConfig, config);\n\n      // copy callbacks into final config (do this to deep merge the callbacks)\n      finalConfig.callbacks = Object.assign(\n        {},\n        defaults.callbacks,\n        config.callbacks,\n      );\n\n      // copy head config into final config  (do this to deep merge the head)\n      finalConfig.head = Object.assign({}, defaults.head, config.head);\n\n      return finalConfig;\n    }\n\n    /**\n     * @returns {HTMLDivElement}\n     */\n    function createPantry() {\n      const pantry = document.createElement(\"div\");\n      pantry.hidden = true;\n      document.body.insertAdjacentElement(\"afterend\", pantry);\n      return pantry;\n    }\n\n    /**\n     * Returns all elements with an ID contained within the root element and its descendants\n     *\n     * @param {Element} root\n     * @returns {Element[]}\n     */\n    function findIdElements(root) {\n      let elements = Array.from(root.querySelectorAll(\"[id]\"));\n      if (root.id) {\n        elements.push(root);\n      }\n      return elements;\n    }\n\n    /**\n     * A bottom-up algorithm that populates a map of Element -> IdSet.\n     * The idSet for a given element is the set of all IDs contained within its subtree.\n     * As an optimzation, we filter these IDs through the given list of persistent IDs,\n     * because we don't need to bother considering IDed elements that won't be in the new content.\n     *\n     * @param {Map<Node, Set<string>>} idMap\n     * @param {Set<string>} persistentIds\n     * @param {Element} root\n     * @param {Element[]} elements\n     */\n    function populateIdMapWithTree(idMap, persistentIds, root, elements) {\n      for (const elt of elements) {\n        if (persistentIds.has(elt.id)) {\n          /** @type {Element|null} */\n          let current = elt;\n          // walk up the parent hierarchy of that element, adding the id\n          // of element to the parent's id set\n          while (current) {\n            let idSet = idMap.get(current);\n            // if the id set doesn't exist, create it and insert it in the map\n            if (idSet == null) {\n              idSet = new Set();\n              idMap.set(current, idSet);\n            }\n            idSet.add(elt.id);\n\n            if (current === root) break;\n            current = current.parentElement;\n          }\n        }\n      }\n    }\n\n    /**\n     * This function computes a map of nodes to all ids contained within that node (inclusive of the\n     * node).  This map can be used to ask if two nodes have intersecting sets of ids, which allows\n     * for a looser definition of \"matching\" than tradition id matching, and allows child nodes\n     * to contribute to a parent nodes matching.\n     *\n     * @param {Element} oldContent  the old content that will be morphed\n     * @param {Element} newContent  the new content to morph to\n     * @returns {IdSets}\n     */\n    function createIdMaps(oldContent, newContent) {\n      const oldIdElements = findIdElements(oldContent);\n      const newIdElements = findIdElements(newContent);\n\n      const persistentIds = createPersistentIds(oldIdElements, newIdElements);\n\n      /** @type {Map<Node, Set<string>>} */\n      let idMap = new Map();\n      populateIdMapWithTree(idMap, persistentIds, oldContent, oldIdElements);\n\n      /** @ts-ignore - if newContent is a duck-typed parent, pass its single child node as the root to halt upwards iteration */\n      const newRoot = newContent.__idiomorphRoot || newContent;\n      populateIdMapWithTree(idMap, persistentIds, newRoot, newIdElements);\n\n      return { persistentIds, idMap };\n    }\n\n    /**\n     * This function computes the set of ids that persist between the two contents excluding duplicates\n     *\n     * @param {Element[]} oldIdElements\n     * @param {Element[]} newIdElements\n     * @returns {Set<string>}\n     */\n    function createPersistentIds(oldIdElements, newIdElements) {\n      let duplicateIds = new Set();\n\n      /** @type {Map<string, string>} */\n      let oldIdTagNameMap = new Map();\n      for (const { id, tagName } of oldIdElements) {\n        if (oldIdTagNameMap.has(id)) {\n          duplicateIds.add(id);\n        } else {\n          oldIdTagNameMap.set(id, tagName);\n        }\n      }\n\n      let persistentIds = new Set();\n      for (const { id, tagName } of newIdElements) {\n        if (persistentIds.has(id)) {\n          duplicateIds.add(id);\n        } else if (oldIdTagNameMap.get(id) === tagName) {\n          persistentIds.add(id);\n        }\n        // skip if tag types mismatch because its not possible to morph one tag into another\n      }\n\n      for (const id of duplicateIds) {\n        persistentIds.delete(id);\n      }\n      return persistentIds;\n    }\n\n    return createMorphContext;\n  })();\n\n  //=============================================================================\n  // HTML Normalization Functions\n  //=============================================================================\n  const { normalizeElement, normalizeParent } = (function () {\n    /** @type {WeakSet<Node>} */\n    const generatedByIdiomorph = new WeakSet();\n\n    /**\n     *\n     * @param {Element | Document} content\n     * @returns {Element}\n     */\n    function normalizeElement(content) {\n      if (content instanceof Document) {\n        return content.documentElement;\n      } else {\n        return content;\n      }\n    }\n\n    /**\n     *\n     * @param {null | string | Node | HTMLCollection | Node[] | Document & {generatedByIdiomorph:boolean}} newContent\n     * @returns {Element}\n     */\n    function normalizeParent(newContent) {\n      if (newContent == null) {\n        return document.createElement(\"div\"); // dummy parent element\n      } else if (typeof newContent === \"string\") {\n        return normalizeParent(parseContent(newContent));\n      } else if (\n        generatedByIdiomorph.has(/** @type {Element} */ (newContent))\n      ) {\n        // the template tag created by idiomorph parsing can serve as a dummy parent\n        return /** @type {Element} */ (newContent);\n      } else if (newContent instanceof Node) {\n        if (newContent.parentNode) {\n          // we can't use the parent directly because newContent may have siblings\n          // that we don't want in the morph, and reparenting might be expensive (TODO is it?),\n          // so instead we create a fake parent node that only sees a slice of its children.\n          /** @type {Element} */\n          return /** @type {any} */ (new SlicedParentNode(newContent));\n        } else {\n          // a single node is added as a child to a dummy parent\n          const dummyParent = document.createElement(\"div\");\n          dummyParent.append(newContent);\n          return dummyParent;\n        }\n      } else {\n        // all nodes in the array or HTMLElement collection are consolidated under\n        // a single dummy parent element\n        const dummyParent = document.createElement(\"div\");\n        for (const elt of [...newContent]) {\n          dummyParent.append(elt);\n        }\n        return dummyParent;\n      }\n    }\n\n    /**\n     * A fake duck-typed parent element to wrap a single node, without actually reparenting it.\n     * This is useful because the node may have siblings that we don't want in the morph, and it may also be moved\n     * or replaced with one or more elements during the morph. This class effectively allows us a window into\n     * a slice of a node's children.\n     * \"If it walks like a duck, and quacks like a duck, then it must be a duck!\" -- James Whitcomb Riley (1849\u20131916)\n     */\n    class SlicedParentNode {\n      /** @param {Node} node */\n      constructor(node) {\n        this.originalNode = node;\n        this.realParentNode = /** @type {Element} */ (node.parentNode);\n        this.previousSibling = node.previousSibling;\n        this.nextSibling = node.nextSibling;\n      }\n\n      /** @returns {Node[]} */\n      get childNodes() {\n        // return slice of realParent's current childNodes, based on previousSibling and nextSibling\n        const nodes = [];\n        let cursor = this.previousSibling\n          ? this.previousSibling.nextSibling\n          : this.realParentNode.firstChild;\n        while (cursor && cursor != this.nextSibling) {\n          nodes.push(cursor);\n          cursor = cursor.nextSibling;\n        }\n        return nodes;\n      }\n\n      /**\n       * @param {string} selector\n       * @returns {Element[]}\n       */\n      querySelectorAll(selector) {\n        return this.childNodes.reduce((results, node) => {\n          if (node instanceof Element) {\n            if (node.matches(selector)) results.push(node);\n            const nodeList = node.querySelectorAll(selector);\n            for (let i = 0; i < nodeList.length; i++) {\n              results.push(nodeList[i]);\n            }\n          }\n          return results;\n        }, /** @type {Element[]} */ ([]));\n      }\n\n      /**\n       * @param {Node} node\n       * @param {Node} referenceNode\n       * @returns {Node}\n       */\n      insertBefore(node, referenceNode) {\n        return this.realParentNode.insertBefore(node, referenceNode);\n      }\n\n      /**\n       * @param {Node} node\n       * @param {Node} referenceNode\n       * @returns {Node}\n       */\n      moveBefore(node, referenceNode) {\n        // @ts-ignore - use new moveBefore feature\n        return this.realParentNode.moveBefore(node, referenceNode);\n      }\n\n      /**\n       * for later use with populateIdMapWithTree to halt upwards iteration\n       * @returns {Node}\n       */\n      get __idiomorphRoot() {\n        return this.originalNode;\n      }\n    }\n\n    /**\n     *\n     * @param {string} newContent\n     * @returns {Node | null | DocumentFragment}\n     */\n    function parseContent(newContent) {\n      let parser = new DOMParser();\n\n      // remove svgs to avoid false-positive matches on head, etc.\n      let contentWithSvgsRemoved = newContent.replace(\n        /<svg(\\s[^>]*>|>)([\\s\\S]*?)<\\/svg>/gim,\n        \"\",\n      );\n\n      // if the newContent contains a html, head or body tag, we can simply parse it w/o wrapping\n      if (\n        contentWithSvgsRemoved.match(/<\\/html>/) ||\n        contentWithSvgsRemoved.match(/<\\/head>/) ||\n        contentWithSvgsRemoved.match(/<\\/body>/)\n      ) {\n        let content = parser.parseFromString(newContent, \"text/html\");\n        // if it is a full HTML document, return the document itself as the parent container\n        if (contentWithSvgsRemoved.match(/<\\/html>/)) {\n          generatedByIdiomorph.add(content);\n          return content;\n        } else {\n          // otherwise return the html element as the parent container\n          let htmlElement = content.firstChild;\n          if (htmlElement) {\n            generatedByIdiomorph.add(htmlElement);\n          }\n          return htmlElement;\n        }\n      } else {\n        // if it is partial HTML, wrap it in a template tag to provide a parent element and also to help\n        // deal with touchy tags like tr, tbody, etc.\n        let responseDoc = parser.parseFromString(\n          \"<body><template>\" + newContent + \"</template></body>\",\n          \"text/html\",\n        );\n        let content = /** @type {HTMLTemplateElement} */ (\n          responseDoc.body.querySelector(\"template\")\n        ).content;\n        generatedByIdiomorph.add(content);\n        return content;\n      }\n    }\n\n    return { normalizeElement, normalizeParent };\n  })();\n\n  //=============================================================================\n  // This is what ends up becoming the Idiomorph global object\n  //=============================================================================\n  return {\n    morph,\n    defaults,\n  };\n})();\n(function () {\n  function createMorphConfig(swapStyle) {\n    if (swapStyle === \"morph\" || swapStyle === \"morph:outerHTML\") {\n      return { morphStyle: \"outerHTML\" };\n    } else if (swapStyle === \"morph:innerHTML\") {\n      return { morphStyle: \"innerHTML\" };\n    } else if (swapStyle.startsWith(\"morph:\")) {\n      return Function(\"return (\" + swapStyle.slice(6) + \")\")();\n    }\n  }\n\n  htmx.defineExtension(\"morph\", {\n    isInlineSwap: function (swapStyle) {\n      let config = createMorphConfig(swapStyle);\n      return config?.morphStyle === \"outerHTML\" || config?.morphStyle == null;\n    },\n    handleSwap: function (swapStyle, target, fragment) {\n      let config = createMorphConfig(swapStyle);\n      if (config) {\n        return Idiomorph.morph(target, fragment.children, config);\n      }\n    },\n  });\n})();\n\nexport {Idiomorph};\n"],
  "mappings": "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",
  "names": ["Idiomorph", "noOp", "defaults", "elt", "morph", "oldNode", "newContent", "config", "normalizeElement", "newNode", "normalizeParent", "ctx", "createMorphContext", "morphedNodes", "saveAndRestoreFocus", "withHeadBlocking", "morphChildren", "morphOuterHTML", "oldParent", "fn", "activeElement", "activeElementId", "selectionStart", "selectionEnd", "results", "newParent", "insertionPoint", "endPoint", "newChild", "bestMatch", "findBestMatch", "removeNodesBetween", "morphNode", "movedChild", "moveBeforeById", "insertedNode", "createNode", "tempNode", "removeNode", "newEmptyChild", "newClonedChild", "node", "startPoint", "softMatch", "nextSibling", "siblingSoftMatchCount", "cursor", "isSoftMatch", "isIdSetMatch", "oldSet", "newSet", "id", "oldElt", "newElt", "moveBefore", "startInclusive", "endExclusive", "parentNode", "after", "target", "removeElementFromAncestorsIdMaps", "element", "idSet", "handleHeadElement", "morphAttributes", "ignoreValueOfActiveElement", "type", "oldAttributes", "newAttributes", "newAttribute", "ignoreAttribute", "i", "oldAttribute", "syncInputValue", "oldElement", "newElement", "newValue", "oldValue", "syncBooleanAttribute", "attributeName", "newLiveValue", "oldLiveValue", "ignoreUpdate", "attr", "updateType", "possibleActiveElement", "callback", "oldHead", "newHead", "promises", "newCtx", "added", "removed", "preserved", "nodesToAppend", "srcToNewHeadNodes", "newHeadChild", "currentHeadElt", "inNewContent", "isReAppended", "isPreserved", "resolve", "promise", "_resolve", "removedElement", "persistentIds", "idMap", "createIdMaps", "mergedConfig", "mergeDefaults", "morphStyle", "createPantry", "finalConfig", "pantry", "findIdElements", "root", "elements", "populateIdMapWithTree", "current", "oldContent", "oldIdElements", "newIdElements", "createPersistentIds", "newRoot", "duplicateIds", "oldIdTagNameMap", "tagName", "generatedByIdiomorph", "content", "parseContent", "SlicedParentNode", "dummyParent", "nodes", "selector", "nodeList", "referenceNode", "parser", "contentWithSvgsRemoved", "htmlElement", "createMorphConfig", "swapStyle", "htmx_esm_default", "fragment"]
}
