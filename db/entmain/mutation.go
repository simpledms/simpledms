// Code generated by ent, DO NOT EDIT.

package entmain

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/simpledms/simpledms/db/entmain/account"
	"github.com/simpledms/simpledms/db/entmain/mail"
	"github.com/simpledms/simpledms/db/entmain/predicate"
	"github.com/simpledms/simpledms/db/entmain/session"
	"github.com/simpledms/simpledms/db/entmain/systemconfig"
	"github.com/simpledms/simpledms/db/entmain/temporaryfile"
	"github.com/simpledms/simpledms/db/entmain/tenant"
	"github.com/simpledms/simpledms/db/entmain/tenantaccountassignment"
	"github.com/simpledms/simpledms/db/entx"
	"github.com/simpledms/simpledms/model/common/country"
	"github.com/simpledms/simpledms/model/common/language"
	"github.com/simpledms/simpledms/model/common/mainrole"
	"github.com/simpledms/simpledms/model/common/plan"
	"github.com/simpledms/simpledms/model/common/storagetype"
	"github.com/simpledms/simpledms/model/common/tenantrole"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAccount                 = "Account"
	TypeMail                    = "Mail"
	TypeSession                 = "Session"
	TypeSystemConfig            = "SystemConfig"
	TypeTemporaryFile           = "TemporaryFile"
	TypeTenant                  = "Tenant"
	TypeTenantAccountAssignment = "TenantAccountAssignment"
)

// AccountMutation represents an operation that mutates the Account nodes in the graph.
type AccountMutation struct {
	config
	op                                         Op
	typ                                        string
	id                                         *int64
	created_at                                 *time.Time
	created_by                                 *int64
	addcreated_by                              *int64
	updated_at                                 *time.Time
	updated_by                                 *int64
	addupdated_by                              *int64
	deleted_by                                 *int64
	adddeleted_by                              *int64
	deleted_at                                 *time.Time
	public_id                                  *entx.CIText
	email                                      *entx.CIText
	first_name                                 *string
	last_name                                  *string
	language                                   *language.Language
	subscribed_to_newsletter_at                *time.Time
	password_salt                              *string
	password_hash                              *string
	temporary_password_salt                    *string
	temporary_password_hash                    *string
	temporary_password_expires_at              *time.Time
	temporary_two_factor_auth_key_encrypted    *string
	two_factory_auth_key_encrypted             *string
	two_factor_auth_recovery_code_salt         *string
	two_factor_auth_recovery_code_hashes       *[]string
	appendtwo_factor_auth_recovery_code_hashes []string
	last_login_attempt_at                      *time.Time
	role                                       *mainrole.MainRole
	clearedFields                              map[string]struct{}
	tenants                                    map[int64]struct{}
	removedtenants                             map[int64]struct{}
	clearedtenants                             bool
	received_mails                             map[int64]struct{}
	removedreceived_mails                      map[int64]struct{}
	clearedreceived_mails                      bool
	temporary_files                            map[int64]struct{}
	removedtemporary_files                     map[int64]struct{}
	clearedtemporary_files                     bool
	tenant_assignment                          map[int64]struct{}
	removedtenant_assignment                   map[int64]struct{}
	clearedtenant_assignment                   bool
	done                                       bool
	oldValue                                   func(context.Context) (*Account, error)
	predicates                                 []predicate.Account
}

var _ ent.Mutation = (*AccountMutation)(nil)

// accountOption allows management of the mutation configuration using functional options.
type accountOption func(*AccountMutation)

// newAccountMutation creates new mutation for the Account entity.
func newAccountMutation(c config, op Op, opts ...accountOption) *AccountMutation {
	m := &AccountMutation{
		config:        c,
		op:            op,
		typ:           TypeAccount,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAccountID sets the ID field of the mutation.
func withAccountID(id int64) accountOption {
	return func(m *AccountMutation) {
		var (
			err   error
			once  sync.Once
			value *Account
		)
		m.oldValue = func(ctx context.Context) (*Account, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Account.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAccount sets the old Account of the mutation.
func withAccount(node *Account) accountOption {
	return func(m *AccountMutation) {
		m.oldValue = func(context.Context) (*Account, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AccountMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AccountMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("entmain: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Account entities.
func (m *AccountMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AccountMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AccountMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Account.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *AccountMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *AccountMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *AccountMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *AccountMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *AccountMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *AccountMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *AccountMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *AccountMutation) ClearCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
	m.clearedFields[account.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *AccountMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[account.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *AccountMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
	delete(m.clearedFields, account.FieldCreatedBy)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *AccountMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *AccountMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *AccountMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *AccountMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *AccountMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *AccountMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *AccountMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *AccountMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	m.clearedFields[account.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *AccountMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[account.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *AccountMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	delete(m.clearedFields, account.FieldUpdatedBy)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *AccountMutation) SetDeletedBy(i int64) {
	m.deleted_by = &i
	m.adddeleted_by = nil
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *AccountMutation) DeletedBy() (r int64, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldDeletedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// AddDeletedBy adds i to the "deleted_by" field.
func (m *AccountMutation) AddDeletedBy(i int64) {
	if m.adddeleted_by != nil {
		*m.adddeleted_by += i
	} else {
		m.adddeleted_by = &i
	}
}

// AddedDeletedBy returns the value that was added to the "deleted_by" field in this mutation.
func (m *AccountMutation) AddedDeletedBy() (r int64, exists bool) {
	v := m.adddeleted_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *AccountMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.adddeleted_by = nil
	m.clearedFields[account.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *AccountMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[account.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *AccountMutation) ResetDeletedBy() {
	m.deleted_by = nil
	m.adddeleted_by = nil
	delete(m.clearedFields, account.FieldDeletedBy)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *AccountMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *AccountMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *AccountMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[account.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *AccountMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[account.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *AccountMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, account.FieldDeletedAt)
}

// SetPublicID sets the "public_id" field.
func (m *AccountMutation) SetPublicID(et entx.CIText) {
	m.public_id = &et
}

// PublicID returns the value of the "public_id" field in the mutation.
func (m *AccountMutation) PublicID() (r entx.CIText, exists bool) {
	v := m.public_id
	if v == nil {
		return
	}
	return *v, true
}

// OldPublicID returns the old "public_id" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldPublicID(ctx context.Context) (v entx.CIText, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPublicID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPublicID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPublicID: %w", err)
	}
	return oldValue.PublicID, nil
}

// ResetPublicID resets all changes to the "public_id" field.
func (m *AccountMutation) ResetPublicID() {
	m.public_id = nil
}

// SetEmail sets the "email" field.
func (m *AccountMutation) SetEmail(et entx.CIText) {
	m.email = &et
}

// Email returns the value of the "email" field in the mutation.
func (m *AccountMutation) Email() (r entx.CIText, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldEmail(ctx context.Context) (v entx.CIText, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *AccountMutation) ResetEmail() {
	m.email = nil
}

// SetFirstName sets the "first_name" field.
func (m *AccountMutation) SetFirstName(s string) {
	m.first_name = &s
}

// FirstName returns the value of the "first_name" field in the mutation.
func (m *AccountMutation) FirstName() (r string, exists bool) {
	v := m.first_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFirstName returns the old "first_name" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldFirstName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFirstName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFirstName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirstName: %w", err)
	}
	return oldValue.FirstName, nil
}

// ResetFirstName resets all changes to the "first_name" field.
func (m *AccountMutation) ResetFirstName() {
	m.first_name = nil
}

// SetLastName sets the "last_name" field.
func (m *AccountMutation) SetLastName(s string) {
	m.last_name = &s
}

// LastName returns the value of the "last_name" field in the mutation.
func (m *AccountMutation) LastName() (r string, exists bool) {
	v := m.last_name
	if v == nil {
		return
	}
	return *v, true
}

// OldLastName returns the old "last_name" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldLastName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastName: %w", err)
	}
	return oldValue.LastName, nil
}

// ResetLastName resets all changes to the "last_name" field.
func (m *AccountMutation) ResetLastName() {
	m.last_name = nil
}

// SetLanguage sets the "language" field.
func (m *AccountMutation) SetLanguage(l language.Language) {
	m.language = &l
}

// Language returns the value of the "language" field in the mutation.
func (m *AccountMutation) Language() (r language.Language, exists bool) {
	v := m.language
	if v == nil {
		return
	}
	return *v, true
}

// OldLanguage returns the old "language" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldLanguage(ctx context.Context) (v language.Language, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLanguage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLanguage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLanguage: %w", err)
	}
	return oldValue.Language, nil
}

// ResetLanguage resets all changes to the "language" field.
func (m *AccountMutation) ResetLanguage() {
	m.language = nil
}

// SetSubscribedToNewsletterAt sets the "subscribed_to_newsletter_at" field.
func (m *AccountMutation) SetSubscribedToNewsletterAt(t time.Time) {
	m.subscribed_to_newsletter_at = &t
}

// SubscribedToNewsletterAt returns the value of the "subscribed_to_newsletter_at" field in the mutation.
func (m *AccountMutation) SubscribedToNewsletterAt() (r time.Time, exists bool) {
	v := m.subscribed_to_newsletter_at
	if v == nil {
		return
	}
	return *v, true
}

// OldSubscribedToNewsletterAt returns the old "subscribed_to_newsletter_at" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldSubscribedToNewsletterAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubscribedToNewsletterAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubscribedToNewsletterAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubscribedToNewsletterAt: %w", err)
	}
	return oldValue.SubscribedToNewsletterAt, nil
}

// ClearSubscribedToNewsletterAt clears the value of the "subscribed_to_newsletter_at" field.
func (m *AccountMutation) ClearSubscribedToNewsletterAt() {
	m.subscribed_to_newsletter_at = nil
	m.clearedFields[account.FieldSubscribedToNewsletterAt] = struct{}{}
}

// SubscribedToNewsletterAtCleared returns if the "subscribed_to_newsletter_at" field was cleared in this mutation.
func (m *AccountMutation) SubscribedToNewsletterAtCleared() bool {
	_, ok := m.clearedFields[account.FieldSubscribedToNewsletterAt]
	return ok
}

// ResetSubscribedToNewsletterAt resets all changes to the "subscribed_to_newsletter_at" field.
func (m *AccountMutation) ResetSubscribedToNewsletterAt() {
	m.subscribed_to_newsletter_at = nil
	delete(m.clearedFields, account.FieldSubscribedToNewsletterAt)
}

// SetPasswordSalt sets the "password_salt" field.
func (m *AccountMutation) SetPasswordSalt(s string) {
	m.password_salt = &s
}

// PasswordSalt returns the value of the "password_salt" field in the mutation.
func (m *AccountMutation) PasswordSalt() (r string, exists bool) {
	v := m.password_salt
	if v == nil {
		return
	}
	return *v, true
}

// OldPasswordSalt returns the old "password_salt" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldPasswordSalt(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPasswordSalt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPasswordSalt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPasswordSalt: %w", err)
	}
	return oldValue.PasswordSalt, nil
}

// ResetPasswordSalt resets all changes to the "password_salt" field.
func (m *AccountMutation) ResetPasswordSalt() {
	m.password_salt = nil
}

// SetPasswordHash sets the "password_hash" field.
func (m *AccountMutation) SetPasswordHash(s string) {
	m.password_hash = &s
}

// PasswordHash returns the value of the "password_hash" field in the mutation.
func (m *AccountMutation) PasswordHash() (r string, exists bool) {
	v := m.password_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldPasswordHash returns the old "password_hash" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldPasswordHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPasswordHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPasswordHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPasswordHash: %w", err)
	}
	return oldValue.PasswordHash, nil
}

// ResetPasswordHash resets all changes to the "password_hash" field.
func (m *AccountMutation) ResetPasswordHash() {
	m.password_hash = nil
}

// SetTemporaryPasswordSalt sets the "temporary_password_salt" field.
func (m *AccountMutation) SetTemporaryPasswordSalt(s string) {
	m.temporary_password_salt = &s
}

// TemporaryPasswordSalt returns the value of the "temporary_password_salt" field in the mutation.
func (m *AccountMutation) TemporaryPasswordSalt() (r string, exists bool) {
	v := m.temporary_password_salt
	if v == nil {
		return
	}
	return *v, true
}

// OldTemporaryPasswordSalt returns the old "temporary_password_salt" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldTemporaryPasswordSalt(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTemporaryPasswordSalt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTemporaryPasswordSalt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTemporaryPasswordSalt: %w", err)
	}
	return oldValue.TemporaryPasswordSalt, nil
}

// ResetTemporaryPasswordSalt resets all changes to the "temporary_password_salt" field.
func (m *AccountMutation) ResetTemporaryPasswordSalt() {
	m.temporary_password_salt = nil
}

// SetTemporaryPasswordHash sets the "temporary_password_hash" field.
func (m *AccountMutation) SetTemporaryPasswordHash(s string) {
	m.temporary_password_hash = &s
}

// TemporaryPasswordHash returns the value of the "temporary_password_hash" field in the mutation.
func (m *AccountMutation) TemporaryPasswordHash() (r string, exists bool) {
	v := m.temporary_password_hash
	if v == nil {
		return
	}
	return *v, true
}

// OldTemporaryPasswordHash returns the old "temporary_password_hash" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldTemporaryPasswordHash(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTemporaryPasswordHash is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTemporaryPasswordHash requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTemporaryPasswordHash: %w", err)
	}
	return oldValue.TemporaryPasswordHash, nil
}

// ResetTemporaryPasswordHash resets all changes to the "temporary_password_hash" field.
func (m *AccountMutation) ResetTemporaryPasswordHash() {
	m.temporary_password_hash = nil
}

// SetTemporaryPasswordExpiresAt sets the "temporary_password_expires_at" field.
func (m *AccountMutation) SetTemporaryPasswordExpiresAt(t time.Time) {
	m.temporary_password_expires_at = &t
}

// TemporaryPasswordExpiresAt returns the value of the "temporary_password_expires_at" field in the mutation.
func (m *AccountMutation) TemporaryPasswordExpiresAt() (r time.Time, exists bool) {
	v := m.temporary_password_expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldTemporaryPasswordExpiresAt returns the old "temporary_password_expires_at" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldTemporaryPasswordExpiresAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTemporaryPasswordExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTemporaryPasswordExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTemporaryPasswordExpiresAt: %w", err)
	}
	return oldValue.TemporaryPasswordExpiresAt, nil
}

// ClearTemporaryPasswordExpiresAt clears the value of the "temporary_password_expires_at" field.
func (m *AccountMutation) ClearTemporaryPasswordExpiresAt() {
	m.temporary_password_expires_at = nil
	m.clearedFields[account.FieldTemporaryPasswordExpiresAt] = struct{}{}
}

// TemporaryPasswordExpiresAtCleared returns if the "temporary_password_expires_at" field was cleared in this mutation.
func (m *AccountMutation) TemporaryPasswordExpiresAtCleared() bool {
	_, ok := m.clearedFields[account.FieldTemporaryPasswordExpiresAt]
	return ok
}

// ResetTemporaryPasswordExpiresAt resets all changes to the "temporary_password_expires_at" field.
func (m *AccountMutation) ResetTemporaryPasswordExpiresAt() {
	m.temporary_password_expires_at = nil
	delete(m.clearedFields, account.FieldTemporaryPasswordExpiresAt)
}

// SetTemporaryTwoFactorAuthKeyEncrypted sets the "temporary_two_factor_auth_key_encrypted" field.
func (m *AccountMutation) SetTemporaryTwoFactorAuthKeyEncrypted(s string) {
	m.temporary_two_factor_auth_key_encrypted = &s
}

// TemporaryTwoFactorAuthKeyEncrypted returns the value of the "temporary_two_factor_auth_key_encrypted" field in the mutation.
func (m *AccountMutation) TemporaryTwoFactorAuthKeyEncrypted() (r string, exists bool) {
	v := m.temporary_two_factor_auth_key_encrypted
	if v == nil {
		return
	}
	return *v, true
}

// OldTemporaryTwoFactorAuthKeyEncrypted returns the old "temporary_two_factor_auth_key_encrypted" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldTemporaryTwoFactorAuthKeyEncrypted(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTemporaryTwoFactorAuthKeyEncrypted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTemporaryTwoFactorAuthKeyEncrypted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTemporaryTwoFactorAuthKeyEncrypted: %w", err)
	}
	return oldValue.TemporaryTwoFactorAuthKeyEncrypted, nil
}

// ResetTemporaryTwoFactorAuthKeyEncrypted resets all changes to the "temporary_two_factor_auth_key_encrypted" field.
func (m *AccountMutation) ResetTemporaryTwoFactorAuthKeyEncrypted() {
	m.temporary_two_factor_auth_key_encrypted = nil
}

// SetTwoFactoryAuthKeyEncrypted sets the "two_factory_auth_key_encrypted" field.
func (m *AccountMutation) SetTwoFactoryAuthKeyEncrypted(s string) {
	m.two_factory_auth_key_encrypted = &s
}

// TwoFactoryAuthKeyEncrypted returns the value of the "two_factory_auth_key_encrypted" field in the mutation.
func (m *AccountMutation) TwoFactoryAuthKeyEncrypted() (r string, exists bool) {
	v := m.two_factory_auth_key_encrypted
	if v == nil {
		return
	}
	return *v, true
}

// OldTwoFactoryAuthKeyEncrypted returns the old "two_factory_auth_key_encrypted" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldTwoFactoryAuthKeyEncrypted(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTwoFactoryAuthKeyEncrypted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTwoFactoryAuthKeyEncrypted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTwoFactoryAuthKeyEncrypted: %w", err)
	}
	return oldValue.TwoFactoryAuthKeyEncrypted, nil
}

// ResetTwoFactoryAuthKeyEncrypted resets all changes to the "two_factory_auth_key_encrypted" field.
func (m *AccountMutation) ResetTwoFactoryAuthKeyEncrypted() {
	m.two_factory_auth_key_encrypted = nil
}

// SetTwoFactorAuthRecoveryCodeSalt sets the "two_factor_auth_recovery_code_salt" field.
func (m *AccountMutation) SetTwoFactorAuthRecoveryCodeSalt(s string) {
	m.two_factor_auth_recovery_code_salt = &s
}

// TwoFactorAuthRecoveryCodeSalt returns the value of the "two_factor_auth_recovery_code_salt" field in the mutation.
func (m *AccountMutation) TwoFactorAuthRecoveryCodeSalt() (r string, exists bool) {
	v := m.two_factor_auth_recovery_code_salt
	if v == nil {
		return
	}
	return *v, true
}

// OldTwoFactorAuthRecoveryCodeSalt returns the old "two_factor_auth_recovery_code_salt" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldTwoFactorAuthRecoveryCodeSalt(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTwoFactorAuthRecoveryCodeSalt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTwoFactorAuthRecoveryCodeSalt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTwoFactorAuthRecoveryCodeSalt: %w", err)
	}
	return oldValue.TwoFactorAuthRecoveryCodeSalt, nil
}

// ResetTwoFactorAuthRecoveryCodeSalt resets all changes to the "two_factor_auth_recovery_code_salt" field.
func (m *AccountMutation) ResetTwoFactorAuthRecoveryCodeSalt() {
	m.two_factor_auth_recovery_code_salt = nil
}

// SetTwoFactorAuthRecoveryCodeHashes sets the "two_factor_auth_recovery_code_hashes" field.
func (m *AccountMutation) SetTwoFactorAuthRecoveryCodeHashes(s []string) {
	m.two_factor_auth_recovery_code_hashes = &s
	m.appendtwo_factor_auth_recovery_code_hashes = nil
}

// TwoFactorAuthRecoveryCodeHashes returns the value of the "two_factor_auth_recovery_code_hashes" field in the mutation.
func (m *AccountMutation) TwoFactorAuthRecoveryCodeHashes() (r []string, exists bool) {
	v := m.two_factor_auth_recovery_code_hashes
	if v == nil {
		return
	}
	return *v, true
}

// OldTwoFactorAuthRecoveryCodeHashes returns the old "two_factor_auth_recovery_code_hashes" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldTwoFactorAuthRecoveryCodeHashes(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTwoFactorAuthRecoveryCodeHashes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTwoFactorAuthRecoveryCodeHashes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTwoFactorAuthRecoveryCodeHashes: %w", err)
	}
	return oldValue.TwoFactorAuthRecoveryCodeHashes, nil
}

// AppendTwoFactorAuthRecoveryCodeHashes adds s to the "two_factor_auth_recovery_code_hashes" field.
func (m *AccountMutation) AppendTwoFactorAuthRecoveryCodeHashes(s []string) {
	m.appendtwo_factor_auth_recovery_code_hashes = append(m.appendtwo_factor_auth_recovery_code_hashes, s...)
}

// AppendedTwoFactorAuthRecoveryCodeHashes returns the list of values that were appended to the "two_factor_auth_recovery_code_hashes" field in this mutation.
func (m *AccountMutation) AppendedTwoFactorAuthRecoveryCodeHashes() ([]string, bool) {
	if len(m.appendtwo_factor_auth_recovery_code_hashes) == 0 {
		return nil, false
	}
	return m.appendtwo_factor_auth_recovery_code_hashes, true
}

// ResetTwoFactorAuthRecoveryCodeHashes resets all changes to the "two_factor_auth_recovery_code_hashes" field.
func (m *AccountMutation) ResetTwoFactorAuthRecoveryCodeHashes() {
	m.two_factor_auth_recovery_code_hashes = nil
	m.appendtwo_factor_auth_recovery_code_hashes = nil
}

// SetLastLoginAttemptAt sets the "last_login_attempt_at" field.
func (m *AccountMutation) SetLastLoginAttemptAt(t time.Time) {
	m.last_login_attempt_at = &t
}

// LastLoginAttemptAt returns the value of the "last_login_attempt_at" field in the mutation.
func (m *AccountMutation) LastLoginAttemptAt() (r time.Time, exists bool) {
	v := m.last_login_attempt_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastLoginAttemptAt returns the old "last_login_attempt_at" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldLastLoginAttemptAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastLoginAttemptAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastLoginAttemptAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastLoginAttemptAt: %w", err)
	}
	return oldValue.LastLoginAttemptAt, nil
}

// ClearLastLoginAttemptAt clears the value of the "last_login_attempt_at" field.
func (m *AccountMutation) ClearLastLoginAttemptAt() {
	m.last_login_attempt_at = nil
	m.clearedFields[account.FieldLastLoginAttemptAt] = struct{}{}
}

// LastLoginAttemptAtCleared returns if the "last_login_attempt_at" field was cleared in this mutation.
func (m *AccountMutation) LastLoginAttemptAtCleared() bool {
	_, ok := m.clearedFields[account.FieldLastLoginAttemptAt]
	return ok
}

// ResetLastLoginAttemptAt resets all changes to the "last_login_attempt_at" field.
func (m *AccountMutation) ResetLastLoginAttemptAt() {
	m.last_login_attempt_at = nil
	delete(m.clearedFields, account.FieldLastLoginAttemptAt)
}

// SetRole sets the "role" field.
func (m *AccountMutation) SetRole(mr mainrole.MainRole) {
	m.role = &mr
}

// Role returns the value of the "role" field in the mutation.
func (m *AccountMutation) Role() (r mainrole.MainRole, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRole returns the old "role" field's value of the Account entity.
// If the Account object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AccountMutation) OldRole(ctx context.Context) (v mainrole.MainRole, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRole is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRole: %w", err)
	}
	return oldValue.Role, nil
}

// ResetRole resets all changes to the "role" field.
func (m *AccountMutation) ResetRole() {
	m.role = nil
}

// AddTenantIDs adds the "tenants" edge to the Tenant entity by ids.
func (m *AccountMutation) AddTenantIDs(ids ...int64) {
	if m.tenants == nil {
		m.tenants = make(map[int64]struct{})
	}
	for i := range ids {
		m.tenants[ids[i]] = struct{}{}
	}
}

// ClearTenants clears the "tenants" edge to the Tenant entity.
func (m *AccountMutation) ClearTenants() {
	m.clearedtenants = true
}

// TenantsCleared reports if the "tenants" edge to the Tenant entity was cleared.
func (m *AccountMutation) TenantsCleared() bool {
	return m.clearedtenants
}

// RemoveTenantIDs removes the "tenants" edge to the Tenant entity by IDs.
func (m *AccountMutation) RemoveTenantIDs(ids ...int64) {
	if m.removedtenants == nil {
		m.removedtenants = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.tenants, ids[i])
		m.removedtenants[ids[i]] = struct{}{}
	}
}

// RemovedTenants returns the removed IDs of the "tenants" edge to the Tenant entity.
func (m *AccountMutation) RemovedTenantsIDs() (ids []int64) {
	for id := range m.removedtenants {
		ids = append(ids, id)
	}
	return
}

// TenantsIDs returns the "tenants" edge IDs in the mutation.
func (m *AccountMutation) TenantsIDs() (ids []int64) {
	for id := range m.tenants {
		ids = append(ids, id)
	}
	return
}

// ResetTenants resets all changes to the "tenants" edge.
func (m *AccountMutation) ResetTenants() {
	m.tenants = nil
	m.clearedtenants = false
	m.removedtenants = nil
}

// AddReceivedMailIDs adds the "received_mails" edge to the Mail entity by ids.
func (m *AccountMutation) AddReceivedMailIDs(ids ...int64) {
	if m.received_mails == nil {
		m.received_mails = make(map[int64]struct{})
	}
	for i := range ids {
		m.received_mails[ids[i]] = struct{}{}
	}
}

// ClearReceivedMails clears the "received_mails" edge to the Mail entity.
func (m *AccountMutation) ClearReceivedMails() {
	m.clearedreceived_mails = true
}

// ReceivedMailsCleared reports if the "received_mails" edge to the Mail entity was cleared.
func (m *AccountMutation) ReceivedMailsCleared() bool {
	return m.clearedreceived_mails
}

// RemoveReceivedMailIDs removes the "received_mails" edge to the Mail entity by IDs.
func (m *AccountMutation) RemoveReceivedMailIDs(ids ...int64) {
	if m.removedreceived_mails == nil {
		m.removedreceived_mails = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.received_mails, ids[i])
		m.removedreceived_mails[ids[i]] = struct{}{}
	}
}

// RemovedReceivedMails returns the removed IDs of the "received_mails" edge to the Mail entity.
func (m *AccountMutation) RemovedReceivedMailsIDs() (ids []int64) {
	for id := range m.removedreceived_mails {
		ids = append(ids, id)
	}
	return
}

// ReceivedMailsIDs returns the "received_mails" edge IDs in the mutation.
func (m *AccountMutation) ReceivedMailsIDs() (ids []int64) {
	for id := range m.received_mails {
		ids = append(ids, id)
	}
	return
}

// ResetReceivedMails resets all changes to the "received_mails" edge.
func (m *AccountMutation) ResetReceivedMails() {
	m.received_mails = nil
	m.clearedreceived_mails = false
	m.removedreceived_mails = nil
}

// AddTemporaryFileIDs adds the "temporary_files" edge to the TemporaryFile entity by ids.
func (m *AccountMutation) AddTemporaryFileIDs(ids ...int64) {
	if m.temporary_files == nil {
		m.temporary_files = make(map[int64]struct{})
	}
	for i := range ids {
		m.temporary_files[ids[i]] = struct{}{}
	}
}

// ClearTemporaryFiles clears the "temporary_files" edge to the TemporaryFile entity.
func (m *AccountMutation) ClearTemporaryFiles() {
	m.clearedtemporary_files = true
}

// TemporaryFilesCleared reports if the "temporary_files" edge to the TemporaryFile entity was cleared.
func (m *AccountMutation) TemporaryFilesCleared() bool {
	return m.clearedtemporary_files
}

// RemoveTemporaryFileIDs removes the "temporary_files" edge to the TemporaryFile entity by IDs.
func (m *AccountMutation) RemoveTemporaryFileIDs(ids ...int64) {
	if m.removedtemporary_files == nil {
		m.removedtemporary_files = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.temporary_files, ids[i])
		m.removedtemporary_files[ids[i]] = struct{}{}
	}
}

// RemovedTemporaryFiles returns the removed IDs of the "temporary_files" edge to the TemporaryFile entity.
func (m *AccountMutation) RemovedTemporaryFilesIDs() (ids []int64) {
	for id := range m.removedtemporary_files {
		ids = append(ids, id)
	}
	return
}

// TemporaryFilesIDs returns the "temporary_files" edge IDs in the mutation.
func (m *AccountMutation) TemporaryFilesIDs() (ids []int64) {
	for id := range m.temporary_files {
		ids = append(ids, id)
	}
	return
}

// ResetTemporaryFiles resets all changes to the "temporary_files" edge.
func (m *AccountMutation) ResetTemporaryFiles() {
	m.temporary_files = nil
	m.clearedtemporary_files = false
	m.removedtemporary_files = nil
}

// AddTenantAssignmentIDs adds the "tenant_assignment" edge to the TenantAccountAssignment entity by ids.
func (m *AccountMutation) AddTenantAssignmentIDs(ids ...int64) {
	if m.tenant_assignment == nil {
		m.tenant_assignment = make(map[int64]struct{})
	}
	for i := range ids {
		m.tenant_assignment[ids[i]] = struct{}{}
	}
}

// ClearTenantAssignment clears the "tenant_assignment" edge to the TenantAccountAssignment entity.
func (m *AccountMutation) ClearTenantAssignment() {
	m.clearedtenant_assignment = true
}

// TenantAssignmentCleared reports if the "tenant_assignment" edge to the TenantAccountAssignment entity was cleared.
func (m *AccountMutation) TenantAssignmentCleared() bool {
	return m.clearedtenant_assignment
}

// RemoveTenantAssignmentIDs removes the "tenant_assignment" edge to the TenantAccountAssignment entity by IDs.
func (m *AccountMutation) RemoveTenantAssignmentIDs(ids ...int64) {
	if m.removedtenant_assignment == nil {
		m.removedtenant_assignment = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.tenant_assignment, ids[i])
		m.removedtenant_assignment[ids[i]] = struct{}{}
	}
}

// RemovedTenantAssignment returns the removed IDs of the "tenant_assignment" edge to the TenantAccountAssignment entity.
func (m *AccountMutation) RemovedTenantAssignmentIDs() (ids []int64) {
	for id := range m.removedtenant_assignment {
		ids = append(ids, id)
	}
	return
}

// TenantAssignmentIDs returns the "tenant_assignment" edge IDs in the mutation.
func (m *AccountMutation) TenantAssignmentIDs() (ids []int64) {
	for id := range m.tenant_assignment {
		ids = append(ids, id)
	}
	return
}

// ResetTenantAssignment resets all changes to the "tenant_assignment" edge.
func (m *AccountMutation) ResetTenantAssignment() {
	m.tenant_assignment = nil
	m.clearedtenant_assignment = false
	m.removedtenant_assignment = nil
}

// Where appends a list predicates to the AccountMutation builder.
func (m *AccountMutation) Where(ps ...predicate.Account) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AccountMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AccountMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Account, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AccountMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AccountMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Account).
func (m *AccountMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AccountMutation) Fields() []string {
	fields := make([]string, 0, 23)
	if m.created_at != nil {
		fields = append(fields, account.FieldCreatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, account.FieldCreatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, account.FieldUpdatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, account.FieldUpdatedBy)
	}
	if m.deleted_by != nil {
		fields = append(fields, account.FieldDeletedBy)
	}
	if m.deleted_at != nil {
		fields = append(fields, account.FieldDeletedAt)
	}
	if m.public_id != nil {
		fields = append(fields, account.FieldPublicID)
	}
	if m.email != nil {
		fields = append(fields, account.FieldEmail)
	}
	if m.first_name != nil {
		fields = append(fields, account.FieldFirstName)
	}
	if m.last_name != nil {
		fields = append(fields, account.FieldLastName)
	}
	if m.language != nil {
		fields = append(fields, account.FieldLanguage)
	}
	if m.subscribed_to_newsletter_at != nil {
		fields = append(fields, account.FieldSubscribedToNewsletterAt)
	}
	if m.password_salt != nil {
		fields = append(fields, account.FieldPasswordSalt)
	}
	if m.password_hash != nil {
		fields = append(fields, account.FieldPasswordHash)
	}
	if m.temporary_password_salt != nil {
		fields = append(fields, account.FieldTemporaryPasswordSalt)
	}
	if m.temporary_password_hash != nil {
		fields = append(fields, account.FieldTemporaryPasswordHash)
	}
	if m.temporary_password_expires_at != nil {
		fields = append(fields, account.FieldTemporaryPasswordExpiresAt)
	}
	if m.temporary_two_factor_auth_key_encrypted != nil {
		fields = append(fields, account.FieldTemporaryTwoFactorAuthKeyEncrypted)
	}
	if m.two_factory_auth_key_encrypted != nil {
		fields = append(fields, account.FieldTwoFactoryAuthKeyEncrypted)
	}
	if m.two_factor_auth_recovery_code_salt != nil {
		fields = append(fields, account.FieldTwoFactorAuthRecoveryCodeSalt)
	}
	if m.two_factor_auth_recovery_code_hashes != nil {
		fields = append(fields, account.FieldTwoFactorAuthRecoveryCodeHashes)
	}
	if m.last_login_attempt_at != nil {
		fields = append(fields, account.FieldLastLoginAttemptAt)
	}
	if m.role != nil {
		fields = append(fields, account.FieldRole)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AccountMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case account.FieldCreatedAt:
		return m.CreatedAt()
	case account.FieldCreatedBy:
		return m.CreatedBy()
	case account.FieldUpdatedAt:
		return m.UpdatedAt()
	case account.FieldUpdatedBy:
		return m.UpdatedBy()
	case account.FieldDeletedBy:
		return m.DeletedBy()
	case account.FieldDeletedAt:
		return m.DeletedAt()
	case account.FieldPublicID:
		return m.PublicID()
	case account.FieldEmail:
		return m.Email()
	case account.FieldFirstName:
		return m.FirstName()
	case account.FieldLastName:
		return m.LastName()
	case account.FieldLanguage:
		return m.Language()
	case account.FieldSubscribedToNewsletterAt:
		return m.SubscribedToNewsletterAt()
	case account.FieldPasswordSalt:
		return m.PasswordSalt()
	case account.FieldPasswordHash:
		return m.PasswordHash()
	case account.FieldTemporaryPasswordSalt:
		return m.TemporaryPasswordSalt()
	case account.FieldTemporaryPasswordHash:
		return m.TemporaryPasswordHash()
	case account.FieldTemporaryPasswordExpiresAt:
		return m.TemporaryPasswordExpiresAt()
	case account.FieldTemporaryTwoFactorAuthKeyEncrypted:
		return m.TemporaryTwoFactorAuthKeyEncrypted()
	case account.FieldTwoFactoryAuthKeyEncrypted:
		return m.TwoFactoryAuthKeyEncrypted()
	case account.FieldTwoFactorAuthRecoveryCodeSalt:
		return m.TwoFactorAuthRecoveryCodeSalt()
	case account.FieldTwoFactorAuthRecoveryCodeHashes:
		return m.TwoFactorAuthRecoveryCodeHashes()
	case account.FieldLastLoginAttemptAt:
		return m.LastLoginAttemptAt()
	case account.FieldRole:
		return m.Role()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AccountMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case account.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case account.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case account.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case account.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case account.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case account.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case account.FieldPublicID:
		return m.OldPublicID(ctx)
	case account.FieldEmail:
		return m.OldEmail(ctx)
	case account.FieldFirstName:
		return m.OldFirstName(ctx)
	case account.FieldLastName:
		return m.OldLastName(ctx)
	case account.FieldLanguage:
		return m.OldLanguage(ctx)
	case account.FieldSubscribedToNewsletterAt:
		return m.OldSubscribedToNewsletterAt(ctx)
	case account.FieldPasswordSalt:
		return m.OldPasswordSalt(ctx)
	case account.FieldPasswordHash:
		return m.OldPasswordHash(ctx)
	case account.FieldTemporaryPasswordSalt:
		return m.OldTemporaryPasswordSalt(ctx)
	case account.FieldTemporaryPasswordHash:
		return m.OldTemporaryPasswordHash(ctx)
	case account.FieldTemporaryPasswordExpiresAt:
		return m.OldTemporaryPasswordExpiresAt(ctx)
	case account.FieldTemporaryTwoFactorAuthKeyEncrypted:
		return m.OldTemporaryTwoFactorAuthKeyEncrypted(ctx)
	case account.FieldTwoFactoryAuthKeyEncrypted:
		return m.OldTwoFactoryAuthKeyEncrypted(ctx)
	case account.FieldTwoFactorAuthRecoveryCodeSalt:
		return m.OldTwoFactorAuthRecoveryCodeSalt(ctx)
	case account.FieldTwoFactorAuthRecoveryCodeHashes:
		return m.OldTwoFactorAuthRecoveryCodeHashes(ctx)
	case account.FieldLastLoginAttemptAt:
		return m.OldLastLoginAttemptAt(ctx)
	case account.FieldRole:
		return m.OldRole(ctx)
	}
	return nil, fmt.Errorf("unknown Account field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AccountMutation) SetField(name string, value ent.Value) error {
	switch name {
	case account.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case account.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case account.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case account.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case account.FieldDeletedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case account.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case account.FieldPublicID:
		v, ok := value.(entx.CIText)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublicID(v)
		return nil
	case account.FieldEmail:
		v, ok := value.(entx.CIText)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case account.FieldFirstName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirstName(v)
		return nil
	case account.FieldLastName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastName(v)
		return nil
	case account.FieldLanguage:
		v, ok := value.(language.Language)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLanguage(v)
		return nil
	case account.FieldSubscribedToNewsletterAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubscribedToNewsletterAt(v)
		return nil
	case account.FieldPasswordSalt:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPasswordSalt(v)
		return nil
	case account.FieldPasswordHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPasswordHash(v)
		return nil
	case account.FieldTemporaryPasswordSalt:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTemporaryPasswordSalt(v)
		return nil
	case account.FieldTemporaryPasswordHash:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTemporaryPasswordHash(v)
		return nil
	case account.FieldTemporaryPasswordExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTemporaryPasswordExpiresAt(v)
		return nil
	case account.FieldTemporaryTwoFactorAuthKeyEncrypted:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTemporaryTwoFactorAuthKeyEncrypted(v)
		return nil
	case account.FieldTwoFactoryAuthKeyEncrypted:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTwoFactoryAuthKeyEncrypted(v)
		return nil
	case account.FieldTwoFactorAuthRecoveryCodeSalt:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTwoFactorAuthRecoveryCodeSalt(v)
		return nil
	case account.FieldTwoFactorAuthRecoveryCodeHashes:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTwoFactorAuthRecoveryCodeHashes(v)
		return nil
	case account.FieldLastLoginAttemptAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastLoginAttemptAt(v)
		return nil
	case account.FieldRole:
		v, ok := value.(mainrole.MainRole)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRole(v)
		return nil
	}
	return fmt.Errorf("unknown Account field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AccountMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, account.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, account.FieldUpdatedBy)
	}
	if m.adddeleted_by != nil {
		fields = append(fields, account.FieldDeletedBy)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AccountMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case account.FieldCreatedBy:
		return m.AddedCreatedBy()
	case account.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case account.FieldDeletedBy:
		return m.AddedDeletedBy()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AccountMutation) AddField(name string, value ent.Value) error {
	switch name {
	case account.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case account.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case account.FieldDeletedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedBy(v)
		return nil
	}
	return fmt.Errorf("unknown Account numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AccountMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(account.FieldCreatedBy) {
		fields = append(fields, account.FieldCreatedBy)
	}
	if m.FieldCleared(account.FieldUpdatedBy) {
		fields = append(fields, account.FieldUpdatedBy)
	}
	if m.FieldCleared(account.FieldDeletedBy) {
		fields = append(fields, account.FieldDeletedBy)
	}
	if m.FieldCleared(account.FieldDeletedAt) {
		fields = append(fields, account.FieldDeletedAt)
	}
	if m.FieldCleared(account.FieldSubscribedToNewsletterAt) {
		fields = append(fields, account.FieldSubscribedToNewsletterAt)
	}
	if m.FieldCleared(account.FieldTemporaryPasswordExpiresAt) {
		fields = append(fields, account.FieldTemporaryPasswordExpiresAt)
	}
	if m.FieldCleared(account.FieldLastLoginAttemptAt) {
		fields = append(fields, account.FieldLastLoginAttemptAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AccountMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AccountMutation) ClearField(name string) error {
	switch name {
	case account.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case account.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case account.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case account.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case account.FieldSubscribedToNewsletterAt:
		m.ClearSubscribedToNewsletterAt()
		return nil
	case account.FieldTemporaryPasswordExpiresAt:
		m.ClearTemporaryPasswordExpiresAt()
		return nil
	case account.FieldLastLoginAttemptAt:
		m.ClearLastLoginAttemptAt()
		return nil
	}
	return fmt.Errorf("unknown Account nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AccountMutation) ResetField(name string) error {
	switch name {
	case account.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case account.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case account.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case account.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case account.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case account.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case account.FieldPublicID:
		m.ResetPublicID()
		return nil
	case account.FieldEmail:
		m.ResetEmail()
		return nil
	case account.FieldFirstName:
		m.ResetFirstName()
		return nil
	case account.FieldLastName:
		m.ResetLastName()
		return nil
	case account.FieldLanguage:
		m.ResetLanguage()
		return nil
	case account.FieldSubscribedToNewsletterAt:
		m.ResetSubscribedToNewsletterAt()
		return nil
	case account.FieldPasswordSalt:
		m.ResetPasswordSalt()
		return nil
	case account.FieldPasswordHash:
		m.ResetPasswordHash()
		return nil
	case account.FieldTemporaryPasswordSalt:
		m.ResetTemporaryPasswordSalt()
		return nil
	case account.FieldTemporaryPasswordHash:
		m.ResetTemporaryPasswordHash()
		return nil
	case account.FieldTemporaryPasswordExpiresAt:
		m.ResetTemporaryPasswordExpiresAt()
		return nil
	case account.FieldTemporaryTwoFactorAuthKeyEncrypted:
		m.ResetTemporaryTwoFactorAuthKeyEncrypted()
		return nil
	case account.FieldTwoFactoryAuthKeyEncrypted:
		m.ResetTwoFactoryAuthKeyEncrypted()
		return nil
	case account.FieldTwoFactorAuthRecoveryCodeSalt:
		m.ResetTwoFactorAuthRecoveryCodeSalt()
		return nil
	case account.FieldTwoFactorAuthRecoveryCodeHashes:
		m.ResetTwoFactorAuthRecoveryCodeHashes()
		return nil
	case account.FieldLastLoginAttemptAt:
		m.ResetLastLoginAttemptAt()
		return nil
	case account.FieldRole:
		m.ResetRole()
		return nil
	}
	return fmt.Errorf("unknown Account field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AccountMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.tenants != nil {
		edges = append(edges, account.EdgeTenants)
	}
	if m.received_mails != nil {
		edges = append(edges, account.EdgeReceivedMails)
	}
	if m.temporary_files != nil {
		edges = append(edges, account.EdgeTemporaryFiles)
	}
	if m.tenant_assignment != nil {
		edges = append(edges, account.EdgeTenantAssignment)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AccountMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case account.EdgeTenants:
		ids := make([]ent.Value, 0, len(m.tenants))
		for id := range m.tenants {
			ids = append(ids, id)
		}
		return ids
	case account.EdgeReceivedMails:
		ids := make([]ent.Value, 0, len(m.received_mails))
		for id := range m.received_mails {
			ids = append(ids, id)
		}
		return ids
	case account.EdgeTemporaryFiles:
		ids := make([]ent.Value, 0, len(m.temporary_files))
		for id := range m.temporary_files {
			ids = append(ids, id)
		}
		return ids
	case account.EdgeTenantAssignment:
		ids := make([]ent.Value, 0, len(m.tenant_assignment))
		for id := range m.tenant_assignment {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AccountMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	if m.removedtenants != nil {
		edges = append(edges, account.EdgeTenants)
	}
	if m.removedreceived_mails != nil {
		edges = append(edges, account.EdgeReceivedMails)
	}
	if m.removedtemporary_files != nil {
		edges = append(edges, account.EdgeTemporaryFiles)
	}
	if m.removedtenant_assignment != nil {
		edges = append(edges, account.EdgeTenantAssignment)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AccountMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case account.EdgeTenants:
		ids := make([]ent.Value, 0, len(m.removedtenants))
		for id := range m.removedtenants {
			ids = append(ids, id)
		}
		return ids
	case account.EdgeReceivedMails:
		ids := make([]ent.Value, 0, len(m.removedreceived_mails))
		for id := range m.removedreceived_mails {
			ids = append(ids, id)
		}
		return ids
	case account.EdgeTemporaryFiles:
		ids := make([]ent.Value, 0, len(m.removedtemporary_files))
		for id := range m.removedtemporary_files {
			ids = append(ids, id)
		}
		return ids
	case account.EdgeTenantAssignment:
		ids := make([]ent.Value, 0, len(m.removedtenant_assignment))
		for id := range m.removedtenant_assignment {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AccountMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedtenants {
		edges = append(edges, account.EdgeTenants)
	}
	if m.clearedreceived_mails {
		edges = append(edges, account.EdgeReceivedMails)
	}
	if m.clearedtemporary_files {
		edges = append(edges, account.EdgeTemporaryFiles)
	}
	if m.clearedtenant_assignment {
		edges = append(edges, account.EdgeTenantAssignment)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AccountMutation) EdgeCleared(name string) bool {
	switch name {
	case account.EdgeTenants:
		return m.clearedtenants
	case account.EdgeReceivedMails:
		return m.clearedreceived_mails
	case account.EdgeTemporaryFiles:
		return m.clearedtemporary_files
	case account.EdgeTenantAssignment:
		return m.clearedtenant_assignment
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AccountMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Account unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AccountMutation) ResetEdge(name string) error {
	switch name {
	case account.EdgeTenants:
		m.ResetTenants()
		return nil
	case account.EdgeReceivedMails:
		m.ResetReceivedMails()
		return nil
	case account.EdgeTemporaryFiles:
		m.ResetTemporaryFiles()
		return nil
	case account.EdgeTenantAssignment:
		m.ResetTenantAssignment()
		return nil
	}
	return fmt.Errorf("unknown Account edge %s", name)
}

// MailMutation represents an operation that mutates the Mail nodes in the graph.
type MailMutation struct {
	config
	op              Op
	typ             string
	id              *int64
	created_at      *time.Time
	updated_at      *time.Time
	subject         *string
	body            *string
	html_body       *string
	sent_at         *time.Time
	last_tried_at   *time.Time
	retry_count     *int
	addretry_count  *int
	clearedFields   map[string]struct{}
	creator         *int64
	clearedcreator  bool
	updater         *int64
	clearedupdater  bool
	receiver        *int64
	clearedreceiver bool
	done            bool
	oldValue        func(context.Context) (*Mail, error)
	predicates      []predicate.Mail
}

var _ ent.Mutation = (*MailMutation)(nil)

// mailOption allows management of the mutation configuration using functional options.
type mailOption func(*MailMutation)

// newMailMutation creates new mutation for the Mail entity.
func newMailMutation(c config, op Op, opts ...mailOption) *MailMutation {
	m := &MailMutation{
		config:        c,
		op:            op,
		typ:           TypeMail,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withMailID sets the ID field of the mutation.
func withMailID(id int64) mailOption {
	return func(m *MailMutation) {
		var (
			err   error
			once  sync.Once
			value *Mail
		)
		m.oldValue = func(ctx context.Context) (*Mail, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Mail.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withMail sets the old Mail of the mutation.
func withMail(node *Mail) mailOption {
	return func(m *MailMutation) {
		m.oldValue = func(context.Context) (*Mail, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m MailMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m MailMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("entmain: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Mail entities.
func (m *MailMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *MailMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *MailMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Mail.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *MailMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *MailMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Mail entity.
// If the Mail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MailMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *MailMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *MailMutation) SetCreatedBy(i int64) {
	m.creator = &i
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *MailMutation) CreatedBy() (r int64, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Mail entity.
// If the Mail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MailMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *MailMutation) ClearCreatedBy() {
	m.creator = nil
	m.clearedFields[mail.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *MailMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[mail.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *MailMutation) ResetCreatedBy() {
	m.creator = nil
	delete(m.clearedFields, mail.FieldCreatedBy)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *MailMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *MailMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Mail entity.
// If the Mail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MailMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *MailMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *MailMutation) SetUpdatedBy(i int64) {
	m.updater = &i
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *MailMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updater
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Mail entity.
// If the Mail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MailMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *MailMutation) ClearUpdatedBy() {
	m.updater = nil
	m.clearedFields[mail.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *MailMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[mail.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *MailMutation) ResetUpdatedBy() {
	m.updater = nil
	delete(m.clearedFields, mail.FieldUpdatedBy)
}

// SetSubject sets the "subject" field.
func (m *MailMutation) SetSubject(s string) {
	m.subject = &s
}

// Subject returns the value of the "subject" field in the mutation.
func (m *MailMutation) Subject() (r string, exists bool) {
	v := m.subject
	if v == nil {
		return
	}
	return *v, true
}

// OldSubject returns the old "subject" field's value of the Mail entity.
// If the Mail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MailMutation) OldSubject(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSubject is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSubject requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSubject: %w", err)
	}
	return oldValue.Subject, nil
}

// ResetSubject resets all changes to the "subject" field.
func (m *MailMutation) ResetSubject() {
	m.subject = nil
}

// SetBody sets the "body" field.
func (m *MailMutation) SetBody(s string) {
	m.body = &s
}

// Body returns the value of the "body" field in the mutation.
func (m *MailMutation) Body() (r string, exists bool) {
	v := m.body
	if v == nil {
		return
	}
	return *v, true
}

// OldBody returns the old "body" field's value of the Mail entity.
// If the Mail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MailMutation) OldBody(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBody is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBody requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBody: %w", err)
	}
	return oldValue.Body, nil
}

// ResetBody resets all changes to the "body" field.
func (m *MailMutation) ResetBody() {
	m.body = nil
}

// SetHTMLBody sets the "html_body" field.
func (m *MailMutation) SetHTMLBody(s string) {
	m.html_body = &s
}

// HTMLBody returns the value of the "html_body" field in the mutation.
func (m *MailMutation) HTMLBody() (r string, exists bool) {
	v := m.html_body
	if v == nil {
		return
	}
	return *v, true
}

// OldHTMLBody returns the old "html_body" field's value of the Mail entity.
// If the Mail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MailMutation) OldHTMLBody(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHTMLBody is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHTMLBody requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHTMLBody: %w", err)
	}
	return oldValue.HTMLBody, nil
}

// ClearHTMLBody clears the value of the "html_body" field.
func (m *MailMutation) ClearHTMLBody() {
	m.html_body = nil
	m.clearedFields[mail.FieldHTMLBody] = struct{}{}
}

// HTMLBodyCleared returns if the "html_body" field was cleared in this mutation.
func (m *MailMutation) HTMLBodyCleared() bool {
	_, ok := m.clearedFields[mail.FieldHTMLBody]
	return ok
}

// ResetHTMLBody resets all changes to the "html_body" field.
func (m *MailMutation) ResetHTMLBody() {
	m.html_body = nil
	delete(m.clearedFields, mail.FieldHTMLBody)
}

// SetSentAt sets the "sent_at" field.
func (m *MailMutation) SetSentAt(t time.Time) {
	m.sent_at = &t
}

// SentAt returns the value of the "sent_at" field in the mutation.
func (m *MailMutation) SentAt() (r time.Time, exists bool) {
	v := m.sent_at
	if v == nil {
		return
	}
	return *v, true
}

// OldSentAt returns the old "sent_at" field's value of the Mail entity.
// If the Mail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MailMutation) OldSentAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSentAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSentAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSentAt: %w", err)
	}
	return oldValue.SentAt, nil
}

// ClearSentAt clears the value of the "sent_at" field.
func (m *MailMutation) ClearSentAt() {
	m.sent_at = nil
	m.clearedFields[mail.FieldSentAt] = struct{}{}
}

// SentAtCleared returns if the "sent_at" field was cleared in this mutation.
func (m *MailMutation) SentAtCleared() bool {
	_, ok := m.clearedFields[mail.FieldSentAt]
	return ok
}

// ResetSentAt resets all changes to the "sent_at" field.
func (m *MailMutation) ResetSentAt() {
	m.sent_at = nil
	delete(m.clearedFields, mail.FieldSentAt)
}

// SetLastTriedAt sets the "last_tried_at" field.
func (m *MailMutation) SetLastTriedAt(t time.Time) {
	m.last_tried_at = &t
}

// LastTriedAt returns the value of the "last_tried_at" field in the mutation.
func (m *MailMutation) LastTriedAt() (r time.Time, exists bool) {
	v := m.last_tried_at
	if v == nil {
		return
	}
	return *v, true
}

// OldLastTriedAt returns the old "last_tried_at" field's value of the Mail entity.
// If the Mail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MailMutation) OldLastTriedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastTriedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastTriedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastTriedAt: %w", err)
	}
	return oldValue.LastTriedAt, nil
}

// ResetLastTriedAt resets all changes to the "last_tried_at" field.
func (m *MailMutation) ResetLastTriedAt() {
	m.last_tried_at = nil
}

// SetRetryCount sets the "retry_count" field.
func (m *MailMutation) SetRetryCount(i int) {
	m.retry_count = &i
	m.addretry_count = nil
}

// RetryCount returns the value of the "retry_count" field in the mutation.
func (m *MailMutation) RetryCount() (r int, exists bool) {
	v := m.retry_count
	if v == nil {
		return
	}
	return *v, true
}

// OldRetryCount returns the old "retry_count" field's value of the Mail entity.
// If the Mail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MailMutation) OldRetryCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRetryCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRetryCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRetryCount: %w", err)
	}
	return oldValue.RetryCount, nil
}

// AddRetryCount adds i to the "retry_count" field.
func (m *MailMutation) AddRetryCount(i int) {
	if m.addretry_count != nil {
		*m.addretry_count += i
	} else {
		m.addretry_count = &i
	}
}

// AddedRetryCount returns the value that was added to the "retry_count" field in this mutation.
func (m *MailMutation) AddedRetryCount() (r int, exists bool) {
	v := m.addretry_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetRetryCount resets all changes to the "retry_count" field.
func (m *MailMutation) ResetRetryCount() {
	m.retry_count = nil
	m.addretry_count = nil
}

// SetReceiverID sets the "receiver_id" field.
func (m *MailMutation) SetReceiverID(i int64) {
	m.receiver = &i
}

// ReceiverID returns the value of the "receiver_id" field in the mutation.
func (m *MailMutation) ReceiverID() (r int64, exists bool) {
	v := m.receiver
	if v == nil {
		return
	}
	return *v, true
}

// OldReceiverID returns the old "receiver_id" field's value of the Mail entity.
// If the Mail object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *MailMutation) OldReceiverID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldReceiverID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldReceiverID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldReceiverID: %w", err)
	}
	return oldValue.ReceiverID, nil
}

// ResetReceiverID resets all changes to the "receiver_id" field.
func (m *MailMutation) ResetReceiverID() {
	m.receiver = nil
}

// SetCreatorID sets the "creator" edge to the Account entity by id.
func (m *MailMutation) SetCreatorID(id int64) {
	m.creator = &id
}

// ClearCreator clears the "creator" edge to the Account entity.
func (m *MailMutation) ClearCreator() {
	m.clearedcreator = true
	m.clearedFields[mail.FieldCreatedBy] = struct{}{}
}

// CreatorCleared reports if the "creator" edge to the Account entity was cleared.
func (m *MailMutation) CreatorCleared() bool {
	return m.CreatedByCleared() || m.clearedcreator
}

// CreatorID returns the "creator" edge ID in the mutation.
func (m *MailMutation) CreatorID() (id int64, exists bool) {
	if m.creator != nil {
		return *m.creator, true
	}
	return
}

// CreatorIDs returns the "creator" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreatorID instead. It exists only for internal usage by the builders.
func (m *MailMutation) CreatorIDs() (ids []int64) {
	if id := m.creator; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreator resets all changes to the "creator" edge.
func (m *MailMutation) ResetCreator() {
	m.creator = nil
	m.clearedcreator = false
}

// SetUpdaterID sets the "updater" edge to the Account entity by id.
func (m *MailMutation) SetUpdaterID(id int64) {
	m.updater = &id
}

// ClearUpdater clears the "updater" edge to the Account entity.
func (m *MailMutation) ClearUpdater() {
	m.clearedupdater = true
	m.clearedFields[mail.FieldUpdatedBy] = struct{}{}
}

// UpdaterCleared reports if the "updater" edge to the Account entity was cleared.
func (m *MailMutation) UpdaterCleared() bool {
	return m.UpdatedByCleared() || m.clearedupdater
}

// UpdaterID returns the "updater" edge ID in the mutation.
func (m *MailMutation) UpdaterID() (id int64, exists bool) {
	if m.updater != nil {
		return *m.updater, true
	}
	return
}

// UpdaterIDs returns the "updater" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UpdaterID instead. It exists only for internal usage by the builders.
func (m *MailMutation) UpdaterIDs() (ids []int64) {
	if id := m.updater; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUpdater resets all changes to the "updater" edge.
func (m *MailMutation) ResetUpdater() {
	m.updater = nil
	m.clearedupdater = false
}

// ClearReceiver clears the "receiver" edge to the Account entity.
func (m *MailMutation) ClearReceiver() {
	m.clearedreceiver = true
	m.clearedFields[mail.FieldReceiverID] = struct{}{}
}

// ReceiverCleared reports if the "receiver" edge to the Account entity was cleared.
func (m *MailMutation) ReceiverCleared() bool {
	return m.clearedreceiver
}

// ReceiverIDs returns the "receiver" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ReceiverID instead. It exists only for internal usage by the builders.
func (m *MailMutation) ReceiverIDs() (ids []int64) {
	if id := m.receiver; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetReceiver resets all changes to the "receiver" edge.
func (m *MailMutation) ResetReceiver() {
	m.receiver = nil
	m.clearedreceiver = false
}

// Where appends a list predicates to the MailMutation builder.
func (m *MailMutation) Where(ps ...predicate.Mail) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the MailMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *MailMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Mail, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *MailMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *MailMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Mail).
func (m *MailMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *MailMutation) Fields() []string {
	fields := make([]string, 0, 11)
	if m.created_at != nil {
		fields = append(fields, mail.FieldCreatedAt)
	}
	if m.creator != nil {
		fields = append(fields, mail.FieldCreatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, mail.FieldUpdatedAt)
	}
	if m.updater != nil {
		fields = append(fields, mail.FieldUpdatedBy)
	}
	if m.subject != nil {
		fields = append(fields, mail.FieldSubject)
	}
	if m.body != nil {
		fields = append(fields, mail.FieldBody)
	}
	if m.html_body != nil {
		fields = append(fields, mail.FieldHTMLBody)
	}
	if m.sent_at != nil {
		fields = append(fields, mail.FieldSentAt)
	}
	if m.last_tried_at != nil {
		fields = append(fields, mail.FieldLastTriedAt)
	}
	if m.retry_count != nil {
		fields = append(fields, mail.FieldRetryCount)
	}
	if m.receiver != nil {
		fields = append(fields, mail.FieldReceiverID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *MailMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case mail.FieldCreatedAt:
		return m.CreatedAt()
	case mail.FieldCreatedBy:
		return m.CreatedBy()
	case mail.FieldUpdatedAt:
		return m.UpdatedAt()
	case mail.FieldUpdatedBy:
		return m.UpdatedBy()
	case mail.FieldSubject:
		return m.Subject()
	case mail.FieldBody:
		return m.Body()
	case mail.FieldHTMLBody:
		return m.HTMLBody()
	case mail.FieldSentAt:
		return m.SentAt()
	case mail.FieldLastTriedAt:
		return m.LastTriedAt()
	case mail.FieldRetryCount:
		return m.RetryCount()
	case mail.FieldReceiverID:
		return m.ReceiverID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *MailMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case mail.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case mail.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case mail.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case mail.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case mail.FieldSubject:
		return m.OldSubject(ctx)
	case mail.FieldBody:
		return m.OldBody(ctx)
	case mail.FieldHTMLBody:
		return m.OldHTMLBody(ctx)
	case mail.FieldSentAt:
		return m.OldSentAt(ctx)
	case mail.FieldLastTriedAt:
		return m.OldLastTriedAt(ctx)
	case mail.FieldRetryCount:
		return m.OldRetryCount(ctx)
	case mail.FieldReceiverID:
		return m.OldReceiverID(ctx)
	}
	return nil, fmt.Errorf("unknown Mail field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MailMutation) SetField(name string, value ent.Value) error {
	switch name {
	case mail.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case mail.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case mail.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case mail.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case mail.FieldSubject:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSubject(v)
		return nil
	case mail.FieldBody:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBody(v)
		return nil
	case mail.FieldHTMLBody:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHTMLBody(v)
		return nil
	case mail.FieldSentAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSentAt(v)
		return nil
	case mail.FieldLastTriedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastTriedAt(v)
		return nil
	case mail.FieldRetryCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRetryCount(v)
		return nil
	case mail.FieldReceiverID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetReceiverID(v)
		return nil
	}
	return fmt.Errorf("unknown Mail field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *MailMutation) AddedFields() []string {
	var fields []string
	if m.addretry_count != nil {
		fields = append(fields, mail.FieldRetryCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *MailMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case mail.FieldRetryCount:
		return m.AddedRetryCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *MailMutation) AddField(name string, value ent.Value) error {
	switch name {
	case mail.FieldRetryCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRetryCount(v)
		return nil
	}
	return fmt.Errorf("unknown Mail numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *MailMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(mail.FieldCreatedBy) {
		fields = append(fields, mail.FieldCreatedBy)
	}
	if m.FieldCleared(mail.FieldUpdatedBy) {
		fields = append(fields, mail.FieldUpdatedBy)
	}
	if m.FieldCleared(mail.FieldHTMLBody) {
		fields = append(fields, mail.FieldHTMLBody)
	}
	if m.FieldCleared(mail.FieldSentAt) {
		fields = append(fields, mail.FieldSentAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *MailMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *MailMutation) ClearField(name string) error {
	switch name {
	case mail.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case mail.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case mail.FieldHTMLBody:
		m.ClearHTMLBody()
		return nil
	case mail.FieldSentAt:
		m.ClearSentAt()
		return nil
	}
	return fmt.Errorf("unknown Mail nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *MailMutation) ResetField(name string) error {
	switch name {
	case mail.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case mail.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case mail.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case mail.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case mail.FieldSubject:
		m.ResetSubject()
		return nil
	case mail.FieldBody:
		m.ResetBody()
		return nil
	case mail.FieldHTMLBody:
		m.ResetHTMLBody()
		return nil
	case mail.FieldSentAt:
		m.ResetSentAt()
		return nil
	case mail.FieldLastTriedAt:
		m.ResetLastTriedAt()
		return nil
	case mail.FieldRetryCount:
		m.ResetRetryCount()
		return nil
	case mail.FieldReceiverID:
		m.ResetReceiverID()
		return nil
	}
	return fmt.Errorf("unknown Mail field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *MailMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.creator != nil {
		edges = append(edges, mail.EdgeCreator)
	}
	if m.updater != nil {
		edges = append(edges, mail.EdgeUpdater)
	}
	if m.receiver != nil {
		edges = append(edges, mail.EdgeReceiver)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *MailMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case mail.EdgeCreator:
		if id := m.creator; id != nil {
			return []ent.Value{*id}
		}
	case mail.EdgeUpdater:
		if id := m.updater; id != nil {
			return []ent.Value{*id}
		}
	case mail.EdgeReceiver:
		if id := m.receiver; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *MailMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *MailMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *MailMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedcreator {
		edges = append(edges, mail.EdgeCreator)
	}
	if m.clearedupdater {
		edges = append(edges, mail.EdgeUpdater)
	}
	if m.clearedreceiver {
		edges = append(edges, mail.EdgeReceiver)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *MailMutation) EdgeCleared(name string) bool {
	switch name {
	case mail.EdgeCreator:
		return m.clearedcreator
	case mail.EdgeUpdater:
		return m.clearedupdater
	case mail.EdgeReceiver:
		return m.clearedreceiver
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *MailMutation) ClearEdge(name string) error {
	switch name {
	case mail.EdgeCreator:
		m.ClearCreator()
		return nil
	case mail.EdgeUpdater:
		m.ClearUpdater()
		return nil
	case mail.EdgeReceiver:
		m.ClearReceiver()
		return nil
	}
	return fmt.Errorf("unknown Mail unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *MailMutation) ResetEdge(name string) error {
	switch name {
	case mail.EdgeCreator:
		m.ResetCreator()
		return nil
	case mail.EdgeUpdater:
		m.ResetUpdater()
		return nil
	case mail.EdgeReceiver:
		m.ResetReceiver()
		return nil
	}
	return fmt.Errorf("unknown Mail edge %s", name)
}

// SessionMutation represents an operation that mutates the Session nodes in the graph.
type SessionMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int64
	value                *string
	is_temporary_session *bool
	expires_at           *time.Time
	deletable_at         *time.Time
	created_at           *time.Time
	updated_at           *time.Time
	clearedFields        map[string]struct{}
	account              *int64
	clearedaccount       bool
	done                 bool
	oldValue             func(context.Context) (*Session, error)
	predicates           []predicate.Session
}

var _ ent.Mutation = (*SessionMutation)(nil)

// sessionOption allows management of the mutation configuration using functional options.
type sessionOption func(*SessionMutation)

// newSessionMutation creates new mutation for the Session entity.
func newSessionMutation(c config, op Op, opts ...sessionOption) *SessionMutation {
	m := &SessionMutation{
		config:        c,
		op:            op,
		typ:           TypeSession,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSessionID sets the ID field of the mutation.
func withSessionID(id int64) sessionOption {
	return func(m *SessionMutation) {
		var (
			err   error
			once  sync.Once
			value *Session
		)
		m.oldValue = func(ctx context.Context) (*Session, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Session.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSession sets the old Session of the mutation.
func withSession(node *Session) sessionOption {
	return func(m *SessionMutation) {
		m.oldValue = func(context.Context) (*Session, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SessionMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SessionMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("entmain: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Session entities.
func (m *SessionMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SessionMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SessionMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Session.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetValue sets the "value" field.
func (m *SessionMutation) SetValue(s string) {
	m.value = &s
}

// Value returns the value of the "value" field in the mutation.
func (m *SessionMutation) Value() (r string, exists bool) {
	v := m.value
	if v == nil {
		return
	}
	return *v, true
}

// OldValue returns the old "value" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldValue: %w", err)
	}
	return oldValue.Value, nil
}

// ResetValue resets all changes to the "value" field.
func (m *SessionMutation) ResetValue() {
	m.value = nil
}

// SetAccountID sets the "account_id" field.
func (m *SessionMutation) SetAccountID(i int64) {
	m.account = &i
}

// AccountID returns the value of the "account_id" field in the mutation.
func (m *SessionMutation) AccountID() (r int64, exists bool) {
	v := m.account
	if v == nil {
		return
	}
	return *v, true
}

// OldAccountID returns the old "account_id" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldAccountID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccountID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccountID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccountID: %w", err)
	}
	return oldValue.AccountID, nil
}

// ResetAccountID resets all changes to the "account_id" field.
func (m *SessionMutation) ResetAccountID() {
	m.account = nil
}

// SetIsTemporarySession sets the "is_temporary_session" field.
func (m *SessionMutation) SetIsTemporarySession(b bool) {
	m.is_temporary_session = &b
}

// IsTemporarySession returns the value of the "is_temporary_session" field in the mutation.
func (m *SessionMutation) IsTemporarySession() (r bool, exists bool) {
	v := m.is_temporary_session
	if v == nil {
		return
	}
	return *v, true
}

// OldIsTemporarySession returns the old "is_temporary_session" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldIsTemporarySession(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsTemporarySession is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsTemporarySession requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsTemporarySession: %w", err)
	}
	return oldValue.IsTemporarySession, nil
}

// ResetIsTemporarySession resets all changes to the "is_temporary_session" field.
func (m *SessionMutation) ResetIsTemporarySession() {
	m.is_temporary_session = nil
}

// SetExpiresAt sets the "expires_at" field.
func (m *SessionMutation) SetExpiresAt(t time.Time) {
	m.expires_at = &t
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *SessionMutation) ExpiresAt() (r time.Time, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldExpiresAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *SessionMutation) ResetExpiresAt() {
	m.expires_at = nil
}

// SetDeletableAt sets the "deletable_at" field.
func (m *SessionMutation) SetDeletableAt(t time.Time) {
	m.deletable_at = &t
}

// DeletableAt returns the value of the "deletable_at" field in the mutation.
func (m *SessionMutation) DeletableAt() (r time.Time, exists bool) {
	v := m.deletable_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletableAt returns the old "deletable_at" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldDeletableAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletableAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletableAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletableAt: %w", err)
	}
	return oldValue.DeletableAt, nil
}

// ResetDeletableAt resets all changes to the "deletable_at" field.
func (m *SessionMutation) ResetDeletableAt() {
	m.deletable_at = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *SessionMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SessionMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SessionMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SessionMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SessionMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Session entity.
// If the Session object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SessionMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SessionMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// ClearAccount clears the "account" edge to the Account entity.
func (m *SessionMutation) ClearAccount() {
	m.clearedaccount = true
	m.clearedFields[session.FieldAccountID] = struct{}{}
}

// AccountCleared reports if the "account" edge to the Account entity was cleared.
func (m *SessionMutation) AccountCleared() bool {
	return m.clearedaccount
}

// AccountIDs returns the "account" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AccountID instead. It exists only for internal usage by the builders.
func (m *SessionMutation) AccountIDs() (ids []int64) {
	if id := m.account; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAccount resets all changes to the "account" edge.
func (m *SessionMutation) ResetAccount() {
	m.account = nil
	m.clearedaccount = false
}

// Where appends a list predicates to the SessionMutation builder.
func (m *SessionMutation) Where(ps ...predicate.Session) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SessionMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SessionMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Session, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SessionMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SessionMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Session).
func (m *SessionMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SessionMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.value != nil {
		fields = append(fields, session.FieldValue)
	}
	if m.account != nil {
		fields = append(fields, session.FieldAccountID)
	}
	if m.is_temporary_session != nil {
		fields = append(fields, session.FieldIsTemporarySession)
	}
	if m.expires_at != nil {
		fields = append(fields, session.FieldExpiresAt)
	}
	if m.deletable_at != nil {
		fields = append(fields, session.FieldDeletableAt)
	}
	if m.created_at != nil {
		fields = append(fields, session.FieldCreatedAt)
	}
	if m.updated_at != nil {
		fields = append(fields, session.FieldUpdatedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SessionMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case session.FieldValue:
		return m.Value()
	case session.FieldAccountID:
		return m.AccountID()
	case session.FieldIsTemporarySession:
		return m.IsTemporarySession()
	case session.FieldExpiresAt:
		return m.ExpiresAt()
	case session.FieldDeletableAt:
		return m.DeletableAt()
	case session.FieldCreatedAt:
		return m.CreatedAt()
	case session.FieldUpdatedAt:
		return m.UpdatedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SessionMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case session.FieldValue:
		return m.OldValue(ctx)
	case session.FieldAccountID:
		return m.OldAccountID(ctx)
	case session.FieldIsTemporarySession:
		return m.OldIsTemporarySession(ctx)
	case session.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	case session.FieldDeletableAt:
		return m.OldDeletableAt(ctx)
	case session.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case session.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Session field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SessionMutation) SetField(name string, value ent.Value) error {
	switch name {
	case session.FieldValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetValue(v)
		return nil
	case session.FieldAccountID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccountID(v)
		return nil
	case session.FieldIsTemporarySession:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsTemporarySession(v)
		return nil
	case session.FieldExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	case session.FieldDeletableAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletableAt(v)
		return nil
	case session.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case session.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Session field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SessionMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SessionMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SessionMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Session numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SessionMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SessionMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SessionMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Session nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SessionMutation) ResetField(name string) error {
	switch name {
	case session.FieldValue:
		m.ResetValue()
		return nil
	case session.FieldAccountID:
		m.ResetAccountID()
		return nil
	case session.FieldIsTemporarySession:
		m.ResetIsTemporarySession()
		return nil
	case session.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	case session.FieldDeletableAt:
		m.ResetDeletableAt()
		return nil
	case session.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case session.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	}
	return fmt.Errorf("unknown Session field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SessionMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.account != nil {
		edges = append(edges, session.EdgeAccount)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SessionMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case session.EdgeAccount:
		if id := m.account; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SessionMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SessionMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SessionMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedaccount {
		edges = append(edges, session.EdgeAccount)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SessionMutation) EdgeCleared(name string) bool {
	switch name {
	case session.EdgeAccount:
		return m.clearedaccount
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SessionMutation) ClearEdge(name string) error {
	switch name {
	case session.EdgeAccount:
		m.ClearAccount()
		return nil
	}
	return fmt.Errorf("unknown Session unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SessionMutation) ResetEdge(name string) error {
	switch name {
	case session.EdgeAccount:
		m.ResetAccount()
		return nil
	}
	return fmt.Errorf("unknown Session edge %s", name)
}

// SystemConfigMutation represents an operation that mutates the SystemConfig nodes in the graph.
type SystemConfigMutation struct {
	config
	op                                    Op
	typ                                   string
	id                                    *int64
	created_at                            *time.Time
	updated_at                            *time.Time
	x25519_identity                       *[]byte
	is_identity_encrypted_with_passphrase *bool
	s3_endpoint                           *string
	s3_access_key_id                      *string
	s3_secret_access_key                  *entx.EncryptedString
	s3_bucket_name                        *string
	s3_use_ssl                            *bool
	tls_enable_autocert                   *bool
	tls_cert_filepath                     *string
	tls_private_key_filepath              *string
	tls_autocert_email                    *string
	tls_autocert_hosts                    *[]string
	appendtls_autocert_hosts              []string
	mailer_host                           *string
	mailer_port                           *int
	addmailer_port                        *int
	mailer_username                       *string
	mailer_password                       *entx.EncryptedString
	mailer_from                           *string
	mailer_insecure_skip_verify           *bool
	mailer_use_implicit_ssl_tls           *bool
	ocr_tika_url                          *string
	ocr_max_file_size_mib                 *int64
	addocr_max_file_size_mib              *int64
	initialized_at                        *time.Time
	clearedFields                         map[string]struct{}
	creator                               *int64
	clearedcreator                        bool
	updater                               *int64
	clearedupdater                        bool
	done                                  bool
	oldValue                              func(context.Context) (*SystemConfig, error)
	predicates                            []predicate.SystemConfig
}

var _ ent.Mutation = (*SystemConfigMutation)(nil)

// systemconfigOption allows management of the mutation configuration using functional options.
type systemconfigOption func(*SystemConfigMutation)

// newSystemConfigMutation creates new mutation for the SystemConfig entity.
func newSystemConfigMutation(c config, op Op, opts ...systemconfigOption) *SystemConfigMutation {
	m := &SystemConfigMutation{
		config:        c,
		op:            op,
		typ:           TypeSystemConfig,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSystemConfigID sets the ID field of the mutation.
func withSystemConfigID(id int64) systemconfigOption {
	return func(m *SystemConfigMutation) {
		var (
			err   error
			once  sync.Once
			value *SystemConfig
		)
		m.oldValue = func(ctx context.Context) (*SystemConfig, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SystemConfig.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSystemConfig sets the old SystemConfig of the mutation.
func withSystemConfig(node *SystemConfig) systemconfigOption {
	return func(m *SystemConfigMutation) {
		m.oldValue = func(context.Context) (*SystemConfig, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SystemConfigMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SystemConfigMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("entmain: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of SystemConfig entities.
func (m *SystemConfigMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SystemConfigMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SystemConfigMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SystemConfig.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *SystemConfigMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SystemConfigMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the SystemConfig entity.
// If the SystemConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemConfigMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SystemConfigMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *SystemConfigMutation) SetCreatedBy(i int64) {
	m.creator = &i
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *SystemConfigMutation) CreatedBy() (r int64, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the SystemConfig entity.
// If the SystemConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemConfigMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *SystemConfigMutation) ClearCreatedBy() {
	m.creator = nil
	m.clearedFields[systemconfig.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *SystemConfigMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[systemconfig.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *SystemConfigMutation) ResetCreatedBy() {
	m.creator = nil
	delete(m.clearedFields, systemconfig.FieldCreatedBy)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SystemConfigMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SystemConfigMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the SystemConfig entity.
// If the SystemConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemConfigMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SystemConfigMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *SystemConfigMutation) SetUpdatedBy(i int64) {
	m.updater = &i
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *SystemConfigMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updater
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the SystemConfig entity.
// If the SystemConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemConfigMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *SystemConfigMutation) ClearUpdatedBy() {
	m.updater = nil
	m.clearedFields[systemconfig.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *SystemConfigMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[systemconfig.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *SystemConfigMutation) ResetUpdatedBy() {
	m.updater = nil
	delete(m.clearedFields, systemconfig.FieldUpdatedBy)
}

// SetX25519Identity sets the "x25519_identity" field.
func (m *SystemConfigMutation) SetX25519Identity(b []byte) {
	m.x25519_identity = &b
}

// X25519Identity returns the value of the "x25519_identity" field in the mutation.
func (m *SystemConfigMutation) X25519Identity() (r []byte, exists bool) {
	v := m.x25519_identity
	if v == nil {
		return
	}
	return *v, true
}

// OldX25519Identity returns the old "x25519_identity" field's value of the SystemConfig entity.
// If the SystemConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemConfigMutation) OldX25519Identity(ctx context.Context) (v []byte, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldX25519Identity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldX25519Identity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldX25519Identity: %w", err)
	}
	return oldValue.X25519Identity, nil
}

// ResetX25519Identity resets all changes to the "x25519_identity" field.
func (m *SystemConfigMutation) ResetX25519Identity() {
	m.x25519_identity = nil
}

// SetIsIdentityEncryptedWithPassphrase sets the "is_identity_encrypted_with_passphrase" field.
func (m *SystemConfigMutation) SetIsIdentityEncryptedWithPassphrase(b bool) {
	m.is_identity_encrypted_with_passphrase = &b
}

// IsIdentityEncryptedWithPassphrase returns the value of the "is_identity_encrypted_with_passphrase" field in the mutation.
func (m *SystemConfigMutation) IsIdentityEncryptedWithPassphrase() (r bool, exists bool) {
	v := m.is_identity_encrypted_with_passphrase
	if v == nil {
		return
	}
	return *v, true
}

// OldIsIdentityEncryptedWithPassphrase returns the old "is_identity_encrypted_with_passphrase" field's value of the SystemConfig entity.
// If the SystemConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemConfigMutation) OldIsIdentityEncryptedWithPassphrase(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsIdentityEncryptedWithPassphrase is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsIdentityEncryptedWithPassphrase requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsIdentityEncryptedWithPassphrase: %w", err)
	}
	return oldValue.IsIdentityEncryptedWithPassphrase, nil
}

// ResetIsIdentityEncryptedWithPassphrase resets all changes to the "is_identity_encrypted_with_passphrase" field.
func (m *SystemConfigMutation) ResetIsIdentityEncryptedWithPassphrase() {
	m.is_identity_encrypted_with_passphrase = nil
}

// SetS3Endpoint sets the "s3_endpoint" field.
func (m *SystemConfigMutation) SetS3Endpoint(s string) {
	m.s3_endpoint = &s
}

// S3Endpoint returns the value of the "s3_endpoint" field in the mutation.
func (m *SystemConfigMutation) S3Endpoint() (r string, exists bool) {
	v := m.s3_endpoint
	if v == nil {
		return
	}
	return *v, true
}

// OldS3Endpoint returns the old "s3_endpoint" field's value of the SystemConfig entity.
// If the SystemConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemConfigMutation) OldS3Endpoint(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldS3Endpoint is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldS3Endpoint requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldS3Endpoint: %w", err)
	}
	return oldValue.S3Endpoint, nil
}

// ResetS3Endpoint resets all changes to the "s3_endpoint" field.
func (m *SystemConfigMutation) ResetS3Endpoint() {
	m.s3_endpoint = nil
}

// SetS3AccessKeyID sets the "s3_access_key_id" field.
func (m *SystemConfigMutation) SetS3AccessKeyID(s string) {
	m.s3_access_key_id = &s
}

// S3AccessKeyID returns the value of the "s3_access_key_id" field in the mutation.
func (m *SystemConfigMutation) S3AccessKeyID() (r string, exists bool) {
	v := m.s3_access_key_id
	if v == nil {
		return
	}
	return *v, true
}

// OldS3AccessKeyID returns the old "s3_access_key_id" field's value of the SystemConfig entity.
// If the SystemConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemConfigMutation) OldS3AccessKeyID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldS3AccessKeyID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldS3AccessKeyID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldS3AccessKeyID: %w", err)
	}
	return oldValue.S3AccessKeyID, nil
}

// ResetS3AccessKeyID resets all changes to the "s3_access_key_id" field.
func (m *SystemConfigMutation) ResetS3AccessKeyID() {
	m.s3_access_key_id = nil
}

// SetS3SecretAccessKey sets the "s3_secret_access_key" field.
func (m *SystemConfigMutation) SetS3SecretAccessKey(es entx.EncryptedString) {
	m.s3_secret_access_key = &es
}

// S3SecretAccessKey returns the value of the "s3_secret_access_key" field in the mutation.
func (m *SystemConfigMutation) S3SecretAccessKey() (r entx.EncryptedString, exists bool) {
	v := m.s3_secret_access_key
	if v == nil {
		return
	}
	return *v, true
}

// OldS3SecretAccessKey returns the old "s3_secret_access_key" field's value of the SystemConfig entity.
// If the SystemConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemConfigMutation) OldS3SecretAccessKey(ctx context.Context) (v entx.EncryptedString, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldS3SecretAccessKey is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldS3SecretAccessKey requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldS3SecretAccessKey: %w", err)
	}
	return oldValue.S3SecretAccessKey, nil
}

// ResetS3SecretAccessKey resets all changes to the "s3_secret_access_key" field.
func (m *SystemConfigMutation) ResetS3SecretAccessKey() {
	m.s3_secret_access_key = nil
}

// SetS3BucketName sets the "s3_bucket_name" field.
func (m *SystemConfigMutation) SetS3BucketName(s string) {
	m.s3_bucket_name = &s
}

// S3BucketName returns the value of the "s3_bucket_name" field in the mutation.
func (m *SystemConfigMutation) S3BucketName() (r string, exists bool) {
	v := m.s3_bucket_name
	if v == nil {
		return
	}
	return *v, true
}

// OldS3BucketName returns the old "s3_bucket_name" field's value of the SystemConfig entity.
// If the SystemConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemConfigMutation) OldS3BucketName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldS3BucketName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldS3BucketName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldS3BucketName: %w", err)
	}
	return oldValue.S3BucketName, nil
}

// ResetS3BucketName resets all changes to the "s3_bucket_name" field.
func (m *SystemConfigMutation) ResetS3BucketName() {
	m.s3_bucket_name = nil
}

// SetS3UseSsl sets the "s3_use_ssl" field.
func (m *SystemConfigMutation) SetS3UseSsl(b bool) {
	m.s3_use_ssl = &b
}

// S3UseSsl returns the value of the "s3_use_ssl" field in the mutation.
func (m *SystemConfigMutation) S3UseSsl() (r bool, exists bool) {
	v := m.s3_use_ssl
	if v == nil {
		return
	}
	return *v, true
}

// OldS3UseSsl returns the old "s3_use_ssl" field's value of the SystemConfig entity.
// If the SystemConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemConfigMutation) OldS3UseSsl(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldS3UseSsl is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldS3UseSsl requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldS3UseSsl: %w", err)
	}
	return oldValue.S3UseSsl, nil
}

// ResetS3UseSsl resets all changes to the "s3_use_ssl" field.
func (m *SystemConfigMutation) ResetS3UseSsl() {
	m.s3_use_ssl = nil
}

// SetTLSEnableAutocert sets the "tls_enable_autocert" field.
func (m *SystemConfigMutation) SetTLSEnableAutocert(b bool) {
	m.tls_enable_autocert = &b
}

// TLSEnableAutocert returns the value of the "tls_enable_autocert" field in the mutation.
func (m *SystemConfigMutation) TLSEnableAutocert() (r bool, exists bool) {
	v := m.tls_enable_autocert
	if v == nil {
		return
	}
	return *v, true
}

// OldTLSEnableAutocert returns the old "tls_enable_autocert" field's value of the SystemConfig entity.
// If the SystemConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemConfigMutation) OldTLSEnableAutocert(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTLSEnableAutocert is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTLSEnableAutocert requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTLSEnableAutocert: %w", err)
	}
	return oldValue.TLSEnableAutocert, nil
}

// ResetTLSEnableAutocert resets all changes to the "tls_enable_autocert" field.
func (m *SystemConfigMutation) ResetTLSEnableAutocert() {
	m.tls_enable_autocert = nil
}

// SetTLSCertFilepath sets the "tls_cert_filepath" field.
func (m *SystemConfigMutation) SetTLSCertFilepath(s string) {
	m.tls_cert_filepath = &s
}

// TLSCertFilepath returns the value of the "tls_cert_filepath" field in the mutation.
func (m *SystemConfigMutation) TLSCertFilepath() (r string, exists bool) {
	v := m.tls_cert_filepath
	if v == nil {
		return
	}
	return *v, true
}

// OldTLSCertFilepath returns the old "tls_cert_filepath" field's value of the SystemConfig entity.
// If the SystemConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemConfigMutation) OldTLSCertFilepath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTLSCertFilepath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTLSCertFilepath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTLSCertFilepath: %w", err)
	}
	return oldValue.TLSCertFilepath, nil
}

// ResetTLSCertFilepath resets all changes to the "tls_cert_filepath" field.
func (m *SystemConfigMutation) ResetTLSCertFilepath() {
	m.tls_cert_filepath = nil
}

// SetTLSPrivateKeyFilepath sets the "tls_private_key_filepath" field.
func (m *SystemConfigMutation) SetTLSPrivateKeyFilepath(s string) {
	m.tls_private_key_filepath = &s
}

// TLSPrivateKeyFilepath returns the value of the "tls_private_key_filepath" field in the mutation.
func (m *SystemConfigMutation) TLSPrivateKeyFilepath() (r string, exists bool) {
	v := m.tls_private_key_filepath
	if v == nil {
		return
	}
	return *v, true
}

// OldTLSPrivateKeyFilepath returns the old "tls_private_key_filepath" field's value of the SystemConfig entity.
// If the SystemConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemConfigMutation) OldTLSPrivateKeyFilepath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTLSPrivateKeyFilepath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTLSPrivateKeyFilepath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTLSPrivateKeyFilepath: %w", err)
	}
	return oldValue.TLSPrivateKeyFilepath, nil
}

// ResetTLSPrivateKeyFilepath resets all changes to the "tls_private_key_filepath" field.
func (m *SystemConfigMutation) ResetTLSPrivateKeyFilepath() {
	m.tls_private_key_filepath = nil
}

// SetTLSAutocertEmail sets the "tls_autocert_email" field.
func (m *SystemConfigMutation) SetTLSAutocertEmail(s string) {
	m.tls_autocert_email = &s
}

// TLSAutocertEmail returns the value of the "tls_autocert_email" field in the mutation.
func (m *SystemConfigMutation) TLSAutocertEmail() (r string, exists bool) {
	v := m.tls_autocert_email
	if v == nil {
		return
	}
	return *v, true
}

// OldTLSAutocertEmail returns the old "tls_autocert_email" field's value of the SystemConfig entity.
// If the SystemConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemConfigMutation) OldTLSAutocertEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTLSAutocertEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTLSAutocertEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTLSAutocertEmail: %w", err)
	}
	return oldValue.TLSAutocertEmail, nil
}

// ResetTLSAutocertEmail resets all changes to the "tls_autocert_email" field.
func (m *SystemConfigMutation) ResetTLSAutocertEmail() {
	m.tls_autocert_email = nil
}

// SetTLSAutocertHosts sets the "tls_autocert_hosts" field.
func (m *SystemConfigMutation) SetTLSAutocertHosts(s []string) {
	m.tls_autocert_hosts = &s
	m.appendtls_autocert_hosts = nil
}

// TLSAutocertHosts returns the value of the "tls_autocert_hosts" field in the mutation.
func (m *SystemConfigMutation) TLSAutocertHosts() (r []string, exists bool) {
	v := m.tls_autocert_hosts
	if v == nil {
		return
	}
	return *v, true
}

// OldTLSAutocertHosts returns the old "tls_autocert_hosts" field's value of the SystemConfig entity.
// If the SystemConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemConfigMutation) OldTLSAutocertHosts(ctx context.Context) (v []string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTLSAutocertHosts is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTLSAutocertHosts requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTLSAutocertHosts: %w", err)
	}
	return oldValue.TLSAutocertHosts, nil
}

// AppendTLSAutocertHosts adds s to the "tls_autocert_hosts" field.
func (m *SystemConfigMutation) AppendTLSAutocertHosts(s []string) {
	m.appendtls_autocert_hosts = append(m.appendtls_autocert_hosts, s...)
}

// AppendedTLSAutocertHosts returns the list of values that were appended to the "tls_autocert_hosts" field in this mutation.
func (m *SystemConfigMutation) AppendedTLSAutocertHosts() ([]string, bool) {
	if len(m.appendtls_autocert_hosts) == 0 {
		return nil, false
	}
	return m.appendtls_autocert_hosts, true
}

// ResetTLSAutocertHosts resets all changes to the "tls_autocert_hosts" field.
func (m *SystemConfigMutation) ResetTLSAutocertHosts() {
	m.tls_autocert_hosts = nil
	m.appendtls_autocert_hosts = nil
}

// SetMailerHost sets the "mailer_host" field.
func (m *SystemConfigMutation) SetMailerHost(s string) {
	m.mailer_host = &s
}

// MailerHost returns the value of the "mailer_host" field in the mutation.
func (m *SystemConfigMutation) MailerHost() (r string, exists bool) {
	v := m.mailer_host
	if v == nil {
		return
	}
	return *v, true
}

// OldMailerHost returns the old "mailer_host" field's value of the SystemConfig entity.
// If the SystemConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemConfigMutation) OldMailerHost(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMailerHost is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMailerHost requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMailerHost: %w", err)
	}
	return oldValue.MailerHost, nil
}

// ResetMailerHost resets all changes to the "mailer_host" field.
func (m *SystemConfigMutation) ResetMailerHost() {
	m.mailer_host = nil
}

// SetMailerPort sets the "mailer_port" field.
func (m *SystemConfigMutation) SetMailerPort(i int) {
	m.mailer_port = &i
	m.addmailer_port = nil
}

// MailerPort returns the value of the "mailer_port" field in the mutation.
func (m *SystemConfigMutation) MailerPort() (r int, exists bool) {
	v := m.mailer_port
	if v == nil {
		return
	}
	return *v, true
}

// OldMailerPort returns the old "mailer_port" field's value of the SystemConfig entity.
// If the SystemConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemConfigMutation) OldMailerPort(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMailerPort is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMailerPort requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMailerPort: %w", err)
	}
	return oldValue.MailerPort, nil
}

// AddMailerPort adds i to the "mailer_port" field.
func (m *SystemConfigMutation) AddMailerPort(i int) {
	if m.addmailer_port != nil {
		*m.addmailer_port += i
	} else {
		m.addmailer_port = &i
	}
}

// AddedMailerPort returns the value that was added to the "mailer_port" field in this mutation.
func (m *SystemConfigMutation) AddedMailerPort() (r int, exists bool) {
	v := m.addmailer_port
	if v == nil {
		return
	}
	return *v, true
}

// ResetMailerPort resets all changes to the "mailer_port" field.
func (m *SystemConfigMutation) ResetMailerPort() {
	m.mailer_port = nil
	m.addmailer_port = nil
}

// SetMailerUsername sets the "mailer_username" field.
func (m *SystemConfigMutation) SetMailerUsername(s string) {
	m.mailer_username = &s
}

// MailerUsername returns the value of the "mailer_username" field in the mutation.
func (m *SystemConfigMutation) MailerUsername() (r string, exists bool) {
	v := m.mailer_username
	if v == nil {
		return
	}
	return *v, true
}

// OldMailerUsername returns the old "mailer_username" field's value of the SystemConfig entity.
// If the SystemConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemConfigMutation) OldMailerUsername(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMailerUsername is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMailerUsername requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMailerUsername: %w", err)
	}
	return oldValue.MailerUsername, nil
}

// ResetMailerUsername resets all changes to the "mailer_username" field.
func (m *SystemConfigMutation) ResetMailerUsername() {
	m.mailer_username = nil
}

// SetMailerPassword sets the "mailer_password" field.
func (m *SystemConfigMutation) SetMailerPassword(es entx.EncryptedString) {
	m.mailer_password = &es
}

// MailerPassword returns the value of the "mailer_password" field in the mutation.
func (m *SystemConfigMutation) MailerPassword() (r entx.EncryptedString, exists bool) {
	v := m.mailer_password
	if v == nil {
		return
	}
	return *v, true
}

// OldMailerPassword returns the old "mailer_password" field's value of the SystemConfig entity.
// If the SystemConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemConfigMutation) OldMailerPassword(ctx context.Context) (v entx.EncryptedString, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMailerPassword is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMailerPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMailerPassword: %w", err)
	}
	return oldValue.MailerPassword, nil
}

// ClearMailerPassword clears the value of the "mailer_password" field.
func (m *SystemConfigMutation) ClearMailerPassword() {
	m.mailer_password = nil
	m.clearedFields[systemconfig.FieldMailerPassword] = struct{}{}
}

// MailerPasswordCleared returns if the "mailer_password" field was cleared in this mutation.
func (m *SystemConfigMutation) MailerPasswordCleared() bool {
	_, ok := m.clearedFields[systemconfig.FieldMailerPassword]
	return ok
}

// ResetMailerPassword resets all changes to the "mailer_password" field.
func (m *SystemConfigMutation) ResetMailerPassword() {
	m.mailer_password = nil
	delete(m.clearedFields, systemconfig.FieldMailerPassword)
}

// SetMailerFrom sets the "mailer_from" field.
func (m *SystemConfigMutation) SetMailerFrom(s string) {
	m.mailer_from = &s
}

// MailerFrom returns the value of the "mailer_from" field in the mutation.
func (m *SystemConfigMutation) MailerFrom() (r string, exists bool) {
	v := m.mailer_from
	if v == nil {
		return
	}
	return *v, true
}

// OldMailerFrom returns the old "mailer_from" field's value of the SystemConfig entity.
// If the SystemConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemConfigMutation) OldMailerFrom(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMailerFrom is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMailerFrom requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMailerFrom: %w", err)
	}
	return oldValue.MailerFrom, nil
}

// ResetMailerFrom resets all changes to the "mailer_from" field.
func (m *SystemConfigMutation) ResetMailerFrom() {
	m.mailer_from = nil
}

// SetMailerInsecureSkipVerify sets the "mailer_insecure_skip_verify" field.
func (m *SystemConfigMutation) SetMailerInsecureSkipVerify(b bool) {
	m.mailer_insecure_skip_verify = &b
}

// MailerInsecureSkipVerify returns the value of the "mailer_insecure_skip_verify" field in the mutation.
func (m *SystemConfigMutation) MailerInsecureSkipVerify() (r bool, exists bool) {
	v := m.mailer_insecure_skip_verify
	if v == nil {
		return
	}
	return *v, true
}

// OldMailerInsecureSkipVerify returns the old "mailer_insecure_skip_verify" field's value of the SystemConfig entity.
// If the SystemConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemConfigMutation) OldMailerInsecureSkipVerify(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMailerInsecureSkipVerify is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMailerInsecureSkipVerify requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMailerInsecureSkipVerify: %w", err)
	}
	return oldValue.MailerInsecureSkipVerify, nil
}

// ResetMailerInsecureSkipVerify resets all changes to the "mailer_insecure_skip_verify" field.
func (m *SystemConfigMutation) ResetMailerInsecureSkipVerify() {
	m.mailer_insecure_skip_verify = nil
}

// SetMailerUseImplicitSslTLS sets the "mailer_use_implicit_ssl_tls" field.
func (m *SystemConfigMutation) SetMailerUseImplicitSslTLS(b bool) {
	m.mailer_use_implicit_ssl_tls = &b
}

// MailerUseImplicitSslTLS returns the value of the "mailer_use_implicit_ssl_tls" field in the mutation.
func (m *SystemConfigMutation) MailerUseImplicitSslTLS() (r bool, exists bool) {
	v := m.mailer_use_implicit_ssl_tls
	if v == nil {
		return
	}
	return *v, true
}

// OldMailerUseImplicitSslTLS returns the old "mailer_use_implicit_ssl_tls" field's value of the SystemConfig entity.
// If the SystemConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemConfigMutation) OldMailerUseImplicitSslTLS(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMailerUseImplicitSslTLS is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMailerUseImplicitSslTLS requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMailerUseImplicitSslTLS: %w", err)
	}
	return oldValue.MailerUseImplicitSslTLS, nil
}

// ResetMailerUseImplicitSslTLS resets all changes to the "mailer_use_implicit_ssl_tls" field.
func (m *SystemConfigMutation) ResetMailerUseImplicitSslTLS() {
	m.mailer_use_implicit_ssl_tls = nil
}

// SetOcrTikaURL sets the "ocr_tika_url" field.
func (m *SystemConfigMutation) SetOcrTikaURL(s string) {
	m.ocr_tika_url = &s
}

// OcrTikaURL returns the value of the "ocr_tika_url" field in the mutation.
func (m *SystemConfigMutation) OcrTikaURL() (r string, exists bool) {
	v := m.ocr_tika_url
	if v == nil {
		return
	}
	return *v, true
}

// OldOcrTikaURL returns the old "ocr_tika_url" field's value of the SystemConfig entity.
// If the SystemConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemConfigMutation) OldOcrTikaURL(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOcrTikaURL is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOcrTikaURL requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOcrTikaURL: %w", err)
	}
	return oldValue.OcrTikaURL, nil
}

// ResetOcrTikaURL resets all changes to the "ocr_tika_url" field.
func (m *SystemConfigMutation) ResetOcrTikaURL() {
	m.ocr_tika_url = nil
}

// SetOcrMaxFileSizeMib sets the "ocr_max_file_size_mib" field.
func (m *SystemConfigMutation) SetOcrMaxFileSizeMib(i int64) {
	m.ocr_max_file_size_mib = &i
	m.addocr_max_file_size_mib = nil
}

// OcrMaxFileSizeMib returns the value of the "ocr_max_file_size_mib" field in the mutation.
func (m *SystemConfigMutation) OcrMaxFileSizeMib() (r int64, exists bool) {
	v := m.ocr_max_file_size_mib
	if v == nil {
		return
	}
	return *v, true
}

// OldOcrMaxFileSizeMib returns the old "ocr_max_file_size_mib" field's value of the SystemConfig entity.
// If the SystemConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemConfigMutation) OldOcrMaxFileSizeMib(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOcrMaxFileSizeMib is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOcrMaxFileSizeMib requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOcrMaxFileSizeMib: %w", err)
	}
	return oldValue.OcrMaxFileSizeMib, nil
}

// AddOcrMaxFileSizeMib adds i to the "ocr_max_file_size_mib" field.
func (m *SystemConfigMutation) AddOcrMaxFileSizeMib(i int64) {
	if m.addocr_max_file_size_mib != nil {
		*m.addocr_max_file_size_mib += i
	} else {
		m.addocr_max_file_size_mib = &i
	}
}

// AddedOcrMaxFileSizeMib returns the value that was added to the "ocr_max_file_size_mib" field in this mutation.
func (m *SystemConfigMutation) AddedOcrMaxFileSizeMib() (r int64, exists bool) {
	v := m.addocr_max_file_size_mib
	if v == nil {
		return
	}
	return *v, true
}

// ResetOcrMaxFileSizeMib resets all changes to the "ocr_max_file_size_mib" field.
func (m *SystemConfigMutation) ResetOcrMaxFileSizeMib() {
	m.ocr_max_file_size_mib = nil
	m.addocr_max_file_size_mib = nil
}

// SetInitializedAt sets the "initialized_at" field.
func (m *SystemConfigMutation) SetInitializedAt(t time.Time) {
	m.initialized_at = &t
}

// InitializedAt returns the value of the "initialized_at" field in the mutation.
func (m *SystemConfigMutation) InitializedAt() (r time.Time, exists bool) {
	v := m.initialized_at
	if v == nil {
		return
	}
	return *v, true
}

// OldInitializedAt returns the old "initialized_at" field's value of the SystemConfig entity.
// If the SystemConfig object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SystemConfigMutation) OldInitializedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInitializedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInitializedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInitializedAt: %w", err)
	}
	return oldValue.InitializedAt, nil
}

// ClearInitializedAt clears the value of the "initialized_at" field.
func (m *SystemConfigMutation) ClearInitializedAt() {
	m.initialized_at = nil
	m.clearedFields[systemconfig.FieldInitializedAt] = struct{}{}
}

// InitializedAtCleared returns if the "initialized_at" field was cleared in this mutation.
func (m *SystemConfigMutation) InitializedAtCleared() bool {
	_, ok := m.clearedFields[systemconfig.FieldInitializedAt]
	return ok
}

// ResetInitializedAt resets all changes to the "initialized_at" field.
func (m *SystemConfigMutation) ResetInitializedAt() {
	m.initialized_at = nil
	delete(m.clearedFields, systemconfig.FieldInitializedAt)
}

// SetCreatorID sets the "creator" edge to the Account entity by id.
func (m *SystemConfigMutation) SetCreatorID(id int64) {
	m.creator = &id
}

// ClearCreator clears the "creator" edge to the Account entity.
func (m *SystemConfigMutation) ClearCreator() {
	m.clearedcreator = true
	m.clearedFields[systemconfig.FieldCreatedBy] = struct{}{}
}

// CreatorCleared reports if the "creator" edge to the Account entity was cleared.
func (m *SystemConfigMutation) CreatorCleared() bool {
	return m.CreatedByCleared() || m.clearedcreator
}

// CreatorID returns the "creator" edge ID in the mutation.
func (m *SystemConfigMutation) CreatorID() (id int64, exists bool) {
	if m.creator != nil {
		return *m.creator, true
	}
	return
}

// CreatorIDs returns the "creator" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreatorID instead. It exists only for internal usage by the builders.
func (m *SystemConfigMutation) CreatorIDs() (ids []int64) {
	if id := m.creator; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreator resets all changes to the "creator" edge.
func (m *SystemConfigMutation) ResetCreator() {
	m.creator = nil
	m.clearedcreator = false
}

// SetUpdaterID sets the "updater" edge to the Account entity by id.
func (m *SystemConfigMutation) SetUpdaterID(id int64) {
	m.updater = &id
}

// ClearUpdater clears the "updater" edge to the Account entity.
func (m *SystemConfigMutation) ClearUpdater() {
	m.clearedupdater = true
	m.clearedFields[systemconfig.FieldUpdatedBy] = struct{}{}
}

// UpdaterCleared reports if the "updater" edge to the Account entity was cleared.
func (m *SystemConfigMutation) UpdaterCleared() bool {
	return m.UpdatedByCleared() || m.clearedupdater
}

// UpdaterID returns the "updater" edge ID in the mutation.
func (m *SystemConfigMutation) UpdaterID() (id int64, exists bool) {
	if m.updater != nil {
		return *m.updater, true
	}
	return
}

// UpdaterIDs returns the "updater" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UpdaterID instead. It exists only for internal usage by the builders.
func (m *SystemConfigMutation) UpdaterIDs() (ids []int64) {
	if id := m.updater; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUpdater resets all changes to the "updater" edge.
func (m *SystemConfigMutation) ResetUpdater() {
	m.updater = nil
	m.clearedupdater = false
}

// Where appends a list predicates to the SystemConfigMutation builder.
func (m *SystemConfigMutation) Where(ps ...predicate.SystemConfig) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SystemConfigMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SystemConfigMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SystemConfig, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SystemConfigMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SystemConfigMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SystemConfig).
func (m *SystemConfigMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SystemConfigMutation) Fields() []string {
	fields := make([]string, 0, 26)
	if m.created_at != nil {
		fields = append(fields, systemconfig.FieldCreatedAt)
	}
	if m.creator != nil {
		fields = append(fields, systemconfig.FieldCreatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, systemconfig.FieldUpdatedAt)
	}
	if m.updater != nil {
		fields = append(fields, systemconfig.FieldUpdatedBy)
	}
	if m.x25519_identity != nil {
		fields = append(fields, systemconfig.FieldX25519Identity)
	}
	if m.is_identity_encrypted_with_passphrase != nil {
		fields = append(fields, systemconfig.FieldIsIdentityEncryptedWithPassphrase)
	}
	if m.s3_endpoint != nil {
		fields = append(fields, systemconfig.FieldS3Endpoint)
	}
	if m.s3_access_key_id != nil {
		fields = append(fields, systemconfig.FieldS3AccessKeyID)
	}
	if m.s3_secret_access_key != nil {
		fields = append(fields, systemconfig.FieldS3SecretAccessKey)
	}
	if m.s3_bucket_name != nil {
		fields = append(fields, systemconfig.FieldS3BucketName)
	}
	if m.s3_use_ssl != nil {
		fields = append(fields, systemconfig.FieldS3UseSsl)
	}
	if m.tls_enable_autocert != nil {
		fields = append(fields, systemconfig.FieldTLSEnableAutocert)
	}
	if m.tls_cert_filepath != nil {
		fields = append(fields, systemconfig.FieldTLSCertFilepath)
	}
	if m.tls_private_key_filepath != nil {
		fields = append(fields, systemconfig.FieldTLSPrivateKeyFilepath)
	}
	if m.tls_autocert_email != nil {
		fields = append(fields, systemconfig.FieldTLSAutocertEmail)
	}
	if m.tls_autocert_hosts != nil {
		fields = append(fields, systemconfig.FieldTLSAutocertHosts)
	}
	if m.mailer_host != nil {
		fields = append(fields, systemconfig.FieldMailerHost)
	}
	if m.mailer_port != nil {
		fields = append(fields, systemconfig.FieldMailerPort)
	}
	if m.mailer_username != nil {
		fields = append(fields, systemconfig.FieldMailerUsername)
	}
	if m.mailer_password != nil {
		fields = append(fields, systemconfig.FieldMailerPassword)
	}
	if m.mailer_from != nil {
		fields = append(fields, systemconfig.FieldMailerFrom)
	}
	if m.mailer_insecure_skip_verify != nil {
		fields = append(fields, systemconfig.FieldMailerInsecureSkipVerify)
	}
	if m.mailer_use_implicit_ssl_tls != nil {
		fields = append(fields, systemconfig.FieldMailerUseImplicitSslTLS)
	}
	if m.ocr_tika_url != nil {
		fields = append(fields, systemconfig.FieldOcrTikaURL)
	}
	if m.ocr_max_file_size_mib != nil {
		fields = append(fields, systemconfig.FieldOcrMaxFileSizeMib)
	}
	if m.initialized_at != nil {
		fields = append(fields, systemconfig.FieldInitializedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SystemConfigMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case systemconfig.FieldCreatedAt:
		return m.CreatedAt()
	case systemconfig.FieldCreatedBy:
		return m.CreatedBy()
	case systemconfig.FieldUpdatedAt:
		return m.UpdatedAt()
	case systemconfig.FieldUpdatedBy:
		return m.UpdatedBy()
	case systemconfig.FieldX25519Identity:
		return m.X25519Identity()
	case systemconfig.FieldIsIdentityEncryptedWithPassphrase:
		return m.IsIdentityEncryptedWithPassphrase()
	case systemconfig.FieldS3Endpoint:
		return m.S3Endpoint()
	case systemconfig.FieldS3AccessKeyID:
		return m.S3AccessKeyID()
	case systemconfig.FieldS3SecretAccessKey:
		return m.S3SecretAccessKey()
	case systemconfig.FieldS3BucketName:
		return m.S3BucketName()
	case systemconfig.FieldS3UseSsl:
		return m.S3UseSsl()
	case systemconfig.FieldTLSEnableAutocert:
		return m.TLSEnableAutocert()
	case systemconfig.FieldTLSCertFilepath:
		return m.TLSCertFilepath()
	case systemconfig.FieldTLSPrivateKeyFilepath:
		return m.TLSPrivateKeyFilepath()
	case systemconfig.FieldTLSAutocertEmail:
		return m.TLSAutocertEmail()
	case systemconfig.FieldTLSAutocertHosts:
		return m.TLSAutocertHosts()
	case systemconfig.FieldMailerHost:
		return m.MailerHost()
	case systemconfig.FieldMailerPort:
		return m.MailerPort()
	case systemconfig.FieldMailerUsername:
		return m.MailerUsername()
	case systemconfig.FieldMailerPassword:
		return m.MailerPassword()
	case systemconfig.FieldMailerFrom:
		return m.MailerFrom()
	case systemconfig.FieldMailerInsecureSkipVerify:
		return m.MailerInsecureSkipVerify()
	case systemconfig.FieldMailerUseImplicitSslTLS:
		return m.MailerUseImplicitSslTLS()
	case systemconfig.FieldOcrTikaURL:
		return m.OcrTikaURL()
	case systemconfig.FieldOcrMaxFileSizeMib:
		return m.OcrMaxFileSizeMib()
	case systemconfig.FieldInitializedAt:
		return m.InitializedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SystemConfigMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case systemconfig.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case systemconfig.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case systemconfig.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case systemconfig.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case systemconfig.FieldX25519Identity:
		return m.OldX25519Identity(ctx)
	case systemconfig.FieldIsIdentityEncryptedWithPassphrase:
		return m.OldIsIdentityEncryptedWithPassphrase(ctx)
	case systemconfig.FieldS3Endpoint:
		return m.OldS3Endpoint(ctx)
	case systemconfig.FieldS3AccessKeyID:
		return m.OldS3AccessKeyID(ctx)
	case systemconfig.FieldS3SecretAccessKey:
		return m.OldS3SecretAccessKey(ctx)
	case systemconfig.FieldS3BucketName:
		return m.OldS3BucketName(ctx)
	case systemconfig.FieldS3UseSsl:
		return m.OldS3UseSsl(ctx)
	case systemconfig.FieldTLSEnableAutocert:
		return m.OldTLSEnableAutocert(ctx)
	case systemconfig.FieldTLSCertFilepath:
		return m.OldTLSCertFilepath(ctx)
	case systemconfig.FieldTLSPrivateKeyFilepath:
		return m.OldTLSPrivateKeyFilepath(ctx)
	case systemconfig.FieldTLSAutocertEmail:
		return m.OldTLSAutocertEmail(ctx)
	case systemconfig.FieldTLSAutocertHosts:
		return m.OldTLSAutocertHosts(ctx)
	case systemconfig.FieldMailerHost:
		return m.OldMailerHost(ctx)
	case systemconfig.FieldMailerPort:
		return m.OldMailerPort(ctx)
	case systemconfig.FieldMailerUsername:
		return m.OldMailerUsername(ctx)
	case systemconfig.FieldMailerPassword:
		return m.OldMailerPassword(ctx)
	case systemconfig.FieldMailerFrom:
		return m.OldMailerFrom(ctx)
	case systemconfig.FieldMailerInsecureSkipVerify:
		return m.OldMailerInsecureSkipVerify(ctx)
	case systemconfig.FieldMailerUseImplicitSslTLS:
		return m.OldMailerUseImplicitSslTLS(ctx)
	case systemconfig.FieldOcrTikaURL:
		return m.OldOcrTikaURL(ctx)
	case systemconfig.FieldOcrMaxFileSizeMib:
		return m.OldOcrMaxFileSizeMib(ctx)
	case systemconfig.FieldInitializedAt:
		return m.OldInitializedAt(ctx)
	}
	return nil, fmt.Errorf("unknown SystemConfig field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SystemConfigMutation) SetField(name string, value ent.Value) error {
	switch name {
	case systemconfig.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case systemconfig.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case systemconfig.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case systemconfig.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case systemconfig.FieldX25519Identity:
		v, ok := value.([]byte)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetX25519Identity(v)
		return nil
	case systemconfig.FieldIsIdentityEncryptedWithPassphrase:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsIdentityEncryptedWithPassphrase(v)
		return nil
	case systemconfig.FieldS3Endpoint:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetS3Endpoint(v)
		return nil
	case systemconfig.FieldS3AccessKeyID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetS3AccessKeyID(v)
		return nil
	case systemconfig.FieldS3SecretAccessKey:
		v, ok := value.(entx.EncryptedString)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetS3SecretAccessKey(v)
		return nil
	case systemconfig.FieldS3BucketName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetS3BucketName(v)
		return nil
	case systemconfig.FieldS3UseSsl:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetS3UseSsl(v)
		return nil
	case systemconfig.FieldTLSEnableAutocert:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTLSEnableAutocert(v)
		return nil
	case systemconfig.FieldTLSCertFilepath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTLSCertFilepath(v)
		return nil
	case systemconfig.FieldTLSPrivateKeyFilepath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTLSPrivateKeyFilepath(v)
		return nil
	case systemconfig.FieldTLSAutocertEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTLSAutocertEmail(v)
		return nil
	case systemconfig.FieldTLSAutocertHosts:
		v, ok := value.([]string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTLSAutocertHosts(v)
		return nil
	case systemconfig.FieldMailerHost:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMailerHost(v)
		return nil
	case systemconfig.FieldMailerPort:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMailerPort(v)
		return nil
	case systemconfig.FieldMailerUsername:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMailerUsername(v)
		return nil
	case systemconfig.FieldMailerPassword:
		v, ok := value.(entx.EncryptedString)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMailerPassword(v)
		return nil
	case systemconfig.FieldMailerFrom:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMailerFrom(v)
		return nil
	case systemconfig.FieldMailerInsecureSkipVerify:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMailerInsecureSkipVerify(v)
		return nil
	case systemconfig.FieldMailerUseImplicitSslTLS:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMailerUseImplicitSslTLS(v)
		return nil
	case systemconfig.FieldOcrTikaURL:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOcrTikaURL(v)
		return nil
	case systemconfig.FieldOcrMaxFileSizeMib:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOcrMaxFileSizeMib(v)
		return nil
	case systemconfig.FieldInitializedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInitializedAt(v)
		return nil
	}
	return fmt.Errorf("unknown SystemConfig field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SystemConfigMutation) AddedFields() []string {
	var fields []string
	if m.addmailer_port != nil {
		fields = append(fields, systemconfig.FieldMailerPort)
	}
	if m.addocr_max_file_size_mib != nil {
		fields = append(fields, systemconfig.FieldOcrMaxFileSizeMib)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SystemConfigMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case systemconfig.FieldMailerPort:
		return m.AddedMailerPort()
	case systemconfig.FieldOcrMaxFileSizeMib:
		return m.AddedOcrMaxFileSizeMib()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SystemConfigMutation) AddField(name string, value ent.Value) error {
	switch name {
	case systemconfig.FieldMailerPort:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddMailerPort(v)
		return nil
	case systemconfig.FieldOcrMaxFileSizeMib:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOcrMaxFileSizeMib(v)
		return nil
	}
	return fmt.Errorf("unknown SystemConfig numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SystemConfigMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(systemconfig.FieldCreatedBy) {
		fields = append(fields, systemconfig.FieldCreatedBy)
	}
	if m.FieldCleared(systemconfig.FieldUpdatedBy) {
		fields = append(fields, systemconfig.FieldUpdatedBy)
	}
	if m.FieldCleared(systemconfig.FieldMailerPassword) {
		fields = append(fields, systemconfig.FieldMailerPassword)
	}
	if m.FieldCleared(systemconfig.FieldInitializedAt) {
		fields = append(fields, systemconfig.FieldInitializedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SystemConfigMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SystemConfigMutation) ClearField(name string) error {
	switch name {
	case systemconfig.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case systemconfig.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case systemconfig.FieldMailerPassword:
		m.ClearMailerPassword()
		return nil
	case systemconfig.FieldInitializedAt:
		m.ClearInitializedAt()
		return nil
	}
	return fmt.Errorf("unknown SystemConfig nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SystemConfigMutation) ResetField(name string) error {
	switch name {
	case systemconfig.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case systemconfig.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case systemconfig.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case systemconfig.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case systemconfig.FieldX25519Identity:
		m.ResetX25519Identity()
		return nil
	case systemconfig.FieldIsIdentityEncryptedWithPassphrase:
		m.ResetIsIdentityEncryptedWithPassphrase()
		return nil
	case systemconfig.FieldS3Endpoint:
		m.ResetS3Endpoint()
		return nil
	case systemconfig.FieldS3AccessKeyID:
		m.ResetS3AccessKeyID()
		return nil
	case systemconfig.FieldS3SecretAccessKey:
		m.ResetS3SecretAccessKey()
		return nil
	case systemconfig.FieldS3BucketName:
		m.ResetS3BucketName()
		return nil
	case systemconfig.FieldS3UseSsl:
		m.ResetS3UseSsl()
		return nil
	case systemconfig.FieldTLSEnableAutocert:
		m.ResetTLSEnableAutocert()
		return nil
	case systemconfig.FieldTLSCertFilepath:
		m.ResetTLSCertFilepath()
		return nil
	case systemconfig.FieldTLSPrivateKeyFilepath:
		m.ResetTLSPrivateKeyFilepath()
		return nil
	case systemconfig.FieldTLSAutocertEmail:
		m.ResetTLSAutocertEmail()
		return nil
	case systemconfig.FieldTLSAutocertHosts:
		m.ResetTLSAutocertHosts()
		return nil
	case systemconfig.FieldMailerHost:
		m.ResetMailerHost()
		return nil
	case systemconfig.FieldMailerPort:
		m.ResetMailerPort()
		return nil
	case systemconfig.FieldMailerUsername:
		m.ResetMailerUsername()
		return nil
	case systemconfig.FieldMailerPassword:
		m.ResetMailerPassword()
		return nil
	case systemconfig.FieldMailerFrom:
		m.ResetMailerFrom()
		return nil
	case systemconfig.FieldMailerInsecureSkipVerify:
		m.ResetMailerInsecureSkipVerify()
		return nil
	case systemconfig.FieldMailerUseImplicitSslTLS:
		m.ResetMailerUseImplicitSslTLS()
		return nil
	case systemconfig.FieldOcrTikaURL:
		m.ResetOcrTikaURL()
		return nil
	case systemconfig.FieldOcrMaxFileSizeMib:
		m.ResetOcrMaxFileSizeMib()
		return nil
	case systemconfig.FieldInitializedAt:
		m.ResetInitializedAt()
		return nil
	}
	return fmt.Errorf("unknown SystemConfig field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SystemConfigMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.creator != nil {
		edges = append(edges, systemconfig.EdgeCreator)
	}
	if m.updater != nil {
		edges = append(edges, systemconfig.EdgeUpdater)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SystemConfigMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case systemconfig.EdgeCreator:
		if id := m.creator; id != nil {
			return []ent.Value{*id}
		}
	case systemconfig.EdgeUpdater:
		if id := m.updater; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SystemConfigMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SystemConfigMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SystemConfigMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedcreator {
		edges = append(edges, systemconfig.EdgeCreator)
	}
	if m.clearedupdater {
		edges = append(edges, systemconfig.EdgeUpdater)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SystemConfigMutation) EdgeCleared(name string) bool {
	switch name {
	case systemconfig.EdgeCreator:
		return m.clearedcreator
	case systemconfig.EdgeUpdater:
		return m.clearedupdater
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SystemConfigMutation) ClearEdge(name string) error {
	switch name {
	case systemconfig.EdgeCreator:
		m.ClearCreator()
		return nil
	case systemconfig.EdgeUpdater:
		m.ClearUpdater()
		return nil
	}
	return fmt.Errorf("unknown SystemConfig unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SystemConfigMutation) ResetEdge(name string) error {
	switch name {
	case systemconfig.EdgeCreator:
		m.ResetCreator()
		return nil
	case systemconfig.EdgeUpdater:
		m.ResetUpdater()
		return nil
	}
	return fmt.Errorf("unknown SystemConfig edge %s", name)
}

// TemporaryFileMutation represents an operation that mutates the TemporaryFile nodes in the graph.
type TemporaryFileMutation struct {
	config
	op                          Op
	typ                         string
	id                          *int64
	public_id                   *entx.CIText
	created_at                  *time.Time
	updated_at                  *time.Time
	deleted_at                  *time.Time
	upload_started_at           *time.Time
	upload_failed_at            *time.Time
	upload_succeeded_at         *time.Time
	filename                    *string
	size                        *int64
	addsize                     *int64
	size_in_storage             *int64
	addsize_in_storage          *int64
	sha256                      *string
	mime_type                   *string
	storage_type                *storagetype.StorageType
	bucket_name                 *string
	storage_path                *string
	storage_filename            *string
	upload_token                *string
	converted_to_stored_file_at *time.Time
	expires_at                  *time.Time
	clearedFields               map[string]struct{}
	creator                     *int64
	clearedcreator              bool
	updater                     *int64
	clearedupdater              bool
	deleter                     *int64
	cleareddeleter              bool
	owner                       *int64
	clearedowner                bool
	done                        bool
	oldValue                    func(context.Context) (*TemporaryFile, error)
	predicates                  []predicate.TemporaryFile
}

var _ ent.Mutation = (*TemporaryFileMutation)(nil)

// temporaryfileOption allows management of the mutation configuration using functional options.
type temporaryfileOption func(*TemporaryFileMutation)

// newTemporaryFileMutation creates new mutation for the TemporaryFile entity.
func newTemporaryFileMutation(c config, op Op, opts ...temporaryfileOption) *TemporaryFileMutation {
	m := &TemporaryFileMutation{
		config:        c,
		op:            op,
		typ:           TypeTemporaryFile,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTemporaryFileID sets the ID field of the mutation.
func withTemporaryFileID(id int64) temporaryfileOption {
	return func(m *TemporaryFileMutation) {
		var (
			err   error
			once  sync.Once
			value *TemporaryFile
		)
		m.oldValue = func(ctx context.Context) (*TemporaryFile, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TemporaryFile.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTemporaryFile sets the old TemporaryFile of the mutation.
func withTemporaryFile(node *TemporaryFile) temporaryfileOption {
	return func(m *TemporaryFileMutation) {
		m.oldValue = func(context.Context) (*TemporaryFile, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TemporaryFileMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TemporaryFileMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("entmain: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of TemporaryFile entities.
func (m *TemporaryFileMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TemporaryFileMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TemporaryFileMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TemporaryFile.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetPublicID sets the "public_id" field.
func (m *TemporaryFileMutation) SetPublicID(et entx.CIText) {
	m.public_id = &et
}

// PublicID returns the value of the "public_id" field in the mutation.
func (m *TemporaryFileMutation) PublicID() (r entx.CIText, exists bool) {
	v := m.public_id
	if v == nil {
		return
	}
	return *v, true
}

// OldPublicID returns the old "public_id" field's value of the TemporaryFile entity.
// If the TemporaryFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemporaryFileMutation) OldPublicID(ctx context.Context) (v entx.CIText, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPublicID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPublicID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPublicID: %w", err)
	}
	return oldValue.PublicID, nil
}

// ResetPublicID resets all changes to the "public_id" field.
func (m *TemporaryFileMutation) ResetPublicID() {
	m.public_id = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *TemporaryFileMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TemporaryFileMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the TemporaryFile entity.
// If the TemporaryFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemporaryFileMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TemporaryFileMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *TemporaryFileMutation) SetCreatedBy(i int64) {
	m.creator = &i
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *TemporaryFileMutation) CreatedBy() (r int64, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the TemporaryFile entity.
// If the TemporaryFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemporaryFileMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *TemporaryFileMutation) ClearCreatedBy() {
	m.creator = nil
	m.clearedFields[temporaryfile.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *TemporaryFileMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[temporaryfile.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *TemporaryFileMutation) ResetCreatedBy() {
	m.creator = nil
	delete(m.clearedFields, temporaryfile.FieldCreatedBy)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TemporaryFileMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TemporaryFileMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the TemporaryFile entity.
// If the TemporaryFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemporaryFileMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TemporaryFileMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *TemporaryFileMutation) SetUpdatedBy(i int64) {
	m.updater = &i
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *TemporaryFileMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updater
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the TemporaryFile entity.
// If the TemporaryFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemporaryFileMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *TemporaryFileMutation) ClearUpdatedBy() {
	m.updater = nil
	m.clearedFields[temporaryfile.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *TemporaryFileMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[temporaryfile.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *TemporaryFileMutation) ResetUpdatedBy() {
	m.updater = nil
	delete(m.clearedFields, temporaryfile.FieldUpdatedBy)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *TemporaryFileMutation) SetDeletedBy(i int64) {
	m.deleter = &i
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *TemporaryFileMutation) DeletedBy() (r int64, exists bool) {
	v := m.deleter
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the TemporaryFile entity.
// If the TemporaryFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemporaryFileMutation) OldDeletedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *TemporaryFileMutation) ClearDeletedBy() {
	m.deleter = nil
	m.clearedFields[temporaryfile.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *TemporaryFileMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[temporaryfile.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *TemporaryFileMutation) ResetDeletedBy() {
	m.deleter = nil
	delete(m.clearedFields, temporaryfile.FieldDeletedBy)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *TemporaryFileMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *TemporaryFileMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the TemporaryFile entity.
// If the TemporaryFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemporaryFileMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *TemporaryFileMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[temporaryfile.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *TemporaryFileMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[temporaryfile.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *TemporaryFileMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, temporaryfile.FieldDeletedAt)
}

// SetUploadStartedAt sets the "upload_started_at" field.
func (m *TemporaryFileMutation) SetUploadStartedAt(t time.Time) {
	m.upload_started_at = &t
}

// UploadStartedAt returns the value of the "upload_started_at" field in the mutation.
func (m *TemporaryFileMutation) UploadStartedAt() (r time.Time, exists bool) {
	v := m.upload_started_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUploadStartedAt returns the old "upload_started_at" field's value of the TemporaryFile entity.
// If the TemporaryFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemporaryFileMutation) OldUploadStartedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUploadStartedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUploadStartedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUploadStartedAt: %w", err)
	}
	return oldValue.UploadStartedAt, nil
}

// ClearUploadStartedAt clears the value of the "upload_started_at" field.
func (m *TemporaryFileMutation) ClearUploadStartedAt() {
	m.upload_started_at = nil
	m.clearedFields[temporaryfile.FieldUploadStartedAt] = struct{}{}
}

// UploadStartedAtCleared returns if the "upload_started_at" field was cleared in this mutation.
func (m *TemporaryFileMutation) UploadStartedAtCleared() bool {
	_, ok := m.clearedFields[temporaryfile.FieldUploadStartedAt]
	return ok
}

// ResetUploadStartedAt resets all changes to the "upload_started_at" field.
func (m *TemporaryFileMutation) ResetUploadStartedAt() {
	m.upload_started_at = nil
	delete(m.clearedFields, temporaryfile.FieldUploadStartedAt)
}

// SetUploadFailedAt sets the "upload_failed_at" field.
func (m *TemporaryFileMutation) SetUploadFailedAt(t time.Time) {
	m.upload_failed_at = &t
}

// UploadFailedAt returns the value of the "upload_failed_at" field in the mutation.
func (m *TemporaryFileMutation) UploadFailedAt() (r time.Time, exists bool) {
	v := m.upload_failed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUploadFailedAt returns the old "upload_failed_at" field's value of the TemporaryFile entity.
// If the TemporaryFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemporaryFileMutation) OldUploadFailedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUploadFailedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUploadFailedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUploadFailedAt: %w", err)
	}
	return oldValue.UploadFailedAt, nil
}

// ClearUploadFailedAt clears the value of the "upload_failed_at" field.
func (m *TemporaryFileMutation) ClearUploadFailedAt() {
	m.upload_failed_at = nil
	m.clearedFields[temporaryfile.FieldUploadFailedAt] = struct{}{}
}

// UploadFailedAtCleared returns if the "upload_failed_at" field was cleared in this mutation.
func (m *TemporaryFileMutation) UploadFailedAtCleared() bool {
	_, ok := m.clearedFields[temporaryfile.FieldUploadFailedAt]
	return ok
}

// ResetUploadFailedAt resets all changes to the "upload_failed_at" field.
func (m *TemporaryFileMutation) ResetUploadFailedAt() {
	m.upload_failed_at = nil
	delete(m.clearedFields, temporaryfile.FieldUploadFailedAt)
}

// SetUploadSucceededAt sets the "upload_succeeded_at" field.
func (m *TemporaryFileMutation) SetUploadSucceededAt(t time.Time) {
	m.upload_succeeded_at = &t
}

// UploadSucceededAt returns the value of the "upload_succeeded_at" field in the mutation.
func (m *TemporaryFileMutation) UploadSucceededAt() (r time.Time, exists bool) {
	v := m.upload_succeeded_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUploadSucceededAt returns the old "upload_succeeded_at" field's value of the TemporaryFile entity.
// If the TemporaryFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemporaryFileMutation) OldUploadSucceededAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUploadSucceededAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUploadSucceededAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUploadSucceededAt: %w", err)
	}
	return oldValue.UploadSucceededAt, nil
}

// ClearUploadSucceededAt clears the value of the "upload_succeeded_at" field.
func (m *TemporaryFileMutation) ClearUploadSucceededAt() {
	m.upload_succeeded_at = nil
	m.clearedFields[temporaryfile.FieldUploadSucceededAt] = struct{}{}
}

// UploadSucceededAtCleared returns if the "upload_succeeded_at" field was cleared in this mutation.
func (m *TemporaryFileMutation) UploadSucceededAtCleared() bool {
	_, ok := m.clearedFields[temporaryfile.FieldUploadSucceededAt]
	return ok
}

// ResetUploadSucceededAt resets all changes to the "upload_succeeded_at" field.
func (m *TemporaryFileMutation) ResetUploadSucceededAt() {
	m.upload_succeeded_at = nil
	delete(m.clearedFields, temporaryfile.FieldUploadSucceededAt)
}

// SetOwnerID sets the "owner_id" field.
func (m *TemporaryFileMutation) SetOwnerID(i int64) {
	m.owner = &i
}

// OwnerID returns the value of the "owner_id" field in the mutation.
func (m *TemporaryFileMutation) OwnerID() (r int64, exists bool) {
	v := m.owner
	if v == nil {
		return
	}
	return *v, true
}

// OldOwnerID returns the old "owner_id" field's value of the TemporaryFile entity.
// If the TemporaryFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemporaryFileMutation) OldOwnerID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOwnerID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOwnerID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOwnerID: %w", err)
	}
	return oldValue.OwnerID, nil
}

// ResetOwnerID resets all changes to the "owner_id" field.
func (m *TemporaryFileMutation) ResetOwnerID() {
	m.owner = nil
}

// SetFilename sets the "filename" field.
func (m *TemporaryFileMutation) SetFilename(s string) {
	m.filename = &s
}

// Filename returns the value of the "filename" field in the mutation.
func (m *TemporaryFileMutation) Filename() (r string, exists bool) {
	v := m.filename
	if v == nil {
		return
	}
	return *v, true
}

// OldFilename returns the old "filename" field's value of the TemporaryFile entity.
// If the TemporaryFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemporaryFileMutation) OldFilename(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFilename is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFilename requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFilename: %w", err)
	}
	return oldValue.Filename, nil
}

// ResetFilename resets all changes to the "filename" field.
func (m *TemporaryFileMutation) ResetFilename() {
	m.filename = nil
}

// SetSize sets the "size" field.
func (m *TemporaryFileMutation) SetSize(i int64) {
	m.size = &i
	m.addsize = nil
}

// Size returns the value of the "size" field in the mutation.
func (m *TemporaryFileMutation) Size() (r int64, exists bool) {
	v := m.size
	if v == nil {
		return
	}
	return *v, true
}

// OldSize returns the old "size" field's value of the TemporaryFile entity.
// If the TemporaryFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemporaryFileMutation) OldSize(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSize: %w", err)
	}
	return oldValue.Size, nil
}

// AddSize adds i to the "size" field.
func (m *TemporaryFileMutation) AddSize(i int64) {
	if m.addsize != nil {
		*m.addsize += i
	} else {
		m.addsize = &i
	}
}

// AddedSize returns the value that was added to the "size" field in this mutation.
func (m *TemporaryFileMutation) AddedSize() (r int64, exists bool) {
	v := m.addsize
	if v == nil {
		return
	}
	return *v, true
}

// ClearSize clears the value of the "size" field.
func (m *TemporaryFileMutation) ClearSize() {
	m.size = nil
	m.addsize = nil
	m.clearedFields[temporaryfile.FieldSize] = struct{}{}
}

// SizeCleared returns if the "size" field was cleared in this mutation.
func (m *TemporaryFileMutation) SizeCleared() bool {
	_, ok := m.clearedFields[temporaryfile.FieldSize]
	return ok
}

// ResetSize resets all changes to the "size" field.
func (m *TemporaryFileMutation) ResetSize() {
	m.size = nil
	m.addsize = nil
	delete(m.clearedFields, temporaryfile.FieldSize)
}

// SetSizeInStorage sets the "size_in_storage" field.
func (m *TemporaryFileMutation) SetSizeInStorage(i int64) {
	m.size_in_storage = &i
	m.addsize_in_storage = nil
}

// SizeInStorage returns the value of the "size_in_storage" field in the mutation.
func (m *TemporaryFileMutation) SizeInStorage() (r int64, exists bool) {
	v := m.size_in_storage
	if v == nil {
		return
	}
	return *v, true
}

// OldSizeInStorage returns the old "size_in_storage" field's value of the TemporaryFile entity.
// If the TemporaryFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemporaryFileMutation) OldSizeInStorage(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSizeInStorage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSizeInStorage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSizeInStorage: %w", err)
	}
	return oldValue.SizeInStorage, nil
}

// AddSizeInStorage adds i to the "size_in_storage" field.
func (m *TemporaryFileMutation) AddSizeInStorage(i int64) {
	if m.addsize_in_storage != nil {
		*m.addsize_in_storage += i
	} else {
		m.addsize_in_storage = &i
	}
}

// AddedSizeInStorage returns the value that was added to the "size_in_storage" field in this mutation.
func (m *TemporaryFileMutation) AddedSizeInStorage() (r int64, exists bool) {
	v := m.addsize_in_storage
	if v == nil {
		return
	}
	return *v, true
}

// ResetSizeInStorage resets all changes to the "size_in_storage" field.
func (m *TemporaryFileMutation) ResetSizeInStorage() {
	m.size_in_storage = nil
	m.addsize_in_storage = nil
}

// SetSha256 sets the "sha256" field.
func (m *TemporaryFileMutation) SetSha256(s string) {
	m.sha256 = &s
}

// Sha256 returns the value of the "sha256" field in the mutation.
func (m *TemporaryFileMutation) Sha256() (r string, exists bool) {
	v := m.sha256
	if v == nil {
		return
	}
	return *v, true
}

// OldSha256 returns the old "sha256" field's value of the TemporaryFile entity.
// If the TemporaryFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemporaryFileMutation) OldSha256(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSha256 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSha256 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSha256: %w", err)
	}
	return oldValue.Sha256, nil
}

// ClearSha256 clears the value of the "sha256" field.
func (m *TemporaryFileMutation) ClearSha256() {
	m.sha256 = nil
	m.clearedFields[temporaryfile.FieldSha256] = struct{}{}
}

// Sha256Cleared returns if the "sha256" field was cleared in this mutation.
func (m *TemporaryFileMutation) Sha256Cleared() bool {
	_, ok := m.clearedFields[temporaryfile.FieldSha256]
	return ok
}

// ResetSha256 resets all changes to the "sha256" field.
func (m *TemporaryFileMutation) ResetSha256() {
	m.sha256 = nil
	delete(m.clearedFields, temporaryfile.FieldSha256)
}

// SetMimeType sets the "mime_type" field.
func (m *TemporaryFileMutation) SetMimeType(s string) {
	m.mime_type = &s
}

// MimeType returns the value of the "mime_type" field in the mutation.
func (m *TemporaryFileMutation) MimeType() (r string, exists bool) {
	v := m.mime_type
	if v == nil {
		return
	}
	return *v, true
}

// OldMimeType returns the old "mime_type" field's value of the TemporaryFile entity.
// If the TemporaryFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemporaryFileMutation) OldMimeType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMimeType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMimeType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMimeType: %w", err)
	}
	return oldValue.MimeType, nil
}

// ClearMimeType clears the value of the "mime_type" field.
func (m *TemporaryFileMutation) ClearMimeType() {
	m.mime_type = nil
	m.clearedFields[temporaryfile.FieldMimeType] = struct{}{}
}

// MimeTypeCleared returns if the "mime_type" field was cleared in this mutation.
func (m *TemporaryFileMutation) MimeTypeCleared() bool {
	_, ok := m.clearedFields[temporaryfile.FieldMimeType]
	return ok
}

// ResetMimeType resets all changes to the "mime_type" field.
func (m *TemporaryFileMutation) ResetMimeType() {
	m.mime_type = nil
	delete(m.clearedFields, temporaryfile.FieldMimeType)
}

// SetStorageType sets the "storage_type" field.
func (m *TemporaryFileMutation) SetStorageType(st storagetype.StorageType) {
	m.storage_type = &st
}

// StorageType returns the value of the "storage_type" field in the mutation.
func (m *TemporaryFileMutation) StorageType() (r storagetype.StorageType, exists bool) {
	v := m.storage_type
	if v == nil {
		return
	}
	return *v, true
}

// OldStorageType returns the old "storage_type" field's value of the TemporaryFile entity.
// If the TemporaryFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemporaryFileMutation) OldStorageType(ctx context.Context) (v storagetype.StorageType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStorageType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStorageType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStorageType: %w", err)
	}
	return oldValue.StorageType, nil
}

// ResetStorageType resets all changes to the "storage_type" field.
func (m *TemporaryFileMutation) ResetStorageType() {
	m.storage_type = nil
}

// SetBucketName sets the "bucket_name" field.
func (m *TemporaryFileMutation) SetBucketName(s string) {
	m.bucket_name = &s
}

// BucketName returns the value of the "bucket_name" field in the mutation.
func (m *TemporaryFileMutation) BucketName() (r string, exists bool) {
	v := m.bucket_name
	if v == nil {
		return
	}
	return *v, true
}

// OldBucketName returns the old "bucket_name" field's value of the TemporaryFile entity.
// If the TemporaryFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemporaryFileMutation) OldBucketName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBucketName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBucketName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBucketName: %w", err)
	}
	return oldValue.BucketName, nil
}

// ClearBucketName clears the value of the "bucket_name" field.
func (m *TemporaryFileMutation) ClearBucketName() {
	m.bucket_name = nil
	m.clearedFields[temporaryfile.FieldBucketName] = struct{}{}
}

// BucketNameCleared returns if the "bucket_name" field was cleared in this mutation.
func (m *TemporaryFileMutation) BucketNameCleared() bool {
	_, ok := m.clearedFields[temporaryfile.FieldBucketName]
	return ok
}

// ResetBucketName resets all changes to the "bucket_name" field.
func (m *TemporaryFileMutation) ResetBucketName() {
	m.bucket_name = nil
	delete(m.clearedFields, temporaryfile.FieldBucketName)
}

// SetStoragePath sets the "storage_path" field.
func (m *TemporaryFileMutation) SetStoragePath(s string) {
	m.storage_path = &s
}

// StoragePath returns the value of the "storage_path" field in the mutation.
func (m *TemporaryFileMutation) StoragePath() (r string, exists bool) {
	v := m.storage_path
	if v == nil {
		return
	}
	return *v, true
}

// OldStoragePath returns the old "storage_path" field's value of the TemporaryFile entity.
// If the TemporaryFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemporaryFileMutation) OldStoragePath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStoragePath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStoragePath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStoragePath: %w", err)
	}
	return oldValue.StoragePath, nil
}

// ResetStoragePath resets all changes to the "storage_path" field.
func (m *TemporaryFileMutation) ResetStoragePath() {
	m.storage_path = nil
}

// SetStorageFilename sets the "storage_filename" field.
func (m *TemporaryFileMutation) SetStorageFilename(s string) {
	m.storage_filename = &s
}

// StorageFilename returns the value of the "storage_filename" field in the mutation.
func (m *TemporaryFileMutation) StorageFilename() (r string, exists bool) {
	v := m.storage_filename
	if v == nil {
		return
	}
	return *v, true
}

// OldStorageFilename returns the old "storage_filename" field's value of the TemporaryFile entity.
// If the TemporaryFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemporaryFileMutation) OldStorageFilename(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStorageFilename is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStorageFilename requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStorageFilename: %w", err)
	}
	return oldValue.StorageFilename, nil
}

// ResetStorageFilename resets all changes to the "storage_filename" field.
func (m *TemporaryFileMutation) ResetStorageFilename() {
	m.storage_filename = nil
}

// SetUploadToken sets the "upload_token" field.
func (m *TemporaryFileMutation) SetUploadToken(s string) {
	m.upload_token = &s
}

// UploadToken returns the value of the "upload_token" field in the mutation.
func (m *TemporaryFileMutation) UploadToken() (r string, exists bool) {
	v := m.upload_token
	if v == nil {
		return
	}
	return *v, true
}

// OldUploadToken returns the old "upload_token" field's value of the TemporaryFile entity.
// If the TemporaryFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemporaryFileMutation) OldUploadToken(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUploadToken is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUploadToken requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUploadToken: %w", err)
	}
	return oldValue.UploadToken, nil
}

// ResetUploadToken resets all changes to the "upload_token" field.
func (m *TemporaryFileMutation) ResetUploadToken() {
	m.upload_token = nil
}

// SetConvertedToStoredFileAt sets the "converted_to_stored_file_at" field.
func (m *TemporaryFileMutation) SetConvertedToStoredFileAt(t time.Time) {
	m.converted_to_stored_file_at = &t
}

// ConvertedToStoredFileAt returns the value of the "converted_to_stored_file_at" field in the mutation.
func (m *TemporaryFileMutation) ConvertedToStoredFileAt() (r time.Time, exists bool) {
	v := m.converted_to_stored_file_at
	if v == nil {
		return
	}
	return *v, true
}

// OldConvertedToStoredFileAt returns the old "converted_to_stored_file_at" field's value of the TemporaryFile entity.
// If the TemporaryFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemporaryFileMutation) OldConvertedToStoredFileAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldConvertedToStoredFileAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldConvertedToStoredFileAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldConvertedToStoredFileAt: %w", err)
	}
	return oldValue.ConvertedToStoredFileAt, nil
}

// ClearConvertedToStoredFileAt clears the value of the "converted_to_stored_file_at" field.
func (m *TemporaryFileMutation) ClearConvertedToStoredFileAt() {
	m.converted_to_stored_file_at = nil
	m.clearedFields[temporaryfile.FieldConvertedToStoredFileAt] = struct{}{}
}

// ConvertedToStoredFileAtCleared returns if the "converted_to_stored_file_at" field was cleared in this mutation.
func (m *TemporaryFileMutation) ConvertedToStoredFileAtCleared() bool {
	_, ok := m.clearedFields[temporaryfile.FieldConvertedToStoredFileAt]
	return ok
}

// ResetConvertedToStoredFileAt resets all changes to the "converted_to_stored_file_at" field.
func (m *TemporaryFileMutation) ResetConvertedToStoredFileAt() {
	m.converted_to_stored_file_at = nil
	delete(m.clearedFields, temporaryfile.FieldConvertedToStoredFileAt)
}

// SetExpiresAt sets the "expires_at" field.
func (m *TemporaryFileMutation) SetExpiresAt(t time.Time) {
	m.expires_at = &t
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *TemporaryFileMutation) ExpiresAt() (r time.Time, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the TemporaryFile entity.
// If the TemporaryFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TemporaryFileMutation) OldExpiresAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ClearExpiresAt clears the value of the "expires_at" field.
func (m *TemporaryFileMutation) ClearExpiresAt() {
	m.expires_at = nil
	m.clearedFields[temporaryfile.FieldExpiresAt] = struct{}{}
}

// ExpiresAtCleared returns if the "expires_at" field was cleared in this mutation.
func (m *TemporaryFileMutation) ExpiresAtCleared() bool {
	_, ok := m.clearedFields[temporaryfile.FieldExpiresAt]
	return ok
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *TemporaryFileMutation) ResetExpiresAt() {
	m.expires_at = nil
	delete(m.clearedFields, temporaryfile.FieldExpiresAt)
}

// SetCreatorID sets the "creator" edge to the Account entity by id.
func (m *TemporaryFileMutation) SetCreatorID(id int64) {
	m.creator = &id
}

// ClearCreator clears the "creator" edge to the Account entity.
func (m *TemporaryFileMutation) ClearCreator() {
	m.clearedcreator = true
	m.clearedFields[temporaryfile.FieldCreatedBy] = struct{}{}
}

// CreatorCleared reports if the "creator" edge to the Account entity was cleared.
func (m *TemporaryFileMutation) CreatorCleared() bool {
	return m.CreatedByCleared() || m.clearedcreator
}

// CreatorID returns the "creator" edge ID in the mutation.
func (m *TemporaryFileMutation) CreatorID() (id int64, exists bool) {
	if m.creator != nil {
		return *m.creator, true
	}
	return
}

// CreatorIDs returns the "creator" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreatorID instead. It exists only for internal usage by the builders.
func (m *TemporaryFileMutation) CreatorIDs() (ids []int64) {
	if id := m.creator; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreator resets all changes to the "creator" edge.
func (m *TemporaryFileMutation) ResetCreator() {
	m.creator = nil
	m.clearedcreator = false
}

// SetUpdaterID sets the "updater" edge to the Account entity by id.
func (m *TemporaryFileMutation) SetUpdaterID(id int64) {
	m.updater = &id
}

// ClearUpdater clears the "updater" edge to the Account entity.
func (m *TemporaryFileMutation) ClearUpdater() {
	m.clearedupdater = true
	m.clearedFields[temporaryfile.FieldUpdatedBy] = struct{}{}
}

// UpdaterCleared reports if the "updater" edge to the Account entity was cleared.
func (m *TemporaryFileMutation) UpdaterCleared() bool {
	return m.UpdatedByCleared() || m.clearedupdater
}

// UpdaterID returns the "updater" edge ID in the mutation.
func (m *TemporaryFileMutation) UpdaterID() (id int64, exists bool) {
	if m.updater != nil {
		return *m.updater, true
	}
	return
}

// UpdaterIDs returns the "updater" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UpdaterID instead. It exists only for internal usage by the builders.
func (m *TemporaryFileMutation) UpdaterIDs() (ids []int64) {
	if id := m.updater; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUpdater resets all changes to the "updater" edge.
func (m *TemporaryFileMutation) ResetUpdater() {
	m.updater = nil
	m.clearedupdater = false
}

// SetDeleterID sets the "deleter" edge to the Account entity by id.
func (m *TemporaryFileMutation) SetDeleterID(id int64) {
	m.deleter = &id
}

// ClearDeleter clears the "deleter" edge to the Account entity.
func (m *TemporaryFileMutation) ClearDeleter() {
	m.cleareddeleter = true
	m.clearedFields[temporaryfile.FieldDeletedBy] = struct{}{}
}

// DeleterCleared reports if the "deleter" edge to the Account entity was cleared.
func (m *TemporaryFileMutation) DeleterCleared() bool {
	return m.DeletedByCleared() || m.cleareddeleter
}

// DeleterID returns the "deleter" edge ID in the mutation.
func (m *TemporaryFileMutation) DeleterID() (id int64, exists bool) {
	if m.deleter != nil {
		return *m.deleter, true
	}
	return
}

// DeleterIDs returns the "deleter" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DeleterID instead. It exists only for internal usage by the builders.
func (m *TemporaryFileMutation) DeleterIDs() (ids []int64) {
	if id := m.deleter; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDeleter resets all changes to the "deleter" edge.
func (m *TemporaryFileMutation) ResetDeleter() {
	m.deleter = nil
	m.cleareddeleter = false
}

// ClearOwner clears the "owner" edge to the Account entity.
func (m *TemporaryFileMutation) ClearOwner() {
	m.clearedowner = true
	m.clearedFields[temporaryfile.FieldOwnerID] = struct{}{}
}

// OwnerCleared reports if the "owner" edge to the Account entity was cleared.
func (m *TemporaryFileMutation) OwnerCleared() bool {
	return m.clearedowner
}

// OwnerIDs returns the "owner" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// OwnerID instead. It exists only for internal usage by the builders.
func (m *TemporaryFileMutation) OwnerIDs() (ids []int64) {
	if id := m.owner; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetOwner resets all changes to the "owner" edge.
func (m *TemporaryFileMutation) ResetOwner() {
	m.owner = nil
	m.clearedowner = false
}

// Where appends a list predicates to the TemporaryFileMutation builder.
func (m *TemporaryFileMutation) Where(ps ...predicate.TemporaryFile) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TemporaryFileMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TemporaryFileMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TemporaryFile, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TemporaryFileMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TemporaryFileMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TemporaryFile).
func (m *TemporaryFileMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TemporaryFileMutation) Fields() []string {
	fields := make([]string, 0, 23)
	if m.public_id != nil {
		fields = append(fields, temporaryfile.FieldPublicID)
	}
	if m.created_at != nil {
		fields = append(fields, temporaryfile.FieldCreatedAt)
	}
	if m.creator != nil {
		fields = append(fields, temporaryfile.FieldCreatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, temporaryfile.FieldUpdatedAt)
	}
	if m.updater != nil {
		fields = append(fields, temporaryfile.FieldUpdatedBy)
	}
	if m.deleter != nil {
		fields = append(fields, temporaryfile.FieldDeletedBy)
	}
	if m.deleted_at != nil {
		fields = append(fields, temporaryfile.FieldDeletedAt)
	}
	if m.upload_started_at != nil {
		fields = append(fields, temporaryfile.FieldUploadStartedAt)
	}
	if m.upload_failed_at != nil {
		fields = append(fields, temporaryfile.FieldUploadFailedAt)
	}
	if m.upload_succeeded_at != nil {
		fields = append(fields, temporaryfile.FieldUploadSucceededAt)
	}
	if m.owner != nil {
		fields = append(fields, temporaryfile.FieldOwnerID)
	}
	if m.filename != nil {
		fields = append(fields, temporaryfile.FieldFilename)
	}
	if m.size != nil {
		fields = append(fields, temporaryfile.FieldSize)
	}
	if m.size_in_storage != nil {
		fields = append(fields, temporaryfile.FieldSizeInStorage)
	}
	if m.sha256 != nil {
		fields = append(fields, temporaryfile.FieldSha256)
	}
	if m.mime_type != nil {
		fields = append(fields, temporaryfile.FieldMimeType)
	}
	if m.storage_type != nil {
		fields = append(fields, temporaryfile.FieldStorageType)
	}
	if m.bucket_name != nil {
		fields = append(fields, temporaryfile.FieldBucketName)
	}
	if m.storage_path != nil {
		fields = append(fields, temporaryfile.FieldStoragePath)
	}
	if m.storage_filename != nil {
		fields = append(fields, temporaryfile.FieldStorageFilename)
	}
	if m.upload_token != nil {
		fields = append(fields, temporaryfile.FieldUploadToken)
	}
	if m.converted_to_stored_file_at != nil {
		fields = append(fields, temporaryfile.FieldConvertedToStoredFileAt)
	}
	if m.expires_at != nil {
		fields = append(fields, temporaryfile.FieldExpiresAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TemporaryFileMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case temporaryfile.FieldPublicID:
		return m.PublicID()
	case temporaryfile.FieldCreatedAt:
		return m.CreatedAt()
	case temporaryfile.FieldCreatedBy:
		return m.CreatedBy()
	case temporaryfile.FieldUpdatedAt:
		return m.UpdatedAt()
	case temporaryfile.FieldUpdatedBy:
		return m.UpdatedBy()
	case temporaryfile.FieldDeletedBy:
		return m.DeletedBy()
	case temporaryfile.FieldDeletedAt:
		return m.DeletedAt()
	case temporaryfile.FieldUploadStartedAt:
		return m.UploadStartedAt()
	case temporaryfile.FieldUploadFailedAt:
		return m.UploadFailedAt()
	case temporaryfile.FieldUploadSucceededAt:
		return m.UploadSucceededAt()
	case temporaryfile.FieldOwnerID:
		return m.OwnerID()
	case temporaryfile.FieldFilename:
		return m.Filename()
	case temporaryfile.FieldSize:
		return m.Size()
	case temporaryfile.FieldSizeInStorage:
		return m.SizeInStorage()
	case temporaryfile.FieldSha256:
		return m.Sha256()
	case temporaryfile.FieldMimeType:
		return m.MimeType()
	case temporaryfile.FieldStorageType:
		return m.StorageType()
	case temporaryfile.FieldBucketName:
		return m.BucketName()
	case temporaryfile.FieldStoragePath:
		return m.StoragePath()
	case temporaryfile.FieldStorageFilename:
		return m.StorageFilename()
	case temporaryfile.FieldUploadToken:
		return m.UploadToken()
	case temporaryfile.FieldConvertedToStoredFileAt:
		return m.ConvertedToStoredFileAt()
	case temporaryfile.FieldExpiresAt:
		return m.ExpiresAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TemporaryFileMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case temporaryfile.FieldPublicID:
		return m.OldPublicID(ctx)
	case temporaryfile.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case temporaryfile.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case temporaryfile.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case temporaryfile.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case temporaryfile.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case temporaryfile.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case temporaryfile.FieldUploadStartedAt:
		return m.OldUploadStartedAt(ctx)
	case temporaryfile.FieldUploadFailedAt:
		return m.OldUploadFailedAt(ctx)
	case temporaryfile.FieldUploadSucceededAt:
		return m.OldUploadSucceededAt(ctx)
	case temporaryfile.FieldOwnerID:
		return m.OldOwnerID(ctx)
	case temporaryfile.FieldFilename:
		return m.OldFilename(ctx)
	case temporaryfile.FieldSize:
		return m.OldSize(ctx)
	case temporaryfile.FieldSizeInStorage:
		return m.OldSizeInStorage(ctx)
	case temporaryfile.FieldSha256:
		return m.OldSha256(ctx)
	case temporaryfile.FieldMimeType:
		return m.OldMimeType(ctx)
	case temporaryfile.FieldStorageType:
		return m.OldStorageType(ctx)
	case temporaryfile.FieldBucketName:
		return m.OldBucketName(ctx)
	case temporaryfile.FieldStoragePath:
		return m.OldStoragePath(ctx)
	case temporaryfile.FieldStorageFilename:
		return m.OldStorageFilename(ctx)
	case temporaryfile.FieldUploadToken:
		return m.OldUploadToken(ctx)
	case temporaryfile.FieldConvertedToStoredFileAt:
		return m.OldConvertedToStoredFileAt(ctx)
	case temporaryfile.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	}
	return nil, fmt.Errorf("unknown TemporaryFile field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TemporaryFileMutation) SetField(name string, value ent.Value) error {
	switch name {
	case temporaryfile.FieldPublicID:
		v, ok := value.(entx.CIText)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublicID(v)
		return nil
	case temporaryfile.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case temporaryfile.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case temporaryfile.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case temporaryfile.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case temporaryfile.FieldDeletedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case temporaryfile.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case temporaryfile.FieldUploadStartedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUploadStartedAt(v)
		return nil
	case temporaryfile.FieldUploadFailedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUploadFailedAt(v)
		return nil
	case temporaryfile.FieldUploadSucceededAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUploadSucceededAt(v)
		return nil
	case temporaryfile.FieldOwnerID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOwnerID(v)
		return nil
	case temporaryfile.FieldFilename:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFilename(v)
		return nil
	case temporaryfile.FieldSize:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSize(v)
		return nil
	case temporaryfile.FieldSizeInStorage:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSizeInStorage(v)
		return nil
	case temporaryfile.FieldSha256:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSha256(v)
		return nil
	case temporaryfile.FieldMimeType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMimeType(v)
		return nil
	case temporaryfile.FieldStorageType:
		v, ok := value.(storagetype.StorageType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStorageType(v)
		return nil
	case temporaryfile.FieldBucketName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBucketName(v)
		return nil
	case temporaryfile.FieldStoragePath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStoragePath(v)
		return nil
	case temporaryfile.FieldStorageFilename:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStorageFilename(v)
		return nil
	case temporaryfile.FieldUploadToken:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUploadToken(v)
		return nil
	case temporaryfile.FieldConvertedToStoredFileAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetConvertedToStoredFileAt(v)
		return nil
	case temporaryfile.FieldExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	}
	return fmt.Errorf("unknown TemporaryFile field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TemporaryFileMutation) AddedFields() []string {
	var fields []string
	if m.addsize != nil {
		fields = append(fields, temporaryfile.FieldSize)
	}
	if m.addsize_in_storage != nil {
		fields = append(fields, temporaryfile.FieldSizeInStorage)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TemporaryFileMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case temporaryfile.FieldSize:
		return m.AddedSize()
	case temporaryfile.FieldSizeInStorage:
		return m.AddedSizeInStorage()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TemporaryFileMutation) AddField(name string, value ent.Value) error {
	switch name {
	case temporaryfile.FieldSize:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSize(v)
		return nil
	case temporaryfile.FieldSizeInStorage:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSizeInStorage(v)
		return nil
	}
	return fmt.Errorf("unknown TemporaryFile numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TemporaryFileMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(temporaryfile.FieldCreatedBy) {
		fields = append(fields, temporaryfile.FieldCreatedBy)
	}
	if m.FieldCleared(temporaryfile.FieldUpdatedBy) {
		fields = append(fields, temporaryfile.FieldUpdatedBy)
	}
	if m.FieldCleared(temporaryfile.FieldDeletedBy) {
		fields = append(fields, temporaryfile.FieldDeletedBy)
	}
	if m.FieldCleared(temporaryfile.FieldDeletedAt) {
		fields = append(fields, temporaryfile.FieldDeletedAt)
	}
	if m.FieldCleared(temporaryfile.FieldUploadStartedAt) {
		fields = append(fields, temporaryfile.FieldUploadStartedAt)
	}
	if m.FieldCleared(temporaryfile.FieldUploadFailedAt) {
		fields = append(fields, temporaryfile.FieldUploadFailedAt)
	}
	if m.FieldCleared(temporaryfile.FieldUploadSucceededAt) {
		fields = append(fields, temporaryfile.FieldUploadSucceededAt)
	}
	if m.FieldCleared(temporaryfile.FieldSize) {
		fields = append(fields, temporaryfile.FieldSize)
	}
	if m.FieldCleared(temporaryfile.FieldSha256) {
		fields = append(fields, temporaryfile.FieldSha256)
	}
	if m.FieldCleared(temporaryfile.FieldMimeType) {
		fields = append(fields, temporaryfile.FieldMimeType)
	}
	if m.FieldCleared(temporaryfile.FieldBucketName) {
		fields = append(fields, temporaryfile.FieldBucketName)
	}
	if m.FieldCleared(temporaryfile.FieldConvertedToStoredFileAt) {
		fields = append(fields, temporaryfile.FieldConvertedToStoredFileAt)
	}
	if m.FieldCleared(temporaryfile.FieldExpiresAt) {
		fields = append(fields, temporaryfile.FieldExpiresAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TemporaryFileMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TemporaryFileMutation) ClearField(name string) error {
	switch name {
	case temporaryfile.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case temporaryfile.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case temporaryfile.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case temporaryfile.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case temporaryfile.FieldUploadStartedAt:
		m.ClearUploadStartedAt()
		return nil
	case temporaryfile.FieldUploadFailedAt:
		m.ClearUploadFailedAt()
		return nil
	case temporaryfile.FieldUploadSucceededAt:
		m.ClearUploadSucceededAt()
		return nil
	case temporaryfile.FieldSize:
		m.ClearSize()
		return nil
	case temporaryfile.FieldSha256:
		m.ClearSha256()
		return nil
	case temporaryfile.FieldMimeType:
		m.ClearMimeType()
		return nil
	case temporaryfile.FieldBucketName:
		m.ClearBucketName()
		return nil
	case temporaryfile.FieldConvertedToStoredFileAt:
		m.ClearConvertedToStoredFileAt()
		return nil
	case temporaryfile.FieldExpiresAt:
		m.ClearExpiresAt()
		return nil
	}
	return fmt.Errorf("unknown TemporaryFile nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TemporaryFileMutation) ResetField(name string) error {
	switch name {
	case temporaryfile.FieldPublicID:
		m.ResetPublicID()
		return nil
	case temporaryfile.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case temporaryfile.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case temporaryfile.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case temporaryfile.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case temporaryfile.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case temporaryfile.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case temporaryfile.FieldUploadStartedAt:
		m.ResetUploadStartedAt()
		return nil
	case temporaryfile.FieldUploadFailedAt:
		m.ResetUploadFailedAt()
		return nil
	case temporaryfile.FieldUploadSucceededAt:
		m.ResetUploadSucceededAt()
		return nil
	case temporaryfile.FieldOwnerID:
		m.ResetOwnerID()
		return nil
	case temporaryfile.FieldFilename:
		m.ResetFilename()
		return nil
	case temporaryfile.FieldSize:
		m.ResetSize()
		return nil
	case temporaryfile.FieldSizeInStorage:
		m.ResetSizeInStorage()
		return nil
	case temporaryfile.FieldSha256:
		m.ResetSha256()
		return nil
	case temporaryfile.FieldMimeType:
		m.ResetMimeType()
		return nil
	case temporaryfile.FieldStorageType:
		m.ResetStorageType()
		return nil
	case temporaryfile.FieldBucketName:
		m.ResetBucketName()
		return nil
	case temporaryfile.FieldStoragePath:
		m.ResetStoragePath()
		return nil
	case temporaryfile.FieldStorageFilename:
		m.ResetStorageFilename()
		return nil
	case temporaryfile.FieldUploadToken:
		m.ResetUploadToken()
		return nil
	case temporaryfile.FieldConvertedToStoredFileAt:
		m.ResetConvertedToStoredFileAt()
		return nil
	case temporaryfile.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	}
	return fmt.Errorf("unknown TemporaryFile field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TemporaryFileMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.creator != nil {
		edges = append(edges, temporaryfile.EdgeCreator)
	}
	if m.updater != nil {
		edges = append(edges, temporaryfile.EdgeUpdater)
	}
	if m.deleter != nil {
		edges = append(edges, temporaryfile.EdgeDeleter)
	}
	if m.owner != nil {
		edges = append(edges, temporaryfile.EdgeOwner)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TemporaryFileMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case temporaryfile.EdgeCreator:
		if id := m.creator; id != nil {
			return []ent.Value{*id}
		}
	case temporaryfile.EdgeUpdater:
		if id := m.updater; id != nil {
			return []ent.Value{*id}
		}
	case temporaryfile.EdgeDeleter:
		if id := m.deleter; id != nil {
			return []ent.Value{*id}
		}
	case temporaryfile.EdgeOwner:
		if id := m.owner; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TemporaryFileMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TemporaryFileMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TemporaryFileMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedcreator {
		edges = append(edges, temporaryfile.EdgeCreator)
	}
	if m.clearedupdater {
		edges = append(edges, temporaryfile.EdgeUpdater)
	}
	if m.cleareddeleter {
		edges = append(edges, temporaryfile.EdgeDeleter)
	}
	if m.clearedowner {
		edges = append(edges, temporaryfile.EdgeOwner)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TemporaryFileMutation) EdgeCleared(name string) bool {
	switch name {
	case temporaryfile.EdgeCreator:
		return m.clearedcreator
	case temporaryfile.EdgeUpdater:
		return m.clearedupdater
	case temporaryfile.EdgeDeleter:
		return m.cleareddeleter
	case temporaryfile.EdgeOwner:
		return m.clearedowner
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TemporaryFileMutation) ClearEdge(name string) error {
	switch name {
	case temporaryfile.EdgeCreator:
		m.ClearCreator()
		return nil
	case temporaryfile.EdgeUpdater:
		m.ClearUpdater()
		return nil
	case temporaryfile.EdgeDeleter:
		m.ClearDeleter()
		return nil
	case temporaryfile.EdgeOwner:
		m.ClearOwner()
		return nil
	}
	return fmt.Errorf("unknown TemporaryFile unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TemporaryFileMutation) ResetEdge(name string) error {
	switch name {
	case temporaryfile.EdgeCreator:
		m.ResetCreator()
		return nil
	case temporaryfile.EdgeUpdater:
		m.ResetUpdater()
		return nil
	case temporaryfile.EdgeDeleter:
		m.ResetDeleter()
		return nil
	case temporaryfile.EdgeOwner:
		m.ResetOwner()
		return nil
	}
	return fmt.Errorf("unknown TemporaryFile edge %s", name)
}

// TenantMutation represents an operation that mutates the Tenant nodes in the graph.
type TenantMutation struct {
	config
	op                          Op
	typ                         string
	id                          *int64
	created_at                  *time.Time
	updated_at                  *time.Time
	deleted_at                  *time.Time
	public_id                   *entx.CIText
	name                        *string
	first_name                  *string
	last_name                   *string
	street                      *string
	house_number                *string
	additional_address_info     *string
	postal_code                 *string
	city                        *string
	country                     *country.Country
	plan                        *plan.Plan
	vat_id                      *string
	terms_of_service_accepted   *time.Time
	privacy_policy_accepted     *time.Time
	two_factor_auth_enforced    *bool
	x25519_identity_encrypted   *entx.EncryptedX25519Identity
	maintenance_mode_enabled_at *time.Time
	initialized_at              *time.Time
	clearedFields               map[string]struct{}
	creator                     *int64
	clearedcreator              bool
	updater                     *int64
	clearedupdater              bool
	deleter                     *int64
	cleareddeleter              bool
	accounts                    map[int64]struct{}
	removedaccounts             map[int64]struct{}
	clearedaccounts             bool
	account_assignment          map[int64]struct{}
	removedaccount_assignment   map[int64]struct{}
	clearedaccount_assignment   bool
	done                        bool
	oldValue                    func(context.Context) (*Tenant, error)
	predicates                  []predicate.Tenant
}

var _ ent.Mutation = (*TenantMutation)(nil)

// tenantOption allows management of the mutation configuration using functional options.
type tenantOption func(*TenantMutation)

// newTenantMutation creates new mutation for the Tenant entity.
func newTenantMutation(c config, op Op, opts ...tenantOption) *TenantMutation {
	m := &TenantMutation{
		config:        c,
		op:            op,
		typ:           TypeTenant,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTenantID sets the ID field of the mutation.
func withTenantID(id int64) tenantOption {
	return func(m *TenantMutation) {
		var (
			err   error
			once  sync.Once
			value *Tenant
		)
		m.oldValue = func(ctx context.Context) (*Tenant, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Tenant.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTenant sets the old Tenant of the mutation.
func withTenant(node *Tenant) tenantOption {
	return func(m *TenantMutation) {
		m.oldValue = func(context.Context) (*Tenant, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TenantMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TenantMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("entmain: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Tenant entities.
func (m *TenantMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TenantMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TenantMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Tenant.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *TenantMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TenantMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the Tenant entity.
// If the Tenant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TenantMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *TenantMutation) SetCreatedBy(i int64) {
	m.creator = &i
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *TenantMutation) CreatedBy() (r int64, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the Tenant entity.
// If the Tenant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *TenantMutation) ClearCreatedBy() {
	m.creator = nil
	m.clearedFields[tenant.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *TenantMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[tenant.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *TenantMutation) ResetCreatedBy() {
	m.creator = nil
	delete(m.clearedFields, tenant.FieldCreatedBy)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TenantMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TenantMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the Tenant entity.
// If the Tenant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TenantMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *TenantMutation) SetUpdatedBy(i int64) {
	m.updater = &i
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *TenantMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updater
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the Tenant entity.
// If the Tenant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *TenantMutation) ClearUpdatedBy() {
	m.updater = nil
	m.clearedFields[tenant.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *TenantMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[tenant.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *TenantMutation) ResetUpdatedBy() {
	m.updater = nil
	delete(m.clearedFields, tenant.FieldUpdatedBy)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *TenantMutation) SetDeletedBy(i int64) {
	m.deleter = &i
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *TenantMutation) DeletedBy() (r int64, exists bool) {
	v := m.deleter
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the Tenant entity.
// If the Tenant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantMutation) OldDeletedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *TenantMutation) ClearDeletedBy() {
	m.deleter = nil
	m.clearedFields[tenant.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *TenantMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[tenant.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *TenantMutation) ResetDeletedBy() {
	m.deleter = nil
	delete(m.clearedFields, tenant.FieldDeletedBy)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *TenantMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *TenantMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Tenant entity.
// If the Tenant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *TenantMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[tenant.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *TenantMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[tenant.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *TenantMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, tenant.FieldDeletedAt)
}

// SetPublicID sets the "public_id" field.
func (m *TenantMutation) SetPublicID(et entx.CIText) {
	m.public_id = &et
}

// PublicID returns the value of the "public_id" field in the mutation.
func (m *TenantMutation) PublicID() (r entx.CIText, exists bool) {
	v := m.public_id
	if v == nil {
		return
	}
	return *v, true
}

// OldPublicID returns the old "public_id" field's value of the Tenant entity.
// If the Tenant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantMutation) OldPublicID(ctx context.Context) (v entx.CIText, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPublicID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPublicID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPublicID: %w", err)
	}
	return oldValue.PublicID, nil
}

// ResetPublicID resets all changes to the "public_id" field.
func (m *TenantMutation) ResetPublicID() {
	m.public_id = nil
}

// SetName sets the "name" field.
func (m *TenantMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TenantMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Tenant entity.
// If the Tenant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TenantMutation) ResetName() {
	m.name = nil
}

// SetFirstName sets the "first_name" field.
func (m *TenantMutation) SetFirstName(s string) {
	m.first_name = &s
}

// FirstName returns the value of the "first_name" field in the mutation.
func (m *TenantMutation) FirstName() (r string, exists bool) {
	v := m.first_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFirstName returns the old "first_name" field's value of the Tenant entity.
// If the Tenant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantMutation) OldFirstName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFirstName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFirstName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirstName: %w", err)
	}
	return oldValue.FirstName, nil
}

// ResetFirstName resets all changes to the "first_name" field.
func (m *TenantMutation) ResetFirstName() {
	m.first_name = nil
}

// SetLastName sets the "last_name" field.
func (m *TenantMutation) SetLastName(s string) {
	m.last_name = &s
}

// LastName returns the value of the "last_name" field in the mutation.
func (m *TenantMutation) LastName() (r string, exists bool) {
	v := m.last_name
	if v == nil {
		return
	}
	return *v, true
}

// OldLastName returns the old "last_name" field's value of the Tenant entity.
// If the Tenant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantMutation) OldLastName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastName: %w", err)
	}
	return oldValue.LastName, nil
}

// ResetLastName resets all changes to the "last_name" field.
func (m *TenantMutation) ResetLastName() {
	m.last_name = nil
}

// SetStreet sets the "street" field.
func (m *TenantMutation) SetStreet(s string) {
	m.street = &s
}

// Street returns the value of the "street" field in the mutation.
func (m *TenantMutation) Street() (r string, exists bool) {
	v := m.street
	if v == nil {
		return
	}
	return *v, true
}

// OldStreet returns the old "street" field's value of the Tenant entity.
// If the Tenant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantMutation) OldStreet(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStreet is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStreet requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStreet: %w", err)
	}
	return oldValue.Street, nil
}

// ResetStreet resets all changes to the "street" field.
func (m *TenantMutation) ResetStreet() {
	m.street = nil
}

// SetHouseNumber sets the "house_number" field.
func (m *TenantMutation) SetHouseNumber(s string) {
	m.house_number = &s
}

// HouseNumber returns the value of the "house_number" field in the mutation.
func (m *TenantMutation) HouseNumber() (r string, exists bool) {
	v := m.house_number
	if v == nil {
		return
	}
	return *v, true
}

// OldHouseNumber returns the old "house_number" field's value of the Tenant entity.
// If the Tenant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantMutation) OldHouseNumber(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldHouseNumber is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldHouseNumber requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHouseNumber: %w", err)
	}
	return oldValue.HouseNumber, nil
}

// ResetHouseNumber resets all changes to the "house_number" field.
func (m *TenantMutation) ResetHouseNumber() {
	m.house_number = nil
}

// SetAdditionalAddressInfo sets the "additional_address_info" field.
func (m *TenantMutation) SetAdditionalAddressInfo(s string) {
	m.additional_address_info = &s
}

// AdditionalAddressInfo returns the value of the "additional_address_info" field in the mutation.
func (m *TenantMutation) AdditionalAddressInfo() (r string, exists bool) {
	v := m.additional_address_info
	if v == nil {
		return
	}
	return *v, true
}

// OldAdditionalAddressInfo returns the old "additional_address_info" field's value of the Tenant entity.
// If the Tenant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantMutation) OldAdditionalAddressInfo(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAdditionalAddressInfo is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAdditionalAddressInfo requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAdditionalAddressInfo: %w", err)
	}
	return oldValue.AdditionalAddressInfo, nil
}

// ResetAdditionalAddressInfo resets all changes to the "additional_address_info" field.
func (m *TenantMutation) ResetAdditionalAddressInfo() {
	m.additional_address_info = nil
}

// SetPostalCode sets the "postal_code" field.
func (m *TenantMutation) SetPostalCode(s string) {
	m.postal_code = &s
}

// PostalCode returns the value of the "postal_code" field in the mutation.
func (m *TenantMutation) PostalCode() (r string, exists bool) {
	v := m.postal_code
	if v == nil {
		return
	}
	return *v, true
}

// OldPostalCode returns the old "postal_code" field's value of the Tenant entity.
// If the Tenant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantMutation) OldPostalCode(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPostalCode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPostalCode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPostalCode: %w", err)
	}
	return oldValue.PostalCode, nil
}

// ResetPostalCode resets all changes to the "postal_code" field.
func (m *TenantMutation) ResetPostalCode() {
	m.postal_code = nil
}

// SetCity sets the "city" field.
func (m *TenantMutation) SetCity(s string) {
	m.city = &s
}

// City returns the value of the "city" field in the mutation.
func (m *TenantMutation) City() (r string, exists bool) {
	v := m.city
	if v == nil {
		return
	}
	return *v, true
}

// OldCity returns the old "city" field's value of the Tenant entity.
// If the Tenant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantMutation) OldCity(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCity is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCity: %w", err)
	}
	return oldValue.City, nil
}

// ResetCity resets all changes to the "city" field.
func (m *TenantMutation) ResetCity() {
	m.city = nil
}

// SetCountry sets the "country" field.
func (m *TenantMutation) SetCountry(c country.Country) {
	m.country = &c
}

// Country returns the value of the "country" field in the mutation.
func (m *TenantMutation) Country() (r country.Country, exists bool) {
	v := m.country
	if v == nil {
		return
	}
	return *v, true
}

// OldCountry returns the old "country" field's value of the Tenant entity.
// If the Tenant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantMutation) OldCountry(ctx context.Context) (v country.Country, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCountry is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCountry requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCountry: %w", err)
	}
	return oldValue.Country, nil
}

// ResetCountry resets all changes to the "country" field.
func (m *TenantMutation) ResetCountry() {
	m.country = nil
}

// SetPlan sets the "plan" field.
func (m *TenantMutation) SetPlan(pl plan.Plan) {
	m.plan = &pl
}

// Plan returns the value of the "plan" field in the mutation.
func (m *TenantMutation) Plan() (r plan.Plan, exists bool) {
	v := m.plan
	if v == nil {
		return
	}
	return *v, true
}

// OldPlan returns the old "plan" field's value of the Tenant entity.
// If the Tenant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantMutation) OldPlan(ctx context.Context) (v plan.Plan, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPlan is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPlan requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPlan: %w", err)
	}
	return oldValue.Plan, nil
}

// ResetPlan resets all changes to the "plan" field.
func (m *TenantMutation) ResetPlan() {
	m.plan = nil
}

// SetVatID sets the "vat_id" field.
func (m *TenantMutation) SetVatID(s string) {
	m.vat_id = &s
}

// VatID returns the value of the "vat_id" field in the mutation.
func (m *TenantMutation) VatID() (r string, exists bool) {
	v := m.vat_id
	if v == nil {
		return
	}
	return *v, true
}

// OldVatID returns the old "vat_id" field's value of the Tenant entity.
// If the Tenant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantMutation) OldVatID(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldVatID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldVatID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldVatID: %w", err)
	}
	return oldValue.VatID, nil
}

// ResetVatID resets all changes to the "vat_id" field.
func (m *TenantMutation) ResetVatID() {
	m.vat_id = nil
}

// SetTermsOfServiceAccepted sets the "terms_of_service_accepted" field.
func (m *TenantMutation) SetTermsOfServiceAccepted(t time.Time) {
	m.terms_of_service_accepted = &t
}

// TermsOfServiceAccepted returns the value of the "terms_of_service_accepted" field in the mutation.
func (m *TenantMutation) TermsOfServiceAccepted() (r time.Time, exists bool) {
	v := m.terms_of_service_accepted
	if v == nil {
		return
	}
	return *v, true
}

// OldTermsOfServiceAccepted returns the old "terms_of_service_accepted" field's value of the Tenant entity.
// If the Tenant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantMutation) OldTermsOfServiceAccepted(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTermsOfServiceAccepted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTermsOfServiceAccepted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTermsOfServiceAccepted: %w", err)
	}
	return oldValue.TermsOfServiceAccepted, nil
}

// ResetTermsOfServiceAccepted resets all changes to the "terms_of_service_accepted" field.
func (m *TenantMutation) ResetTermsOfServiceAccepted() {
	m.terms_of_service_accepted = nil
}

// SetPrivacyPolicyAccepted sets the "privacy_policy_accepted" field.
func (m *TenantMutation) SetPrivacyPolicyAccepted(t time.Time) {
	m.privacy_policy_accepted = &t
}

// PrivacyPolicyAccepted returns the value of the "privacy_policy_accepted" field in the mutation.
func (m *TenantMutation) PrivacyPolicyAccepted() (r time.Time, exists bool) {
	v := m.privacy_policy_accepted
	if v == nil {
		return
	}
	return *v, true
}

// OldPrivacyPolicyAccepted returns the old "privacy_policy_accepted" field's value of the Tenant entity.
// If the Tenant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantMutation) OldPrivacyPolicyAccepted(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPrivacyPolicyAccepted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPrivacyPolicyAccepted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPrivacyPolicyAccepted: %w", err)
	}
	return oldValue.PrivacyPolicyAccepted, nil
}

// ResetPrivacyPolicyAccepted resets all changes to the "privacy_policy_accepted" field.
func (m *TenantMutation) ResetPrivacyPolicyAccepted() {
	m.privacy_policy_accepted = nil
}

// SetTwoFactorAuthEnforced sets the "two_factor_auth_enforced" field.
func (m *TenantMutation) SetTwoFactorAuthEnforced(b bool) {
	m.two_factor_auth_enforced = &b
}

// TwoFactorAuthEnforced returns the value of the "two_factor_auth_enforced" field in the mutation.
func (m *TenantMutation) TwoFactorAuthEnforced() (r bool, exists bool) {
	v := m.two_factor_auth_enforced
	if v == nil {
		return
	}
	return *v, true
}

// OldTwoFactorAuthEnforced returns the old "two_factor_auth_enforced" field's value of the Tenant entity.
// If the Tenant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantMutation) OldTwoFactorAuthEnforced(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTwoFactorAuthEnforced is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTwoFactorAuthEnforced requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTwoFactorAuthEnforced: %w", err)
	}
	return oldValue.TwoFactorAuthEnforced, nil
}

// ResetTwoFactorAuthEnforced resets all changes to the "two_factor_auth_enforced" field.
func (m *TenantMutation) ResetTwoFactorAuthEnforced() {
	m.two_factor_auth_enforced = nil
}

// SetX25519IdentityEncrypted sets the "x25519_identity_encrypted" field.
func (m *TenantMutation) SetX25519IdentityEncrypted(ex entx.EncryptedX25519Identity) {
	m.x25519_identity_encrypted = &ex
}

// X25519IdentityEncrypted returns the value of the "x25519_identity_encrypted" field in the mutation.
func (m *TenantMutation) X25519IdentityEncrypted() (r entx.EncryptedX25519Identity, exists bool) {
	v := m.x25519_identity_encrypted
	if v == nil {
		return
	}
	return *v, true
}

// OldX25519IdentityEncrypted returns the old "x25519_identity_encrypted" field's value of the Tenant entity.
// If the Tenant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantMutation) OldX25519IdentityEncrypted(ctx context.Context) (v entx.EncryptedX25519Identity, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldX25519IdentityEncrypted is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldX25519IdentityEncrypted requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldX25519IdentityEncrypted: %w", err)
	}
	return oldValue.X25519IdentityEncrypted, nil
}

// ClearX25519IdentityEncrypted clears the value of the "x25519_identity_encrypted" field.
func (m *TenantMutation) ClearX25519IdentityEncrypted() {
	m.x25519_identity_encrypted = nil
	m.clearedFields[tenant.FieldX25519IdentityEncrypted] = struct{}{}
}

// X25519IdentityEncryptedCleared returns if the "x25519_identity_encrypted" field was cleared in this mutation.
func (m *TenantMutation) X25519IdentityEncryptedCleared() bool {
	_, ok := m.clearedFields[tenant.FieldX25519IdentityEncrypted]
	return ok
}

// ResetX25519IdentityEncrypted resets all changes to the "x25519_identity_encrypted" field.
func (m *TenantMutation) ResetX25519IdentityEncrypted() {
	m.x25519_identity_encrypted = nil
	delete(m.clearedFields, tenant.FieldX25519IdentityEncrypted)
}

// SetMaintenanceModeEnabledAt sets the "maintenance_mode_enabled_at" field.
func (m *TenantMutation) SetMaintenanceModeEnabledAt(t time.Time) {
	m.maintenance_mode_enabled_at = &t
}

// MaintenanceModeEnabledAt returns the value of the "maintenance_mode_enabled_at" field in the mutation.
func (m *TenantMutation) MaintenanceModeEnabledAt() (r time.Time, exists bool) {
	v := m.maintenance_mode_enabled_at
	if v == nil {
		return
	}
	return *v, true
}

// OldMaintenanceModeEnabledAt returns the old "maintenance_mode_enabled_at" field's value of the Tenant entity.
// If the Tenant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantMutation) OldMaintenanceModeEnabledAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMaintenanceModeEnabledAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMaintenanceModeEnabledAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMaintenanceModeEnabledAt: %w", err)
	}
	return oldValue.MaintenanceModeEnabledAt, nil
}

// ClearMaintenanceModeEnabledAt clears the value of the "maintenance_mode_enabled_at" field.
func (m *TenantMutation) ClearMaintenanceModeEnabledAt() {
	m.maintenance_mode_enabled_at = nil
	m.clearedFields[tenant.FieldMaintenanceModeEnabledAt] = struct{}{}
}

// MaintenanceModeEnabledAtCleared returns if the "maintenance_mode_enabled_at" field was cleared in this mutation.
func (m *TenantMutation) MaintenanceModeEnabledAtCleared() bool {
	_, ok := m.clearedFields[tenant.FieldMaintenanceModeEnabledAt]
	return ok
}

// ResetMaintenanceModeEnabledAt resets all changes to the "maintenance_mode_enabled_at" field.
func (m *TenantMutation) ResetMaintenanceModeEnabledAt() {
	m.maintenance_mode_enabled_at = nil
	delete(m.clearedFields, tenant.FieldMaintenanceModeEnabledAt)
}

// SetInitializedAt sets the "initialized_at" field.
func (m *TenantMutation) SetInitializedAt(t time.Time) {
	m.initialized_at = &t
}

// InitializedAt returns the value of the "initialized_at" field in the mutation.
func (m *TenantMutation) InitializedAt() (r time.Time, exists bool) {
	v := m.initialized_at
	if v == nil {
		return
	}
	return *v, true
}

// OldInitializedAt returns the old "initialized_at" field's value of the Tenant entity.
// If the Tenant object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantMutation) OldInitializedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldInitializedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldInitializedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldInitializedAt: %w", err)
	}
	return oldValue.InitializedAt, nil
}

// ClearInitializedAt clears the value of the "initialized_at" field.
func (m *TenantMutation) ClearInitializedAt() {
	m.initialized_at = nil
	m.clearedFields[tenant.FieldInitializedAt] = struct{}{}
}

// InitializedAtCleared returns if the "initialized_at" field was cleared in this mutation.
func (m *TenantMutation) InitializedAtCleared() bool {
	_, ok := m.clearedFields[tenant.FieldInitializedAt]
	return ok
}

// ResetInitializedAt resets all changes to the "initialized_at" field.
func (m *TenantMutation) ResetInitializedAt() {
	m.initialized_at = nil
	delete(m.clearedFields, tenant.FieldInitializedAt)
}

// SetCreatorID sets the "creator" edge to the Account entity by id.
func (m *TenantMutation) SetCreatorID(id int64) {
	m.creator = &id
}

// ClearCreator clears the "creator" edge to the Account entity.
func (m *TenantMutation) ClearCreator() {
	m.clearedcreator = true
	m.clearedFields[tenant.FieldCreatedBy] = struct{}{}
}

// CreatorCleared reports if the "creator" edge to the Account entity was cleared.
func (m *TenantMutation) CreatorCleared() bool {
	return m.CreatedByCleared() || m.clearedcreator
}

// CreatorID returns the "creator" edge ID in the mutation.
func (m *TenantMutation) CreatorID() (id int64, exists bool) {
	if m.creator != nil {
		return *m.creator, true
	}
	return
}

// CreatorIDs returns the "creator" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreatorID instead. It exists only for internal usage by the builders.
func (m *TenantMutation) CreatorIDs() (ids []int64) {
	if id := m.creator; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreator resets all changes to the "creator" edge.
func (m *TenantMutation) ResetCreator() {
	m.creator = nil
	m.clearedcreator = false
}

// SetUpdaterID sets the "updater" edge to the Account entity by id.
func (m *TenantMutation) SetUpdaterID(id int64) {
	m.updater = &id
}

// ClearUpdater clears the "updater" edge to the Account entity.
func (m *TenantMutation) ClearUpdater() {
	m.clearedupdater = true
	m.clearedFields[tenant.FieldUpdatedBy] = struct{}{}
}

// UpdaterCleared reports if the "updater" edge to the Account entity was cleared.
func (m *TenantMutation) UpdaterCleared() bool {
	return m.UpdatedByCleared() || m.clearedupdater
}

// UpdaterID returns the "updater" edge ID in the mutation.
func (m *TenantMutation) UpdaterID() (id int64, exists bool) {
	if m.updater != nil {
		return *m.updater, true
	}
	return
}

// UpdaterIDs returns the "updater" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UpdaterID instead. It exists only for internal usage by the builders.
func (m *TenantMutation) UpdaterIDs() (ids []int64) {
	if id := m.updater; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUpdater resets all changes to the "updater" edge.
func (m *TenantMutation) ResetUpdater() {
	m.updater = nil
	m.clearedupdater = false
}

// SetDeleterID sets the "deleter" edge to the Account entity by id.
func (m *TenantMutation) SetDeleterID(id int64) {
	m.deleter = &id
}

// ClearDeleter clears the "deleter" edge to the Account entity.
func (m *TenantMutation) ClearDeleter() {
	m.cleareddeleter = true
	m.clearedFields[tenant.FieldDeletedBy] = struct{}{}
}

// DeleterCleared reports if the "deleter" edge to the Account entity was cleared.
func (m *TenantMutation) DeleterCleared() bool {
	return m.DeletedByCleared() || m.cleareddeleter
}

// DeleterID returns the "deleter" edge ID in the mutation.
func (m *TenantMutation) DeleterID() (id int64, exists bool) {
	if m.deleter != nil {
		return *m.deleter, true
	}
	return
}

// DeleterIDs returns the "deleter" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DeleterID instead. It exists only for internal usage by the builders.
func (m *TenantMutation) DeleterIDs() (ids []int64) {
	if id := m.deleter; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDeleter resets all changes to the "deleter" edge.
func (m *TenantMutation) ResetDeleter() {
	m.deleter = nil
	m.cleareddeleter = false
}

// AddAccountIDs adds the "accounts" edge to the Account entity by ids.
func (m *TenantMutation) AddAccountIDs(ids ...int64) {
	if m.accounts == nil {
		m.accounts = make(map[int64]struct{})
	}
	for i := range ids {
		m.accounts[ids[i]] = struct{}{}
	}
}

// ClearAccounts clears the "accounts" edge to the Account entity.
func (m *TenantMutation) ClearAccounts() {
	m.clearedaccounts = true
}

// AccountsCleared reports if the "accounts" edge to the Account entity was cleared.
func (m *TenantMutation) AccountsCleared() bool {
	return m.clearedaccounts
}

// RemoveAccountIDs removes the "accounts" edge to the Account entity by IDs.
func (m *TenantMutation) RemoveAccountIDs(ids ...int64) {
	if m.removedaccounts == nil {
		m.removedaccounts = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.accounts, ids[i])
		m.removedaccounts[ids[i]] = struct{}{}
	}
}

// RemovedAccounts returns the removed IDs of the "accounts" edge to the Account entity.
func (m *TenantMutation) RemovedAccountsIDs() (ids []int64) {
	for id := range m.removedaccounts {
		ids = append(ids, id)
	}
	return
}

// AccountsIDs returns the "accounts" edge IDs in the mutation.
func (m *TenantMutation) AccountsIDs() (ids []int64) {
	for id := range m.accounts {
		ids = append(ids, id)
	}
	return
}

// ResetAccounts resets all changes to the "accounts" edge.
func (m *TenantMutation) ResetAccounts() {
	m.accounts = nil
	m.clearedaccounts = false
	m.removedaccounts = nil
}

// AddAccountAssignmentIDs adds the "account_assignment" edge to the TenantAccountAssignment entity by ids.
func (m *TenantMutation) AddAccountAssignmentIDs(ids ...int64) {
	if m.account_assignment == nil {
		m.account_assignment = make(map[int64]struct{})
	}
	for i := range ids {
		m.account_assignment[ids[i]] = struct{}{}
	}
}

// ClearAccountAssignment clears the "account_assignment" edge to the TenantAccountAssignment entity.
func (m *TenantMutation) ClearAccountAssignment() {
	m.clearedaccount_assignment = true
}

// AccountAssignmentCleared reports if the "account_assignment" edge to the TenantAccountAssignment entity was cleared.
func (m *TenantMutation) AccountAssignmentCleared() bool {
	return m.clearedaccount_assignment
}

// RemoveAccountAssignmentIDs removes the "account_assignment" edge to the TenantAccountAssignment entity by IDs.
func (m *TenantMutation) RemoveAccountAssignmentIDs(ids ...int64) {
	if m.removedaccount_assignment == nil {
		m.removedaccount_assignment = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.account_assignment, ids[i])
		m.removedaccount_assignment[ids[i]] = struct{}{}
	}
}

// RemovedAccountAssignment returns the removed IDs of the "account_assignment" edge to the TenantAccountAssignment entity.
func (m *TenantMutation) RemovedAccountAssignmentIDs() (ids []int64) {
	for id := range m.removedaccount_assignment {
		ids = append(ids, id)
	}
	return
}

// AccountAssignmentIDs returns the "account_assignment" edge IDs in the mutation.
func (m *TenantMutation) AccountAssignmentIDs() (ids []int64) {
	for id := range m.account_assignment {
		ids = append(ids, id)
	}
	return
}

// ResetAccountAssignment resets all changes to the "account_assignment" edge.
func (m *TenantMutation) ResetAccountAssignment() {
	m.account_assignment = nil
	m.clearedaccount_assignment = false
	m.removedaccount_assignment = nil
}

// Where appends a list predicates to the TenantMutation builder.
func (m *TenantMutation) Where(ps ...predicate.Tenant) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TenantMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TenantMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Tenant, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TenantMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TenantMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Tenant).
func (m *TenantMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TenantMutation) Fields() []string {
	fields := make([]string, 0, 24)
	if m.created_at != nil {
		fields = append(fields, tenant.FieldCreatedAt)
	}
	if m.creator != nil {
		fields = append(fields, tenant.FieldCreatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, tenant.FieldUpdatedAt)
	}
	if m.updater != nil {
		fields = append(fields, tenant.FieldUpdatedBy)
	}
	if m.deleter != nil {
		fields = append(fields, tenant.FieldDeletedBy)
	}
	if m.deleted_at != nil {
		fields = append(fields, tenant.FieldDeletedAt)
	}
	if m.public_id != nil {
		fields = append(fields, tenant.FieldPublicID)
	}
	if m.name != nil {
		fields = append(fields, tenant.FieldName)
	}
	if m.first_name != nil {
		fields = append(fields, tenant.FieldFirstName)
	}
	if m.last_name != nil {
		fields = append(fields, tenant.FieldLastName)
	}
	if m.street != nil {
		fields = append(fields, tenant.FieldStreet)
	}
	if m.house_number != nil {
		fields = append(fields, tenant.FieldHouseNumber)
	}
	if m.additional_address_info != nil {
		fields = append(fields, tenant.FieldAdditionalAddressInfo)
	}
	if m.postal_code != nil {
		fields = append(fields, tenant.FieldPostalCode)
	}
	if m.city != nil {
		fields = append(fields, tenant.FieldCity)
	}
	if m.country != nil {
		fields = append(fields, tenant.FieldCountry)
	}
	if m.plan != nil {
		fields = append(fields, tenant.FieldPlan)
	}
	if m.vat_id != nil {
		fields = append(fields, tenant.FieldVatID)
	}
	if m.terms_of_service_accepted != nil {
		fields = append(fields, tenant.FieldTermsOfServiceAccepted)
	}
	if m.privacy_policy_accepted != nil {
		fields = append(fields, tenant.FieldPrivacyPolicyAccepted)
	}
	if m.two_factor_auth_enforced != nil {
		fields = append(fields, tenant.FieldTwoFactorAuthEnforced)
	}
	if m.x25519_identity_encrypted != nil {
		fields = append(fields, tenant.FieldX25519IdentityEncrypted)
	}
	if m.maintenance_mode_enabled_at != nil {
		fields = append(fields, tenant.FieldMaintenanceModeEnabledAt)
	}
	if m.initialized_at != nil {
		fields = append(fields, tenant.FieldInitializedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TenantMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tenant.FieldCreatedAt:
		return m.CreatedAt()
	case tenant.FieldCreatedBy:
		return m.CreatedBy()
	case tenant.FieldUpdatedAt:
		return m.UpdatedAt()
	case tenant.FieldUpdatedBy:
		return m.UpdatedBy()
	case tenant.FieldDeletedBy:
		return m.DeletedBy()
	case tenant.FieldDeletedAt:
		return m.DeletedAt()
	case tenant.FieldPublicID:
		return m.PublicID()
	case tenant.FieldName:
		return m.Name()
	case tenant.FieldFirstName:
		return m.FirstName()
	case tenant.FieldLastName:
		return m.LastName()
	case tenant.FieldStreet:
		return m.Street()
	case tenant.FieldHouseNumber:
		return m.HouseNumber()
	case tenant.FieldAdditionalAddressInfo:
		return m.AdditionalAddressInfo()
	case tenant.FieldPostalCode:
		return m.PostalCode()
	case tenant.FieldCity:
		return m.City()
	case tenant.FieldCountry:
		return m.Country()
	case tenant.FieldPlan:
		return m.Plan()
	case tenant.FieldVatID:
		return m.VatID()
	case tenant.FieldTermsOfServiceAccepted:
		return m.TermsOfServiceAccepted()
	case tenant.FieldPrivacyPolicyAccepted:
		return m.PrivacyPolicyAccepted()
	case tenant.FieldTwoFactorAuthEnforced:
		return m.TwoFactorAuthEnforced()
	case tenant.FieldX25519IdentityEncrypted:
		return m.X25519IdentityEncrypted()
	case tenant.FieldMaintenanceModeEnabledAt:
		return m.MaintenanceModeEnabledAt()
	case tenant.FieldInitializedAt:
		return m.InitializedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TenantMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tenant.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case tenant.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case tenant.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case tenant.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case tenant.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case tenant.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case tenant.FieldPublicID:
		return m.OldPublicID(ctx)
	case tenant.FieldName:
		return m.OldName(ctx)
	case tenant.FieldFirstName:
		return m.OldFirstName(ctx)
	case tenant.FieldLastName:
		return m.OldLastName(ctx)
	case tenant.FieldStreet:
		return m.OldStreet(ctx)
	case tenant.FieldHouseNumber:
		return m.OldHouseNumber(ctx)
	case tenant.FieldAdditionalAddressInfo:
		return m.OldAdditionalAddressInfo(ctx)
	case tenant.FieldPostalCode:
		return m.OldPostalCode(ctx)
	case tenant.FieldCity:
		return m.OldCity(ctx)
	case tenant.FieldCountry:
		return m.OldCountry(ctx)
	case tenant.FieldPlan:
		return m.OldPlan(ctx)
	case tenant.FieldVatID:
		return m.OldVatID(ctx)
	case tenant.FieldTermsOfServiceAccepted:
		return m.OldTermsOfServiceAccepted(ctx)
	case tenant.FieldPrivacyPolicyAccepted:
		return m.OldPrivacyPolicyAccepted(ctx)
	case tenant.FieldTwoFactorAuthEnforced:
		return m.OldTwoFactorAuthEnforced(ctx)
	case tenant.FieldX25519IdentityEncrypted:
		return m.OldX25519IdentityEncrypted(ctx)
	case tenant.FieldMaintenanceModeEnabledAt:
		return m.OldMaintenanceModeEnabledAt(ctx)
	case tenant.FieldInitializedAt:
		return m.OldInitializedAt(ctx)
	}
	return nil, fmt.Errorf("unknown Tenant field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TenantMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tenant.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case tenant.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case tenant.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case tenant.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case tenant.FieldDeletedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case tenant.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case tenant.FieldPublicID:
		v, ok := value.(entx.CIText)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublicID(v)
		return nil
	case tenant.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case tenant.FieldFirstName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirstName(v)
		return nil
	case tenant.FieldLastName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastName(v)
		return nil
	case tenant.FieldStreet:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStreet(v)
		return nil
	case tenant.FieldHouseNumber:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHouseNumber(v)
		return nil
	case tenant.FieldAdditionalAddressInfo:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAdditionalAddressInfo(v)
		return nil
	case tenant.FieldPostalCode:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPostalCode(v)
		return nil
	case tenant.FieldCity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCity(v)
		return nil
	case tenant.FieldCountry:
		v, ok := value.(country.Country)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCountry(v)
		return nil
	case tenant.FieldPlan:
		v, ok := value.(plan.Plan)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPlan(v)
		return nil
	case tenant.FieldVatID:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetVatID(v)
		return nil
	case tenant.FieldTermsOfServiceAccepted:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTermsOfServiceAccepted(v)
		return nil
	case tenant.FieldPrivacyPolicyAccepted:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPrivacyPolicyAccepted(v)
		return nil
	case tenant.FieldTwoFactorAuthEnforced:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTwoFactorAuthEnforced(v)
		return nil
	case tenant.FieldX25519IdentityEncrypted:
		v, ok := value.(entx.EncryptedX25519Identity)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetX25519IdentityEncrypted(v)
		return nil
	case tenant.FieldMaintenanceModeEnabledAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMaintenanceModeEnabledAt(v)
		return nil
	case tenant.FieldInitializedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetInitializedAt(v)
		return nil
	}
	return fmt.Errorf("unknown Tenant field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TenantMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TenantMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TenantMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Tenant numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TenantMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(tenant.FieldCreatedBy) {
		fields = append(fields, tenant.FieldCreatedBy)
	}
	if m.FieldCleared(tenant.FieldUpdatedBy) {
		fields = append(fields, tenant.FieldUpdatedBy)
	}
	if m.FieldCleared(tenant.FieldDeletedBy) {
		fields = append(fields, tenant.FieldDeletedBy)
	}
	if m.FieldCleared(tenant.FieldDeletedAt) {
		fields = append(fields, tenant.FieldDeletedAt)
	}
	if m.FieldCleared(tenant.FieldX25519IdentityEncrypted) {
		fields = append(fields, tenant.FieldX25519IdentityEncrypted)
	}
	if m.FieldCleared(tenant.FieldMaintenanceModeEnabledAt) {
		fields = append(fields, tenant.FieldMaintenanceModeEnabledAt)
	}
	if m.FieldCleared(tenant.FieldInitializedAt) {
		fields = append(fields, tenant.FieldInitializedAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TenantMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TenantMutation) ClearField(name string) error {
	switch name {
	case tenant.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case tenant.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case tenant.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case tenant.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case tenant.FieldX25519IdentityEncrypted:
		m.ClearX25519IdentityEncrypted()
		return nil
	case tenant.FieldMaintenanceModeEnabledAt:
		m.ClearMaintenanceModeEnabledAt()
		return nil
	case tenant.FieldInitializedAt:
		m.ClearInitializedAt()
		return nil
	}
	return fmt.Errorf("unknown Tenant nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TenantMutation) ResetField(name string) error {
	switch name {
	case tenant.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case tenant.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case tenant.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case tenant.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case tenant.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case tenant.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case tenant.FieldPublicID:
		m.ResetPublicID()
		return nil
	case tenant.FieldName:
		m.ResetName()
		return nil
	case tenant.FieldFirstName:
		m.ResetFirstName()
		return nil
	case tenant.FieldLastName:
		m.ResetLastName()
		return nil
	case tenant.FieldStreet:
		m.ResetStreet()
		return nil
	case tenant.FieldHouseNumber:
		m.ResetHouseNumber()
		return nil
	case tenant.FieldAdditionalAddressInfo:
		m.ResetAdditionalAddressInfo()
		return nil
	case tenant.FieldPostalCode:
		m.ResetPostalCode()
		return nil
	case tenant.FieldCity:
		m.ResetCity()
		return nil
	case tenant.FieldCountry:
		m.ResetCountry()
		return nil
	case tenant.FieldPlan:
		m.ResetPlan()
		return nil
	case tenant.FieldVatID:
		m.ResetVatID()
		return nil
	case tenant.FieldTermsOfServiceAccepted:
		m.ResetTermsOfServiceAccepted()
		return nil
	case tenant.FieldPrivacyPolicyAccepted:
		m.ResetPrivacyPolicyAccepted()
		return nil
	case tenant.FieldTwoFactorAuthEnforced:
		m.ResetTwoFactorAuthEnforced()
		return nil
	case tenant.FieldX25519IdentityEncrypted:
		m.ResetX25519IdentityEncrypted()
		return nil
	case tenant.FieldMaintenanceModeEnabledAt:
		m.ResetMaintenanceModeEnabledAt()
		return nil
	case tenant.FieldInitializedAt:
		m.ResetInitializedAt()
		return nil
	}
	return fmt.Errorf("unknown Tenant field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TenantMutation) AddedEdges() []string {
	edges := make([]string, 0, 5)
	if m.creator != nil {
		edges = append(edges, tenant.EdgeCreator)
	}
	if m.updater != nil {
		edges = append(edges, tenant.EdgeUpdater)
	}
	if m.deleter != nil {
		edges = append(edges, tenant.EdgeDeleter)
	}
	if m.accounts != nil {
		edges = append(edges, tenant.EdgeAccounts)
	}
	if m.account_assignment != nil {
		edges = append(edges, tenant.EdgeAccountAssignment)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TenantMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case tenant.EdgeCreator:
		if id := m.creator; id != nil {
			return []ent.Value{*id}
		}
	case tenant.EdgeUpdater:
		if id := m.updater; id != nil {
			return []ent.Value{*id}
		}
	case tenant.EdgeDeleter:
		if id := m.deleter; id != nil {
			return []ent.Value{*id}
		}
	case tenant.EdgeAccounts:
		ids := make([]ent.Value, 0, len(m.accounts))
		for id := range m.accounts {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeAccountAssignment:
		ids := make([]ent.Value, 0, len(m.account_assignment))
		for id := range m.account_assignment {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TenantMutation) RemovedEdges() []string {
	edges := make([]string, 0, 5)
	if m.removedaccounts != nil {
		edges = append(edges, tenant.EdgeAccounts)
	}
	if m.removedaccount_assignment != nil {
		edges = append(edges, tenant.EdgeAccountAssignment)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TenantMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case tenant.EdgeAccounts:
		ids := make([]ent.Value, 0, len(m.removedaccounts))
		for id := range m.removedaccounts {
			ids = append(ids, id)
		}
		return ids
	case tenant.EdgeAccountAssignment:
		ids := make([]ent.Value, 0, len(m.removedaccount_assignment))
		for id := range m.removedaccount_assignment {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TenantMutation) ClearedEdges() []string {
	edges := make([]string, 0, 5)
	if m.clearedcreator {
		edges = append(edges, tenant.EdgeCreator)
	}
	if m.clearedupdater {
		edges = append(edges, tenant.EdgeUpdater)
	}
	if m.cleareddeleter {
		edges = append(edges, tenant.EdgeDeleter)
	}
	if m.clearedaccounts {
		edges = append(edges, tenant.EdgeAccounts)
	}
	if m.clearedaccount_assignment {
		edges = append(edges, tenant.EdgeAccountAssignment)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TenantMutation) EdgeCleared(name string) bool {
	switch name {
	case tenant.EdgeCreator:
		return m.clearedcreator
	case tenant.EdgeUpdater:
		return m.clearedupdater
	case tenant.EdgeDeleter:
		return m.cleareddeleter
	case tenant.EdgeAccounts:
		return m.clearedaccounts
	case tenant.EdgeAccountAssignment:
		return m.clearedaccount_assignment
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TenantMutation) ClearEdge(name string) error {
	switch name {
	case tenant.EdgeCreator:
		m.ClearCreator()
		return nil
	case tenant.EdgeUpdater:
		m.ClearUpdater()
		return nil
	case tenant.EdgeDeleter:
		m.ClearDeleter()
		return nil
	}
	return fmt.Errorf("unknown Tenant unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TenantMutation) ResetEdge(name string) error {
	switch name {
	case tenant.EdgeCreator:
		m.ResetCreator()
		return nil
	case tenant.EdgeUpdater:
		m.ResetUpdater()
		return nil
	case tenant.EdgeDeleter:
		m.ResetDeleter()
		return nil
	case tenant.EdgeAccounts:
		m.ResetAccounts()
		return nil
	case tenant.EdgeAccountAssignment:
		m.ResetAccountAssignment()
		return nil
	}
	return fmt.Errorf("unknown Tenant edge %s", name)
}

// TenantAccountAssignmentMutation represents an operation that mutates the TenantAccountAssignment nodes in the graph.
type TenantAccountAssignmentMutation struct {
	config
	op                Op
	typ               string
	id                *int64
	created_at        *time.Time
	updated_at        *time.Time
	is_contact_person *bool
	is_default        *bool
	role              *tenantrole.TenantRole
	expires_at        *time.Time
	clearedFields     map[string]struct{}
	creator           *int64
	clearedcreator    bool
	updater           *int64
	clearedupdater    bool
	tenant            *int64
	clearedtenant     bool
	account           *int64
	clearedaccount    bool
	done              bool
	oldValue          func(context.Context) (*TenantAccountAssignment, error)
	predicates        []predicate.TenantAccountAssignment
}

var _ ent.Mutation = (*TenantAccountAssignmentMutation)(nil)

// tenantaccountassignmentOption allows management of the mutation configuration using functional options.
type tenantaccountassignmentOption func(*TenantAccountAssignmentMutation)

// newTenantAccountAssignmentMutation creates new mutation for the TenantAccountAssignment entity.
func newTenantAccountAssignmentMutation(c config, op Op, opts ...tenantaccountassignmentOption) *TenantAccountAssignmentMutation {
	m := &TenantAccountAssignmentMutation{
		config:        c,
		op:            op,
		typ:           TypeTenantAccountAssignment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTenantAccountAssignmentID sets the ID field of the mutation.
func withTenantAccountAssignmentID(id int64) tenantaccountassignmentOption {
	return func(m *TenantAccountAssignmentMutation) {
		var (
			err   error
			once  sync.Once
			value *TenantAccountAssignment
		)
		m.oldValue = func(ctx context.Context) (*TenantAccountAssignment, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TenantAccountAssignment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTenantAccountAssignment sets the old TenantAccountAssignment of the mutation.
func withTenantAccountAssignment(node *TenantAccountAssignment) tenantaccountassignmentOption {
	return func(m *TenantAccountAssignmentMutation) {
		m.oldValue = func(context.Context) (*TenantAccountAssignment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TenantAccountAssignmentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TenantAccountAssignmentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("entmain: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of TenantAccountAssignment entities.
func (m *TenantAccountAssignmentMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TenantAccountAssignmentMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TenantAccountAssignmentMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TenantAccountAssignment.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *TenantAccountAssignmentMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *TenantAccountAssignmentMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the TenantAccountAssignment entity.
// If the TenantAccountAssignment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantAccountAssignmentMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *TenantAccountAssignmentMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *TenantAccountAssignmentMutation) SetCreatedBy(i int64) {
	m.creator = &i
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *TenantAccountAssignmentMutation) CreatedBy() (r int64, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the TenantAccountAssignment entity.
// If the TenantAccountAssignment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantAccountAssignmentMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *TenantAccountAssignmentMutation) ClearCreatedBy() {
	m.creator = nil
	m.clearedFields[tenantaccountassignment.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *TenantAccountAssignmentMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[tenantaccountassignment.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *TenantAccountAssignmentMutation) ResetCreatedBy() {
	m.creator = nil
	delete(m.clearedFields, tenantaccountassignment.FieldCreatedBy)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *TenantAccountAssignmentMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *TenantAccountAssignmentMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the TenantAccountAssignment entity.
// If the TenantAccountAssignment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantAccountAssignmentMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *TenantAccountAssignmentMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *TenantAccountAssignmentMutation) SetUpdatedBy(i int64) {
	m.updater = &i
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *TenantAccountAssignmentMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updater
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the TenantAccountAssignment entity.
// If the TenantAccountAssignment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantAccountAssignmentMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *TenantAccountAssignmentMutation) ClearUpdatedBy() {
	m.updater = nil
	m.clearedFields[tenantaccountassignment.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *TenantAccountAssignmentMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[tenantaccountassignment.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *TenantAccountAssignmentMutation) ResetUpdatedBy() {
	m.updater = nil
	delete(m.clearedFields, tenantaccountassignment.FieldUpdatedBy)
}

// SetTenantID sets the "tenant_id" field.
func (m *TenantAccountAssignmentMutation) SetTenantID(i int64) {
	m.tenant = &i
}

// TenantID returns the value of the "tenant_id" field in the mutation.
func (m *TenantAccountAssignmentMutation) TenantID() (r int64, exists bool) {
	v := m.tenant
	if v == nil {
		return
	}
	return *v, true
}

// OldTenantID returns the old "tenant_id" field's value of the TenantAccountAssignment entity.
// If the TenantAccountAssignment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantAccountAssignmentMutation) OldTenantID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTenantID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTenantID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTenantID: %w", err)
	}
	return oldValue.TenantID, nil
}

// ResetTenantID resets all changes to the "tenant_id" field.
func (m *TenantAccountAssignmentMutation) ResetTenantID() {
	m.tenant = nil
}

// SetAccountID sets the "account_id" field.
func (m *TenantAccountAssignmentMutation) SetAccountID(i int64) {
	m.account = &i
}

// AccountID returns the value of the "account_id" field in the mutation.
func (m *TenantAccountAssignmentMutation) AccountID() (r int64, exists bool) {
	v := m.account
	if v == nil {
		return
	}
	return *v, true
}

// OldAccountID returns the old "account_id" field's value of the TenantAccountAssignment entity.
// If the TenantAccountAssignment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantAccountAssignmentMutation) OldAccountID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccountID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccountID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccountID: %w", err)
	}
	return oldValue.AccountID, nil
}

// ResetAccountID resets all changes to the "account_id" field.
func (m *TenantAccountAssignmentMutation) ResetAccountID() {
	m.account = nil
}

// SetIsContactPerson sets the "is_contact_person" field.
func (m *TenantAccountAssignmentMutation) SetIsContactPerson(b bool) {
	m.is_contact_person = &b
}

// IsContactPerson returns the value of the "is_contact_person" field in the mutation.
func (m *TenantAccountAssignmentMutation) IsContactPerson() (r bool, exists bool) {
	v := m.is_contact_person
	if v == nil {
		return
	}
	return *v, true
}

// OldIsContactPerson returns the old "is_contact_person" field's value of the TenantAccountAssignment entity.
// If the TenantAccountAssignment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantAccountAssignmentMutation) OldIsContactPerson(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsContactPerson is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsContactPerson requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsContactPerson: %w", err)
	}
	return oldValue.IsContactPerson, nil
}

// ResetIsContactPerson resets all changes to the "is_contact_person" field.
func (m *TenantAccountAssignmentMutation) ResetIsContactPerson() {
	m.is_contact_person = nil
}

// SetIsDefault sets the "is_default" field.
func (m *TenantAccountAssignmentMutation) SetIsDefault(b bool) {
	m.is_default = &b
}

// IsDefault returns the value of the "is_default" field in the mutation.
func (m *TenantAccountAssignmentMutation) IsDefault() (r bool, exists bool) {
	v := m.is_default
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDefault returns the old "is_default" field's value of the TenantAccountAssignment entity.
// If the TenantAccountAssignment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantAccountAssignmentMutation) OldIsDefault(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDefault is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDefault requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDefault: %w", err)
	}
	return oldValue.IsDefault, nil
}

// ResetIsDefault resets all changes to the "is_default" field.
func (m *TenantAccountAssignmentMutation) ResetIsDefault() {
	m.is_default = nil
}

// SetRole sets the "role" field.
func (m *TenantAccountAssignmentMutation) SetRole(tr tenantrole.TenantRole) {
	m.role = &tr
}

// Role returns the value of the "role" field in the mutation.
func (m *TenantAccountAssignmentMutation) Role() (r tenantrole.TenantRole, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRole returns the old "role" field's value of the TenantAccountAssignment entity.
// If the TenantAccountAssignment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantAccountAssignmentMutation) OldRole(ctx context.Context) (v tenantrole.TenantRole, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRole is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRole: %w", err)
	}
	return oldValue.Role, nil
}

// ResetRole resets all changes to the "role" field.
func (m *TenantAccountAssignmentMutation) ResetRole() {
	m.role = nil
}

// SetExpiresAt sets the "expires_at" field.
func (m *TenantAccountAssignmentMutation) SetExpiresAt(t time.Time) {
	m.expires_at = &t
}

// ExpiresAt returns the value of the "expires_at" field in the mutation.
func (m *TenantAccountAssignmentMutation) ExpiresAt() (r time.Time, exists bool) {
	v := m.expires_at
	if v == nil {
		return
	}
	return *v, true
}

// OldExpiresAt returns the old "expires_at" field's value of the TenantAccountAssignment entity.
// If the TenantAccountAssignment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TenantAccountAssignmentMutation) OldExpiresAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldExpiresAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldExpiresAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldExpiresAt: %w", err)
	}
	return oldValue.ExpiresAt, nil
}

// ClearExpiresAt clears the value of the "expires_at" field.
func (m *TenantAccountAssignmentMutation) ClearExpiresAt() {
	m.expires_at = nil
	m.clearedFields[tenantaccountassignment.FieldExpiresAt] = struct{}{}
}

// ExpiresAtCleared returns if the "expires_at" field was cleared in this mutation.
func (m *TenantAccountAssignmentMutation) ExpiresAtCleared() bool {
	_, ok := m.clearedFields[tenantaccountassignment.FieldExpiresAt]
	return ok
}

// ResetExpiresAt resets all changes to the "expires_at" field.
func (m *TenantAccountAssignmentMutation) ResetExpiresAt() {
	m.expires_at = nil
	delete(m.clearedFields, tenantaccountassignment.FieldExpiresAt)
}

// SetCreatorID sets the "creator" edge to the Account entity by id.
func (m *TenantAccountAssignmentMutation) SetCreatorID(id int64) {
	m.creator = &id
}

// ClearCreator clears the "creator" edge to the Account entity.
func (m *TenantAccountAssignmentMutation) ClearCreator() {
	m.clearedcreator = true
	m.clearedFields[tenantaccountassignment.FieldCreatedBy] = struct{}{}
}

// CreatorCleared reports if the "creator" edge to the Account entity was cleared.
func (m *TenantAccountAssignmentMutation) CreatorCleared() bool {
	return m.CreatedByCleared() || m.clearedcreator
}

// CreatorID returns the "creator" edge ID in the mutation.
func (m *TenantAccountAssignmentMutation) CreatorID() (id int64, exists bool) {
	if m.creator != nil {
		return *m.creator, true
	}
	return
}

// CreatorIDs returns the "creator" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreatorID instead. It exists only for internal usage by the builders.
func (m *TenantAccountAssignmentMutation) CreatorIDs() (ids []int64) {
	if id := m.creator; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreator resets all changes to the "creator" edge.
func (m *TenantAccountAssignmentMutation) ResetCreator() {
	m.creator = nil
	m.clearedcreator = false
}

// SetUpdaterID sets the "updater" edge to the Account entity by id.
func (m *TenantAccountAssignmentMutation) SetUpdaterID(id int64) {
	m.updater = &id
}

// ClearUpdater clears the "updater" edge to the Account entity.
func (m *TenantAccountAssignmentMutation) ClearUpdater() {
	m.clearedupdater = true
	m.clearedFields[tenantaccountassignment.FieldUpdatedBy] = struct{}{}
}

// UpdaterCleared reports if the "updater" edge to the Account entity was cleared.
func (m *TenantAccountAssignmentMutation) UpdaterCleared() bool {
	return m.UpdatedByCleared() || m.clearedupdater
}

// UpdaterID returns the "updater" edge ID in the mutation.
func (m *TenantAccountAssignmentMutation) UpdaterID() (id int64, exists bool) {
	if m.updater != nil {
		return *m.updater, true
	}
	return
}

// UpdaterIDs returns the "updater" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UpdaterID instead. It exists only for internal usage by the builders.
func (m *TenantAccountAssignmentMutation) UpdaterIDs() (ids []int64) {
	if id := m.updater; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUpdater resets all changes to the "updater" edge.
func (m *TenantAccountAssignmentMutation) ResetUpdater() {
	m.updater = nil
	m.clearedupdater = false
}

// ClearTenant clears the "tenant" edge to the Tenant entity.
func (m *TenantAccountAssignmentMutation) ClearTenant() {
	m.clearedtenant = true
	m.clearedFields[tenantaccountassignment.FieldTenantID] = struct{}{}
}

// TenantCleared reports if the "tenant" edge to the Tenant entity was cleared.
func (m *TenantAccountAssignmentMutation) TenantCleared() bool {
	return m.clearedtenant
}

// TenantIDs returns the "tenant" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TenantID instead. It exists only for internal usage by the builders.
func (m *TenantAccountAssignmentMutation) TenantIDs() (ids []int64) {
	if id := m.tenant; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTenant resets all changes to the "tenant" edge.
func (m *TenantAccountAssignmentMutation) ResetTenant() {
	m.tenant = nil
	m.clearedtenant = false
}

// ClearAccount clears the "account" edge to the Account entity.
func (m *TenantAccountAssignmentMutation) ClearAccount() {
	m.clearedaccount = true
	m.clearedFields[tenantaccountassignment.FieldAccountID] = struct{}{}
}

// AccountCleared reports if the "account" edge to the Account entity was cleared.
func (m *TenantAccountAssignmentMutation) AccountCleared() bool {
	return m.clearedaccount
}

// AccountIDs returns the "account" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// AccountID instead. It exists only for internal usage by the builders.
func (m *TenantAccountAssignmentMutation) AccountIDs() (ids []int64) {
	if id := m.account; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetAccount resets all changes to the "account" edge.
func (m *TenantAccountAssignmentMutation) ResetAccount() {
	m.account = nil
	m.clearedaccount = false
}

// Where appends a list predicates to the TenantAccountAssignmentMutation builder.
func (m *TenantAccountAssignmentMutation) Where(ps ...predicate.TenantAccountAssignment) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TenantAccountAssignmentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TenantAccountAssignmentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TenantAccountAssignment, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TenantAccountAssignmentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TenantAccountAssignmentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TenantAccountAssignment).
func (m *TenantAccountAssignmentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TenantAccountAssignmentMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.created_at != nil {
		fields = append(fields, tenantaccountassignment.FieldCreatedAt)
	}
	if m.creator != nil {
		fields = append(fields, tenantaccountassignment.FieldCreatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, tenantaccountassignment.FieldUpdatedAt)
	}
	if m.updater != nil {
		fields = append(fields, tenantaccountassignment.FieldUpdatedBy)
	}
	if m.tenant != nil {
		fields = append(fields, tenantaccountassignment.FieldTenantID)
	}
	if m.account != nil {
		fields = append(fields, tenantaccountassignment.FieldAccountID)
	}
	if m.is_contact_person != nil {
		fields = append(fields, tenantaccountassignment.FieldIsContactPerson)
	}
	if m.is_default != nil {
		fields = append(fields, tenantaccountassignment.FieldIsDefault)
	}
	if m.role != nil {
		fields = append(fields, tenantaccountassignment.FieldRole)
	}
	if m.expires_at != nil {
		fields = append(fields, tenantaccountassignment.FieldExpiresAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TenantAccountAssignmentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tenantaccountassignment.FieldCreatedAt:
		return m.CreatedAt()
	case tenantaccountassignment.FieldCreatedBy:
		return m.CreatedBy()
	case tenantaccountassignment.FieldUpdatedAt:
		return m.UpdatedAt()
	case tenantaccountassignment.FieldUpdatedBy:
		return m.UpdatedBy()
	case tenantaccountassignment.FieldTenantID:
		return m.TenantID()
	case tenantaccountassignment.FieldAccountID:
		return m.AccountID()
	case tenantaccountassignment.FieldIsContactPerson:
		return m.IsContactPerson()
	case tenantaccountassignment.FieldIsDefault:
		return m.IsDefault()
	case tenantaccountassignment.FieldRole:
		return m.Role()
	case tenantaccountassignment.FieldExpiresAt:
		return m.ExpiresAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TenantAccountAssignmentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tenantaccountassignment.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case tenantaccountassignment.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case tenantaccountassignment.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case tenantaccountassignment.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case tenantaccountassignment.FieldTenantID:
		return m.OldTenantID(ctx)
	case tenantaccountassignment.FieldAccountID:
		return m.OldAccountID(ctx)
	case tenantaccountassignment.FieldIsContactPerson:
		return m.OldIsContactPerson(ctx)
	case tenantaccountassignment.FieldIsDefault:
		return m.OldIsDefault(ctx)
	case tenantaccountassignment.FieldRole:
		return m.OldRole(ctx)
	case tenantaccountassignment.FieldExpiresAt:
		return m.OldExpiresAt(ctx)
	}
	return nil, fmt.Errorf("unknown TenantAccountAssignment field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TenantAccountAssignmentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tenantaccountassignment.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case tenantaccountassignment.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case tenantaccountassignment.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case tenantaccountassignment.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case tenantaccountassignment.FieldTenantID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTenantID(v)
		return nil
	case tenantaccountassignment.FieldAccountID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccountID(v)
		return nil
	case tenantaccountassignment.FieldIsContactPerson:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsContactPerson(v)
		return nil
	case tenantaccountassignment.FieldIsDefault:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDefault(v)
		return nil
	case tenantaccountassignment.FieldRole:
		v, ok := value.(tenantrole.TenantRole)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRole(v)
		return nil
	case tenantaccountassignment.FieldExpiresAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetExpiresAt(v)
		return nil
	}
	return fmt.Errorf("unknown TenantAccountAssignment field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TenantAccountAssignmentMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TenantAccountAssignmentMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TenantAccountAssignmentMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown TenantAccountAssignment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TenantAccountAssignmentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(tenantaccountassignment.FieldCreatedBy) {
		fields = append(fields, tenantaccountassignment.FieldCreatedBy)
	}
	if m.FieldCleared(tenantaccountassignment.FieldUpdatedBy) {
		fields = append(fields, tenantaccountassignment.FieldUpdatedBy)
	}
	if m.FieldCleared(tenantaccountassignment.FieldExpiresAt) {
		fields = append(fields, tenantaccountassignment.FieldExpiresAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TenantAccountAssignmentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TenantAccountAssignmentMutation) ClearField(name string) error {
	switch name {
	case tenantaccountassignment.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case tenantaccountassignment.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case tenantaccountassignment.FieldExpiresAt:
		m.ClearExpiresAt()
		return nil
	}
	return fmt.Errorf("unknown TenantAccountAssignment nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TenantAccountAssignmentMutation) ResetField(name string) error {
	switch name {
	case tenantaccountassignment.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case tenantaccountassignment.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case tenantaccountassignment.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case tenantaccountassignment.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case tenantaccountassignment.FieldTenantID:
		m.ResetTenantID()
		return nil
	case tenantaccountassignment.FieldAccountID:
		m.ResetAccountID()
		return nil
	case tenantaccountassignment.FieldIsContactPerson:
		m.ResetIsContactPerson()
		return nil
	case tenantaccountassignment.FieldIsDefault:
		m.ResetIsDefault()
		return nil
	case tenantaccountassignment.FieldRole:
		m.ResetRole()
		return nil
	case tenantaccountassignment.FieldExpiresAt:
		m.ResetExpiresAt()
		return nil
	}
	return fmt.Errorf("unknown TenantAccountAssignment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TenantAccountAssignmentMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.creator != nil {
		edges = append(edges, tenantaccountassignment.EdgeCreator)
	}
	if m.updater != nil {
		edges = append(edges, tenantaccountassignment.EdgeUpdater)
	}
	if m.tenant != nil {
		edges = append(edges, tenantaccountassignment.EdgeTenant)
	}
	if m.account != nil {
		edges = append(edges, tenantaccountassignment.EdgeAccount)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TenantAccountAssignmentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case tenantaccountassignment.EdgeCreator:
		if id := m.creator; id != nil {
			return []ent.Value{*id}
		}
	case tenantaccountassignment.EdgeUpdater:
		if id := m.updater; id != nil {
			return []ent.Value{*id}
		}
	case tenantaccountassignment.EdgeTenant:
		if id := m.tenant; id != nil {
			return []ent.Value{*id}
		}
	case tenantaccountassignment.EdgeAccount:
		if id := m.account; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TenantAccountAssignmentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TenantAccountAssignmentMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TenantAccountAssignmentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedcreator {
		edges = append(edges, tenantaccountassignment.EdgeCreator)
	}
	if m.clearedupdater {
		edges = append(edges, tenantaccountassignment.EdgeUpdater)
	}
	if m.clearedtenant {
		edges = append(edges, tenantaccountassignment.EdgeTenant)
	}
	if m.clearedaccount {
		edges = append(edges, tenantaccountassignment.EdgeAccount)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TenantAccountAssignmentMutation) EdgeCleared(name string) bool {
	switch name {
	case tenantaccountassignment.EdgeCreator:
		return m.clearedcreator
	case tenantaccountassignment.EdgeUpdater:
		return m.clearedupdater
	case tenantaccountassignment.EdgeTenant:
		return m.clearedtenant
	case tenantaccountassignment.EdgeAccount:
		return m.clearedaccount
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TenantAccountAssignmentMutation) ClearEdge(name string) error {
	switch name {
	case tenantaccountassignment.EdgeCreator:
		m.ClearCreator()
		return nil
	case tenantaccountassignment.EdgeUpdater:
		m.ClearUpdater()
		return nil
	case tenantaccountassignment.EdgeTenant:
		m.ClearTenant()
		return nil
	case tenantaccountassignment.EdgeAccount:
		m.ClearAccount()
		return nil
	}
	return fmt.Errorf("unknown TenantAccountAssignment unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TenantAccountAssignmentMutation) ResetEdge(name string) error {
	switch name {
	case tenantaccountassignment.EdgeCreator:
		m.ResetCreator()
		return nil
	case tenantaccountassignment.EdgeUpdater:
		m.ResetUpdater()
		return nil
	case tenantaccountassignment.EdgeTenant:
		m.ResetTenant()
		return nil
	case tenantaccountassignment.EdgeAccount:
		m.ResetAccount()
		return nil
	}
	return fmt.Errorf("unknown TenantAccountAssignment edge %s", name)
}
