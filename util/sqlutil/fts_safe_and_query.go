package sqlutil

import (
	"regexp"
	"strings"
	"unicode/utf8"

	"golang.org/x/text/unicode/norm"
)

var reWS = regexp.MustCompile(`\s+`)
var reCtrl = regexp.MustCompile(`[\x00-\x1F\x7F]`)

// FTSSafeAndQuery builds a safe FTS5 MATCH string where each token is ANDed.
// Supports a single trailing '*' (prefix) per token, e.g. "comp*" -> "comp"*.
//
// Old: ~~Returns `""` if nothing usable remains (which will match nothing).~~
// New: returns empty string instead, because that is easier to check for in Go code
//
// initial code was generated by ChatGPT:
// https://chatgpt.com/c/6899dc5e-d260-8324-9f73-1518408ebbf8
func FTSSafeAndQuery(input string, maxLen int) string {
	if input == "" {
		return ""
	}

	if maxLen <= 0 {
		maxLen = 300
	}

	// Normalize & clean
	s := norm.NFKC.String(input)
	s = reCtrl.ReplaceAllString(s, "")
	s = strings.TrimSpace(s)
	s = truncateRunes(s, maxLen)
	if s == "" {
		return `""`
	}

	raw := reWS.Split(s, -1)

	out := make([]string, 0, len(raw))
	for _, tok := range raw {
		if tok == "" {
			continue
		}

		// Allow exactly one trailing '*' for prefix; reject '*' elsewhere.
		hasStar := strings.HasSuffix(tok, "*")
		if strings.Contains(tok[:len(tok)-boolToInt(hasStar)], "*") {
			// '*' found not at the end -> skip this token
			continue
		}
		if hasStar {
			tok = tok[:len(tok)-1]
		}
		if tok == "" {
			continue
		}

		// Escape any embedded quotes in the term and wrap in quotes to force literal
		term := `"` + strings.ReplaceAll(tok, `"`, `""`) + `"`
		if hasStar {
			term += "*"
		}

		out = append(out, term)

		// Optional safety: cap number of tokens to avoid huge queries
		if len(out) >= 50 {
			break
		}
	}

	if len(out) == 0 {
		return `""`
	}
	// Spaces in MATCH are ANDs in FTS
	return strings.Join(out, " ")
}

// truncateRunes trims to at most max runes (not bytes).
func truncateRunes(s string, max int) string {
	if utf8.RuneCountInString(s) <= max {
		return s
	}
	var b strings.Builder
	b.Grow(len(s))
	count := 0
	for _, r := range s {
		if count >= max {
			break
		}
		b.WriteRune(r)
		count++
	}
	return b.String()
}

func boolToInt(b bool) int {
	if b {
		return 1
	}
	return 0
}
