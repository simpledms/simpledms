{
  "version": 3,
  "sources": ["../../../../../../node_modules/@uppy/core/lib/EventManager.js", "../../../../../../node_modules/@uppy/utils/lib/NetworkError.js", "../../../../../../node_modules/@uppy/utils/lib/ProgressTimeout.js", "../../../../../../node_modules/@uppy/utils/lib/fetcher.js", "../../../../../../node_modules/@uppy/utils/lib/fileFilters.js", "../../../../../../node_modules/@uppy/utils/lib/getAllowedMetaFields.js", "../../../../../../node_modules/@uppy/utils/lib/isNetworkError.js", "../../../../../../node_modules/@uppy/utils/lib/RateLimitedQueue.js", "../../../../../../node_modules/@uppy/xhr-upload/package.json", "../../../../../../node_modules/@uppy/xhr-upload/lib/locale.js", "../../../../../../node_modules/@uppy/xhr-upload/lib/index.js"],
  "sourcesContent": ["/**\n * Create a wrapper around an event emitter with a `remove` method to remove\n * all events that were added using the wrapped emitter.\n */\nexport default class EventManager {\n    #uppy;\n    #events = [];\n    constructor(uppy) {\n        this.#uppy = uppy;\n    }\n    on(event, fn) {\n        this.#events.push([event, fn]);\n        return this.#uppy.on(event, fn);\n    }\n    remove() {\n        for (const [event, fn] of this.#events.splice(0)) {\n            this.#uppy.off(event, fn);\n        }\n    }\n    onFilePause(fileID, cb) {\n        this.on('upload-pause', (file, isPaused) => {\n            if (fileID === file?.id) {\n                cb(isPaused);\n            }\n        });\n    }\n    onFileRemove(fileID, cb) {\n        this.on('file-removed', (file) => {\n            if (fileID === file.id)\n                cb(file.id);\n        });\n    }\n    onPause(fileID, cb) {\n        this.on('upload-pause', (file, isPaused) => {\n            if (fileID === file?.id) {\n                // const isPaused = this.#uppy.pauseResume(fileID)\n                cb(isPaused);\n            }\n        });\n    }\n    onRetry(fileID, cb) {\n        this.on('upload-retry', (file) => {\n            if (fileID === file?.id) {\n                cb();\n            }\n        });\n    }\n    onRetryAll(fileID, cb) {\n        this.on('retry-all', () => {\n            if (!this.#uppy.getFile(fileID))\n                return;\n            cb();\n        });\n    }\n    onPauseAll(fileID, cb) {\n        this.on('pause-all', () => {\n            if (!this.#uppy.getFile(fileID))\n                return;\n            cb();\n        });\n    }\n    onCancelAll(fileID, eventHandler) {\n        this.on('cancel-all', (...args) => {\n            if (!this.#uppy.getFile(fileID))\n                return;\n            eventHandler(...args);\n        });\n    }\n    onResumeAll(fileID, cb) {\n        this.on('resume-all', () => {\n            if (!this.#uppy.getFile(fileID))\n                return;\n            cb();\n        });\n    }\n}\n", "class NetworkError extends Error {\n    cause;\n    isNetworkError;\n    request;\n    constructor(error, xhr = null) {\n        super(`This looks like a network error, the endpoint might be blocked by an internet provider or a firewall.`);\n        this.cause = error;\n        this.isNetworkError = true;\n        this.request = xhr;\n    }\n}\nexport default NetworkError;\n", "/**\n * Helper to abort upload requests if there has not been any progress for `timeout` ms.\n * Create an instance using `timer = new ProgressTimeout(10000, onTimeout)`\n * Call `timer.progress()` to signal that there has been progress of any kind.\n * Call `timer.done()` when the upload has completed.\n */\nclass ProgressTimeout {\n    #aliveTimer;\n    #isDone = false;\n    #onTimedOut;\n    #timeout;\n    constructor(timeout, timeoutHandler) {\n        this.#timeout = timeout;\n        this.#onTimedOut = () => timeoutHandler(timeout);\n    }\n    progress() {\n        // Some browsers fire another progress event when the upload is\n        // cancelled, so we have to ignore progress after the timer was\n        // told to stop.\n        if (this.#isDone)\n            return;\n        if (this.#timeout > 0) {\n            clearTimeout(this.#aliveTimer);\n            this.#aliveTimer = setTimeout(this.#onTimedOut, this.#timeout);\n        }\n    }\n    done() {\n        if (!this.#isDone) {\n            clearTimeout(this.#aliveTimer);\n            this.#aliveTimer = undefined;\n            this.#isDone = true;\n        }\n    }\n}\nexport default ProgressTimeout;\n", "import NetworkError from './NetworkError.js';\nimport ProgressTimeout from './ProgressTimeout.js';\nconst noop = () => { };\n/**\n * Fetches data from a specified URL using XMLHttpRequest, with optional retry functionality and progress tracking.\n *\n * @param url The URL to send the request to.\n * @param options Optional settings for the fetch operation.\n */\nexport function fetcher(url, options = {}) {\n    const { body = null, headers = {}, method = 'GET', onBeforeRequest = noop, onUploadProgress = noop, shouldRetry = () => true, onAfterResponse = noop, onTimeout = noop, responseType, retries = 3, signal = null, timeout = 30_000, withCredentials = false, } = options;\n    // 300 ms, 600 ms, 1200 ms, 2400 ms, 4800 ms\n    const delay = (attempt) => 0.3 * 2 ** (attempt - 1) * 1000;\n    const timer = new ProgressTimeout(timeout, onTimeout);\n    function requestWithRetry(retryCount = 0) {\n        // biome-ignore lint/suspicious/noAsyncPromiseExecutor: it's fine\n        return new Promise(async (resolve, reject) => {\n            const xhr = new XMLHttpRequest();\n            const onError = (error) => {\n                if (shouldRetry(xhr) && retryCount < retries) {\n                    setTimeout(() => {\n                        requestWithRetry(retryCount + 1).then(resolve, reject);\n                    }, delay(retryCount));\n                }\n                else {\n                    timer.done();\n                    reject(error);\n                }\n            };\n            xhr.open(method, url, true);\n            xhr.withCredentials = withCredentials;\n            if (responseType) {\n                xhr.responseType = responseType;\n            }\n            signal?.addEventListener('abort', () => {\n                xhr.abort();\n                // Using DOMException for abort errors aligns with\n                // the convention established by the Fetch API.\n                reject(new DOMException('Aborted', 'AbortError'));\n            });\n            xhr.onload = async () => {\n                try {\n                    await onAfterResponse(xhr, retryCount);\n                }\n                catch (err) {\n                    // This is important as we need to emit the xhr\n                    // over the upload-error event.\n                    err.request = xhr;\n                    onError(err);\n                    return;\n                }\n                if (xhr.status >= 200 && xhr.status < 300) {\n                    timer.done();\n                    resolve(xhr);\n                }\n                else if (shouldRetry(xhr) && retryCount < retries) {\n                    setTimeout(() => {\n                        requestWithRetry(retryCount + 1).then(resolve, reject);\n                    }, delay(retryCount));\n                }\n                else {\n                    timer.done();\n                    reject(new NetworkError(xhr.statusText, xhr));\n                }\n            };\n            xhr.onerror = () => onError(new NetworkError(xhr.statusText, xhr));\n            xhr.upload.onprogress = (event) => {\n                timer.progress();\n                onUploadProgress(event);\n            };\n            if (headers) {\n                Object.keys(headers).forEach((key) => {\n                    xhr.setRequestHeader(key, headers[key]);\n                });\n            }\n            await onBeforeRequest(xhr, retryCount);\n            xhr.send(body);\n        });\n    }\n    return requestWithRetry();\n}\n", "export function filterNonFailedFiles(files) {\n    const hasError = (file) => 'error' in file && !!file.error;\n    return files.filter((file) => !hasError(file));\n}\n// Don't double-emit upload-started for Golden Retriever-restored files that were already started\nexport function filterFilesToEmitUploadStarted(files) {\n    return files.filter((file) => !file.progress?.uploadStarted || !file.isRestored);\n}\n", "export default function getAllowedMetaFields(fields, meta) {\n    if (fields === true) {\n        return Object.keys(meta);\n    }\n    if (Array.isArray(fields)) {\n        return fields;\n    }\n    return [];\n}\n", "function isNetworkError(xhr) {\n    if (!xhr) {\n        return false;\n    }\n    return (xhr.readyState !== 0 && xhr.readyState !== 4) || xhr.status === 0;\n}\nexport default isNetworkError;\n", "function createCancelError(cause) {\n    return new Error('Cancelled', { cause });\n}\nfunction abortOn(signal) {\n    if (signal != null) {\n        const abortPromise = () => this.abort(signal.reason);\n        signal.addEventListener('abort', abortPromise, { once: true });\n        const removeAbortListener = () => {\n            signal.removeEventListener('abort', abortPromise);\n        };\n        this.then?.(removeAbortListener, removeAbortListener);\n    }\n    return this;\n}\nexport class RateLimitedQueue {\n    #activeRequests = 0;\n    #queuedHandlers = [];\n    #paused = false;\n    #pauseTimer;\n    #downLimit = 1;\n    #upperLimit;\n    #rateLimitingTimer;\n    limit;\n    constructor(limit) {\n        if (typeof limit !== 'number' || limit === 0) {\n            this.limit = Infinity;\n        }\n        else {\n            this.limit = limit;\n        }\n    }\n    #call(fn) {\n        this.#activeRequests += 1;\n        let done = false;\n        let cancelActive;\n        try {\n            cancelActive = fn();\n        }\n        catch (err) {\n            this.#activeRequests -= 1;\n            throw err;\n        }\n        return {\n            abort: (cause) => {\n                if (done)\n                    return;\n                done = true;\n                this.#activeRequests -= 1;\n                cancelActive?.(cause);\n                this.#queueNext();\n            },\n            done: () => {\n                if (done)\n                    return;\n                done = true;\n                this.#activeRequests -= 1;\n                this.#queueNext();\n            },\n        };\n    }\n    #queueNext() {\n        // Do it soon but not immediately, this allows clearing out the entire queue synchronously\n        // one by one without continuously _advancing_ it (and starting new tasks before immediately\n        // aborting them)\n        queueMicrotask(() => this.#next());\n    }\n    #next() {\n        if (this.#paused || this.#activeRequests >= this.limit) {\n            return;\n        }\n        if (this.#queuedHandlers.length === 0) {\n            return;\n        }\n        // Dispatch the next request, and update the abort/done handlers\n        // so that cancelling it does the Right Thing (and doesn't just try\n        // to dequeue an already-running request).\n        const next = this.#queuedHandlers.shift();\n        if (next == null) {\n            throw new Error('Invariant violation: next is null');\n        }\n        const handler = this.#call(next.fn);\n        next.abort = handler.abort;\n        next.done = handler.done;\n    }\n    #queue(fn, options) {\n        const handler = {\n            fn,\n            priority: options?.priority || 0,\n            abort: () => {\n                this.#dequeue(handler);\n            },\n            done: () => {\n                throw new Error('Cannot mark a queued request as done: this indicates a bug');\n            },\n        };\n        const index = this.#queuedHandlers.findIndex((other) => {\n            return handler.priority > other.priority;\n        });\n        if (index === -1) {\n            this.#queuedHandlers.push(handler);\n        }\n        else {\n            this.#queuedHandlers.splice(index, 0, handler);\n        }\n        return handler;\n    }\n    #dequeue(handler) {\n        const index = this.#queuedHandlers.indexOf(handler);\n        if (index !== -1) {\n            this.#queuedHandlers.splice(index, 1);\n        }\n    }\n    run(fn, queueOptions) {\n        if (!this.#paused && this.#activeRequests < this.limit) {\n            return this.#call(fn);\n        }\n        return this.#queue(fn, queueOptions);\n    }\n    wrapSyncFunction(fn, queueOptions) {\n        return (...args) => {\n            const queuedRequest = this.run(() => {\n                fn(...args);\n                queueMicrotask(() => queuedRequest.done());\n                return () => { };\n            }, queueOptions);\n            return {\n                abortOn,\n                abort() {\n                    queuedRequest.abort();\n                },\n            };\n        };\n    }\n    wrapPromiseFunction(fn, queueOptions) {\n        return (...args) => {\n            let queuedRequest;\n            const outerPromise = new Promise((resolve, reject) => {\n                queuedRequest = this.run(() => {\n                    let cancelError;\n                    let innerPromise;\n                    try {\n                        innerPromise = Promise.resolve(fn(...args));\n                    }\n                    catch (err) {\n                        innerPromise = Promise.reject(err);\n                    }\n                    innerPromise.then((result) => {\n                        if (cancelError) {\n                            reject(cancelError);\n                        }\n                        else {\n                            queuedRequest.done();\n                            resolve(result);\n                        }\n                    }, (err) => {\n                        if (cancelError) {\n                            reject(cancelError);\n                        }\n                        else {\n                            queuedRequest.done();\n                            reject(err);\n                        }\n                    });\n                    return (cause) => {\n                        cancelError = createCancelError(cause);\n                    };\n                }, queueOptions);\n            });\n            outerPromise.abort = (cause) => {\n                queuedRequest.abort(cause);\n            };\n            outerPromise.abortOn = abortOn;\n            return outerPromise;\n        };\n    }\n    resume() {\n        this.#paused = false;\n        clearTimeout(this.#pauseTimer);\n        for (let i = 0; i < this.limit; i++) {\n            this.#queueNext();\n        }\n    }\n    #resume = () => this.resume();\n    /**\n     * Freezes the queue for a while or indefinitely.\n     *\n     * @param {number | null } [duration] Duration for the pause to happen, in milliseconds.\n     *                                    If omitted, the queue won't resume automatically.\n     */\n    pause(duration = null) {\n        this.#paused = true;\n        clearTimeout(this.#pauseTimer);\n        if (duration != null) {\n            this.#pauseTimer = setTimeout(this.#resume, duration);\n        }\n    }\n    /**\n     * Pauses the queue for a duration, and lower the limit of concurrent requests\n     * when the queue resumes. When the queue resumes, it tries to progressively\n     * increase the limit in `this.#increaseLimit` until another call is made to\n     * `this.rateLimit`.\n     * Call this function when using the RateLimitedQueue for network requests and\n     * the remote server responds with 429 HTTP code.\n     *\n     * @param {number} duration in milliseconds.\n     */\n    rateLimit(duration) {\n        clearTimeout(this.#rateLimitingTimer);\n        this.pause(duration);\n        if (this.limit > 1 && Number.isFinite(this.limit)) {\n            this.#upperLimit = this.limit - 1;\n            this.limit = this.#downLimit;\n            this.#rateLimitingTimer = setTimeout(this.#increaseLimit, duration);\n        }\n    }\n    #increaseLimit = () => {\n        if (this.#paused) {\n            this.#rateLimitingTimer = setTimeout(this.#increaseLimit, 0);\n            return;\n        }\n        this.#downLimit = this.limit;\n        this.limit = Math.ceil((this.#upperLimit + this.#downLimit) / 2);\n        for (let i = this.#downLimit; i <= this.limit; i++) {\n            this.#queueNext();\n        }\n        if (this.#upperLimit - this.#downLimit > 3) {\n            this.#rateLimitingTimer = setTimeout(this.#increaseLimit, 2000);\n        }\n        else {\n            this.#downLimit = Math.floor(this.#downLimit / 2);\n        }\n    };\n    get isPaused() {\n        return this.#paused;\n    }\n}\nexport const internalRateLimitedQueue = Symbol('__queue');\n", "{\n  \"name\": \"@uppy/xhr-upload\",\n  \"description\": \"Plain and simple classic HTML multipart form uploads with Uppy, as well as uploads using the HTTP PUT method.\",\n  \"version\": \"4.4.2\",\n  \"license\": \"MIT\",\n  \"main\": \"lib/index.js\",\n  \"type\": \"module\",\n  \"scripts\": {\n    \"build\": \"tsc --build tsconfig.build.json\",\n    \"typecheck\": \"tsc --build\",\n    \"test\": \"vitest run --environment=jsdom --silent='passed-only'\"\n  },\n  \"keywords\": [\n    \"file uploader\",\n    \"xhr\",\n    \"xhr upload\",\n    \"XMLHttpRequest\",\n    \"ajax\",\n    \"fetch\",\n    \"uppy\",\n    \"uppy-plugin\"\n  ],\n  \"homepage\": \"https://uppy.io\",\n  \"bugs\": {\n    \"url\": \"https://github.com/transloadit/uppy/issues\"\n  },\n  \"repository\": {\n    \"type\": \"git\",\n    \"url\": \"git+https://github.com/transloadit/uppy.git\"\n  },\n  \"files\": [\n    \"src\",\n    \"lib\",\n    \"dist\",\n    \"CHANGELOG.md\"\n  ],\n  \"dependencies\": {\n    \"@uppy/companion-client\": \"^4.5.2\",\n    \"@uppy/utils\": \"^6.2.2\"\n  },\n  \"devDependencies\": {\n    \"@uppy/core\": \"^4.5.2\",\n    \"jsdom\": \"^26.1.0\",\n    \"nock\": \"^13.1.0\",\n    \"typescript\": \"^5.8.3\",\n    \"vitest\": \"^3.2.4\"\n  },\n  \"peerDependencies\": {\n    \"@uppy/core\": \"^4.5.2\"\n  }\n}", "export default {\n    strings: {\n        // Shown in the Informer if an upload is being canceled because it stalled for too long.\n        uploadStalled: 'Upload has not made any progress for %{seconds} seconds. You may want to retry it.',\n    },\n};\n", "import { BasePlugin } from '@uppy/core';\nimport EventManager from '@uppy/core/lib/EventManager.js';\nimport { fetcher } from '@uppy/utils/lib/fetcher';\nimport { filterFilesToEmitUploadStarted, filterNonFailedFiles, } from '@uppy/utils/lib/fileFilters';\nimport getAllowedMetaFields from '@uppy/utils/lib/getAllowedMetaFields';\nimport isNetworkError from '@uppy/utils/lib/isNetworkError';\nimport NetworkError from '@uppy/utils/lib/NetworkError';\nimport { internalRateLimitedQueue, RateLimitedQueue,\n// @ts-ignore untyped\n } from '@uppy/utils/lib/RateLimitedQueue';\nimport packageJson from '../package.json' with { type: 'json' };\nimport locale from './locale.js';\nfunction buildResponseError(xhr, err) {\n    let error = err;\n    // No error message\n    if (!error)\n        error = new Error('Upload error');\n    // Got an error message string\n    if (typeof error === 'string')\n        error = new Error(error);\n    // Got something else\n    if (!(error instanceof Error)) {\n        error = Object.assign(new Error('Upload error'), { data: error });\n    }\n    if (isNetworkError(xhr)) {\n        error = new NetworkError(error, xhr);\n        return error;\n    }\n    // @ts-expect-error request can only be set on NetworkError\n    // but we use NetworkError to distinguish between errors.\n    error.request = xhr;\n    return error;\n}\n/**\n * Set `data.type` in the blob to `file.meta.type`,\n * because we might have detected a more accurate file type in Uppy\n * https://stackoverflow.com/a/50875615\n */\nfunction setTypeInBlob(file) {\n    const dataWithUpdatedType = file.data.slice(0, file.data.size, file.meta.type);\n    return dataWithUpdatedType;\n}\nconst defaultOptions = {\n    formData: true,\n    fieldName: 'file',\n    method: 'post',\n    allowedMetaFields: true,\n    bundle: false,\n    headers: {},\n    timeout: 30 * 1000,\n    limit: 5,\n    withCredentials: false,\n    responseType: '',\n};\nexport default class XHRUpload extends BasePlugin {\n    static VERSION = packageJson.version;\n    #getFetcher;\n    requests;\n    uploaderEvents;\n    constructor(uppy, opts) {\n        super(uppy, {\n            ...defaultOptions,\n            fieldName: opts.bundle ? 'files[]' : 'file',\n            ...opts,\n        });\n        this.type = 'uploader';\n        this.id = this.opts.id || 'XHRUpload';\n        this.defaultLocale = locale;\n        this.i18nInit();\n        // Simultaneous upload limiting is shared across all uploads with this plugin.\n        if (internalRateLimitedQueue in this.opts) {\n            // @ts-ignore untyped internal\n            this.requests = this.opts[internalRateLimitedQueue];\n        }\n        else {\n            this.requests = new RateLimitedQueue(this.opts.limit);\n        }\n        if (this.opts.bundle && !this.opts.formData) {\n            throw new Error('`opts.formData` must be true when `opts.bundle` is enabled.');\n        }\n        if (this.opts.bundle && typeof this.opts.headers === 'function') {\n            throw new Error('`opts.headers` can not be a function when the `bundle: true` option is set.');\n        }\n        if (opts?.allowedMetaFields === undefined && 'metaFields' in this.opts) {\n            throw new Error('The `metaFields` option has been renamed to `allowedMetaFields`.');\n        }\n        this.uploaderEvents = Object.create(null);\n        /**\n         * xhr-upload wrapper for `fetcher` to handle user options\n         * `validateStatus`, `getResponseError`, `getResponseData`\n         * and to emit `upload-progress`, `upload-error`, and `upload-success` events.\n         */\n        this.#getFetcher = (files) => {\n            return async (url, options) => {\n                try {\n                    const res = await fetcher(url, {\n                        ...options,\n                        onBeforeRequest: (xhr, retryCount) => this.opts.onBeforeRequest?.(xhr, retryCount, files),\n                        shouldRetry: this.opts.shouldRetry,\n                        onAfterResponse: this.opts.onAfterResponse,\n                        onTimeout: (timeout) => {\n                            const seconds = Math.ceil(timeout / 1000);\n                            const error = new Error(this.i18n('uploadStalled', { seconds }));\n                            this.uppy.emit('upload-stalled', error, files);\n                        },\n                        onUploadProgress: (event) => {\n                            if (event.lengthComputable) {\n                                for (const { id } of files) {\n                                    const file = this.uppy.getFile(id);\n                                    this.uppy.emit('upload-progress', file, {\n                                        uploadStarted: file.progress.uploadStarted ?? 0,\n                                        bytesUploaded: (event.loaded / event.total) * file.size,\n                                        bytesTotal: file.size,\n                                    });\n                                }\n                            }\n                        },\n                    });\n                    let body = await this.opts.getResponseData?.(res);\n                    if (res.responseType === 'json') {\n                        body ??= res.response;\n                    }\n                    else {\n                        try {\n                            body ??= JSON.parse(res.responseText);\n                        }\n                        catch (cause) {\n                            throw new Error('@uppy/xhr-upload expects a JSON response (with a `url` property). To parse non-JSON responses, use `getResponseData` to turn your response into JSON.', { cause });\n                        }\n                    }\n                    const uploadURL = typeof body?.url === 'string' ? body.url : undefined;\n                    for (const { id } of files) {\n                        this.uppy.emit('upload-success', this.uppy.getFile(id), {\n                            status: res.status,\n                            body,\n                            uploadURL,\n                        });\n                    }\n                    return res;\n                }\n                catch (error) {\n                    if (error.name === 'AbortError') {\n                        return undefined;\n                    }\n                    const request = error.request;\n                    for (const file of files) {\n                        this.uppy.emit('upload-error', this.uppy.getFile(file.id), buildResponseError(request, error), request);\n                    }\n                    throw error;\n                }\n            };\n        };\n    }\n    getOptions(file) {\n        const overrides = this.uppy.getState().xhrUpload;\n        const { headers } = this.opts;\n        const opts = {\n            ...this.opts,\n            ...(overrides || {}),\n            ...(file.xhrUpload || {}),\n            headers: {},\n        };\n        // Support for `headers` as a function, only in the XHRUpload settings.\n        // Options set by other plugins in Uppy state or on the files themselves are still merged in afterward.\n        //\n        // ```js\n        // headers: (file) => ({ expires: file.meta.expires })\n        // ```\n        if (typeof headers === 'function') {\n            opts.headers = headers(file);\n        }\n        else {\n            Object.assign(opts.headers, this.opts.headers);\n        }\n        if (overrides) {\n            Object.assign(opts.headers, overrides.headers);\n        }\n        if (file.xhrUpload) {\n            Object.assign(opts.headers, file.xhrUpload.headers);\n        }\n        return opts;\n    }\n    addMetadata(formData, meta, opts) {\n        const allowedMetaFields = getAllowedMetaFields(opts.allowedMetaFields, meta);\n        allowedMetaFields.forEach((item) => {\n            const value = meta[item];\n            if (Array.isArray(value)) {\n                // In this case we don't transform `item` to add brackets, it's up to\n                // the user to add the brackets so it won't be overridden.\n                value.forEach((subItem) => formData.append(item, subItem));\n            }\n            else {\n                formData.append(item, value);\n            }\n        });\n    }\n    createFormDataUpload(file, opts) {\n        const formPost = new FormData();\n        this.addMetadata(formPost, file.meta, opts);\n        const dataWithUpdatedType = setTypeInBlob(file);\n        if (file.name) {\n            formPost.append(opts.fieldName, dataWithUpdatedType, file.meta.name);\n        }\n        else {\n            formPost.append(opts.fieldName, dataWithUpdatedType);\n        }\n        return formPost;\n    }\n    createBundledUpload(files, opts) {\n        const formPost = new FormData();\n        const { meta } = this.uppy.getState();\n        this.addMetadata(formPost, meta, opts);\n        files.forEach((file) => {\n            const options = this.getOptions(file);\n            const dataWithUpdatedType = setTypeInBlob(file);\n            if (file.name) {\n                formPost.append(options.fieldName, dataWithUpdatedType, file.name);\n            }\n            else {\n                formPost.append(options.fieldName, dataWithUpdatedType);\n            }\n        });\n        return formPost;\n    }\n    async #uploadLocalFile(file) {\n        const events = new EventManager(this.uppy);\n        const controller = new AbortController();\n        const uppyFetch = this.requests.wrapPromiseFunction(async () => {\n            const opts = this.getOptions(file);\n            const fetch = this.#getFetcher([file]);\n            const body = opts.formData\n                ? this.createFormDataUpload(file, opts)\n                : file.data;\n            const endpoint = typeof opts.endpoint === 'string'\n                ? opts.endpoint\n                : await opts.endpoint(file);\n            return fetch(endpoint, {\n                ...opts,\n                body,\n                signal: controller.signal,\n            });\n        });\n        events.onFileRemove(file.id, () => controller.abort());\n        events.onCancelAll(file.id, () => {\n            controller.abort();\n        });\n        try {\n            await uppyFetch().abortOn(controller.signal);\n        }\n        catch (error) {\n            // TODO: create formal error with name 'AbortError' (this comes from RateLimitedQueue)\n            if (error.message !== 'Cancelled') {\n                throw error;\n            }\n        }\n        finally {\n            events.remove();\n        }\n    }\n    async #uploadBundle(files) {\n        const controller = new AbortController();\n        const uppyFetch = this.requests.wrapPromiseFunction(async () => {\n            const optsFromState = this.uppy.getState().xhrUpload ?? {};\n            const fetch = this.#getFetcher(files);\n            const body = this.createBundledUpload(files, {\n                ...this.opts,\n                ...optsFromState,\n            });\n            const endpoint = typeof this.opts.endpoint === 'string'\n                ? this.opts.endpoint\n                : await this.opts.endpoint(files);\n            return fetch(endpoint, {\n                // headers can't be a function with bundle: true\n                ...this.opts,\n                body,\n                signal: controller.signal,\n            });\n        });\n        function abort() {\n            controller.abort();\n        }\n        // We only need to abort on cancel all because\n        // individual cancellations are not possible with bundle: true\n        this.uppy.once('cancel-all', abort);\n        try {\n            await uppyFetch().abortOn(controller.signal);\n        }\n        catch (error) {\n            // TODO: create formal error with name 'AbortError' (this comes from RateLimitedQueue)\n            if (error.message !== 'Cancelled') {\n                throw error;\n            }\n        }\n        finally {\n            this.uppy.off('cancel-all', abort);\n        }\n    }\n    #getCompanionClientArgs(file) {\n        const opts = this.getOptions(file);\n        const allowedMetaFields = getAllowedMetaFields(opts.allowedMetaFields, file.meta);\n        return {\n            ...file.remote?.body,\n            protocol: 'multipart',\n            endpoint: opts.endpoint,\n            size: file.data.size,\n            fieldname: opts.fieldName,\n            metadata: Object.fromEntries(allowedMetaFields.map((name) => [name, file.meta[name]])),\n            httpMethod: opts.method,\n            useFormData: opts.formData,\n            headers: opts.headers,\n        };\n    }\n    async #uploadFiles(files) {\n        await Promise.allSettled(files.map((file) => {\n            if (file.isRemote) {\n                const getQueue = () => this.requests;\n                const controller = new AbortController();\n                const removedHandler = (removedFile) => {\n                    if (removedFile.id === file.id)\n                        controller.abort();\n                };\n                this.uppy.on('file-removed', removedHandler);\n                const uploadPromise = this.uppy\n                    .getRequestClientForFile(file)\n                    .uploadRemoteFile(file, this.#getCompanionClientArgs(file), {\n                    signal: controller.signal,\n                    getQueue,\n                });\n                this.requests.wrapSyncFunction(() => {\n                    this.uppy.off('file-removed', removedHandler);\n                }, { priority: -1 })();\n                return uploadPromise;\n            }\n            return this.#uploadLocalFile(file);\n        }));\n    }\n    #handleUpload = async (fileIDs) => {\n        if (fileIDs.length === 0) {\n            this.uppy.log('[XHRUpload] No files to upload!');\n            return;\n        }\n        // No limit configured by the user, and no RateLimitedQueue passed in by a \"parent\" plugin\n        // (basically just AwsS3) using the internal symbol\n        // @ts-ignore untyped internal\n        if (this.opts.limit === 0 && !this.opts[internalRateLimitedQueue]) {\n            this.uppy.log('[XHRUpload] When uploading multiple files at once, consider setting the `limit` option (to `10` for example), to limit the number of concurrent uploads, which helps prevent memory and network issues: https://uppy.io/docs/xhr-upload/#limit-0', 'warning');\n        }\n        this.uppy.log('[XHRUpload] Uploading...');\n        const files = this.uppy.getFilesByIds(fileIDs);\n        const filesFiltered = filterNonFailedFiles(files);\n        const filesToEmit = filterFilesToEmitUploadStarted(filesFiltered);\n        this.uppy.emit('upload-start', filesToEmit);\n        if (this.opts.bundle) {\n            // if bundle: true, we don\u2019t support remote uploads\n            const isSomeFileRemote = filesFiltered.some((file) => file.isRemote);\n            if (isSomeFileRemote) {\n                throw new Error('Can\u2019t upload remote files when the `bundle: true` option is set');\n            }\n            if (typeof this.opts.headers === 'function') {\n                throw new TypeError('`headers` may not be a function when the `bundle: true` option is set');\n            }\n            await this.#uploadBundle(filesFiltered);\n        }\n        else {\n            await this.#uploadFiles(filesFiltered);\n        }\n    };\n    install() {\n        if (this.opts.bundle) {\n            const { capabilities } = this.uppy.getState();\n            this.uppy.setState({\n                capabilities: {\n                    ...capabilities,\n                    individualCancellation: false,\n                },\n            });\n        }\n        this.uppy.addUploader(this.#handleUpload);\n    }\n    uninstall() {\n        if (this.opts.bundle) {\n            const { capabilities } = this.uppy.getState();\n            this.uppy.setState({\n                capabilities: {\n                    ...capabilities,\n                    individualCancellation: true,\n                },\n            });\n        }\n        this.uppy.removeUploader(this.#handleUpload);\n    }\n}\n"],
  "mappings": "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",
  "names": ["EventManager", "#uppy", "#events", "uppy", "event", "fn", "fileID", "cb", "file", "isPaused", "eventHandler", "args", "NetworkError", "error", "xhr", "NetworkError_default", "ProgressTimeout", "#aliveTimer", "#isDone", "#onTimedOut", "#timeout", "timeout", "timeoutHandler", "ProgressTimeout_default", "noop", "fetcher", "url", "options", "body", "headers", "method", "onBeforeRequest", "onUploadProgress", "shouldRetry", "onAfterResponse", "onTimeout", "responseType", "retries", "signal", "timeout", "withCredentials", "delay", "attempt", "timer", "ProgressTimeout_default", "requestWithRetry", "retryCount", "resolve", "reject", "xhr", "onError", "error", "err", "NetworkError_default", "event", "key", "filterNonFailedFiles", "files", "hasError", "file", "filterFilesToEmitUploadStarted", "getAllowedMetaFields", "fields", "meta", "isNetworkError", "xhr", "isNetworkError_default", "createCancelError", "cause", "abortOn", "signal", "abortPromise", "removeAbortListener", "RateLimitedQueue", "#activeRequests", "#queuedHandlers", "#paused", "#pauseTimer", "#downLimit", "#upperLimit", "#rateLimitingTimer", "limit", "#call", "fn", "done", "cancelActive", "err", "#queueNext", "#next", "next", "handler", "#queue", "options", "#dequeue", "index", "other", "queueOptions", "args", "queuedRequest", "outerPromise", "resolve", "reject", "cancelError", "innerPromise", "result", "i", "#resume", "duration", "#increaseLimit", "internalRateLimitedQueue", "package_default", "locale_default", "buildResponseError", "xhr", "err", "error", "isNetworkError_default", "NetworkError_default", "setTypeInBlob", "file", "defaultOptions", "XHRUpload", "BasePlugin", "package_default", "#getFetcher", "uppy", "opts", "locale_default", "internalRateLimitedQueue", "RateLimitedQueue", "files", "url", "options", "res", "fetcher", "retryCount", "timeout", "seconds", "event", "id", "body", "cause", "uploadURL", "request", "overrides", "headers", "formData", "meta", "getAllowedMetaFields", "item", "value", "subItem", "formPost", "dataWithUpdatedType", "#uploadLocalFile", "events", "EventManager", "controller", "uppyFetch", "fetch", "endpoint", "#uploadBundle", "optsFromState", "abort", "#getCompanionClientArgs", "allowedMetaFields", "name", "#uploadFiles", "getQueue", "removedHandler", "removedFile", "uploadPromise", "#handleUpload", "fileIDs", "filesFiltered", "filterNonFailedFiles", "filesToEmit", "filterFilesToEmitUploadStarted", "capabilities"]
}
