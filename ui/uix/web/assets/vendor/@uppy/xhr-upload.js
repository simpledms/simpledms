import{a as A}from"../chunk-RMJY7HHF.js";import"../chunk-FW4363Y4.js";var y=class{#t;#e=[];constructor(t){this.#t=t}on(t,e){return this.#e.push([t,e]),this.#t.on(t,e)}remove(){for(let[t,e]of this.#e.splice(0))this.#t.off(t,e)}onFilePause(t,e){this.on("upload-pause",(s,i)=>{t===s?.id&&e(i)})}onFileRemove(t,e){this.on("file-removed",s=>{t===s.id&&e(s.id)})}onPause(t,e){this.on("upload-pause",(s,i)=>{t===s?.id&&e(i)})}onRetry(t,e){this.on("upload-retry",s=>{t===s?.id&&e()})}onRetryAll(t,e){this.on("retry-all",()=>{this.#t.getFile(t)&&e()})}onPauseAll(t,e){this.on("pause-all",()=>{this.#t.getFile(t)&&e()})}onCancelAll(t,e){this.on("cancel-all",(...s)=>{this.#t.getFile(t)&&e(...s)})}onResumeAll(t,e){this.on("resume-all",()=>{this.#t.getFile(t)&&e()})}};var q=class extends Error{cause;isNetworkError;request;constructor(t,e=null){super("This looks like a network error, the endpoint might be blocked by an internet provider or a firewall."),this.cause=t,this.isNetworkError=!0,this.request=e}},w=q;var v=class{#t;#e=!1;#s;#i;constructor(t,e){this.#i=t,this.#s=()=>e(t)}progress(){this.#e||this.#i>0&&(clearTimeout(this.#t),this.#t=setTimeout(this.#s,this.#i))}done(){this.#e||(clearTimeout(this.#t),this.#t=void 0,this.#e=!0)}},M=v;var g=()=>{};function P(r,t={}){let{body:e=null,headers:s={},method:i="GET",onBeforeRequest:o=g,onUploadProgress:n=g,shouldRetry:a=()=>!0,onAfterResponse:d=g,onTimeout:p=g,responseType:u,retries:c=3,signal:B=null,timeout:I=3e4,withCredentials:W=!1}=t,S=h=>.3*2**(h-1)*1e3,b=new M(I,p);function R(h=0){return new Promise(async(x,f)=>{let l=new XMLHttpRequest,O=m=>{a(l)&&h<c?setTimeout(()=>{R(h+1).then(x,f)},S(h)):(b.done(),f(m))};l.open(i,r,!0),l.withCredentials=W,u&&(l.responseType=u),B?.addEventListener("abort",()=>{l.abort(),f(new DOMException("Aborted","AbortError"))}),l.onload=async()=>{try{await d(l,h)}catch(m){m.request=l,O(m);return}l.status>=200&&l.status<300?(b.done(),x(l)):a(l)&&h<c?setTimeout(()=>{R(h+1).then(x,f)},S(h)):(b.done(),f(new w(l.statusText,l)))},l.onerror=()=>O(new w(l.statusText,l)),l.upload.onprogress=m=>{b.progress(),n(m)},s&&Object.keys(s).forEach(m=>{l.setRequestHeader(m,s[m])}),await o(l,h),l.send(e)})}return R()}function N(r){let t=e=>"error"in e&&!!e.error;return r.filter(e=>!t(e))}function k(r){return r.filter(t=>!t.progress?.uploadStarted||!t.isRestored)}function F(r,t){return r===!0?Object.keys(t):Array.isArray(r)?r:[]}function z(r){return r?r.readyState!==0&&r.readyState!==4||r.status===0:!1}var L=z;function J(r){return new Error("Cancelled",{cause:r})}function C(r){if(r!=null){let t=()=>this.abort(r.reason);r.addEventListener("abort",t,{once:!0});let e=()=>{r.removeEventListener("abort",t)};this.then?.(e,e)}return this}var E=class{#t=0;#e=[];#s=!1;#i;#o=1;#r;#n;limit;constructor(t){typeof t!="number"||t===0?this.limit=1/0:this.limit=t}#p(t){this.#t+=1;let e=!1,s;try{s=t()}catch(i){throw this.#t-=1,i}return{abort:i=>{e||(e=!0,this.#t-=1,s?.(i),this.#a())},done:()=>{e||(e=!0,this.#t-=1,this.#a())}}}#a(){queueMicrotask(()=>this.#u())}#u(){if(this.#s||this.#t>=this.limit||this.#e.length===0)return;let t=this.#e.shift();if(t==null)throw new Error("Invariant violation: next is null");let e=this.#p(t.fn);t.abort=e.abort,t.done=e.done}#d(t,e){let s={fn:t,priority:e?.priority||0,abort:()=>{this.#h(s)},done:()=>{throw new Error("Cannot mark a queued request as done: this indicates a bug")}},i=this.#e.findIndex(o=>s.priority>o.priority);return i===-1?this.#e.push(s):this.#e.splice(i,0,s),s}#h(t){let e=this.#e.indexOf(t);e!==-1&&this.#e.splice(e,1)}run(t,e){return!this.#s&&this.#t<this.limit?this.#p(t):this.#d(t,e)}wrapSyncFunction(t,e){return(...s)=>{let i=this.run(()=>(t(...s),queueMicrotask(()=>i.done()),()=>{}),e);return{abortOn:C,abort(){i.abort()}}}}wrapPromiseFunction(t,e){return(...s)=>{let i,o=new Promise((n,a)=>{i=this.run(()=>{let d,p;try{p=Promise.resolve(t(...s))}catch(u){p=Promise.reject(u)}return p.then(u=>{d?a(d):(i.done(),n(u))},u=>{d?a(d):(i.done(),a(u))}),u=>{d=J(u)}},e)});return o.abort=n=>{i.abort(n)},o.abortOn=C,o}}resume(){this.#s=!1,clearTimeout(this.#i);for(let t=0;t<this.limit;t++)this.#a()}#c=()=>this.resume();pause(t=null){this.#s=!0,clearTimeout(this.#i),t!=null&&(this.#i=setTimeout(this.#c,t))}rateLimit(t){clearTimeout(this.#n),this.pause(t),this.limit>1&&Number.isFinite(this.limit)&&(this.#r=this.limit-1,this.limit=this.#o,this.#n=setTimeout(this.#l,t))}#l=()=>{if(this.#s){this.#n=setTimeout(this.#l,0);return}this.#o=this.limit,this.limit=Math.ceil((this.#r+this.#o)/2);for(let t=this.#o;t<=this.limit;t++)this.#a();this.#r-this.#o>3?this.#n=setTimeout(this.#l,2e3):this.#o=Math.floor(this.#o/2)};get isPaused(){return this.#s}},T=Symbol("__queue");var D={name:"@uppy/xhr-upload",description:"Plain and simple classic HTML multipart form uploads with Uppy, as well as uploads using the HTTP PUT method.",version:"4.4.2",license:"MIT",main:"lib/index.js",type:"module",scripts:{build:"tsc --build tsconfig.build.json",typecheck:"tsc --build",test:"vitest run --environment=jsdom --silent='passed-only'"},keywords:["file uploader","xhr","xhr upload","XMLHttpRequest","ajax","fetch","uppy","uppy-plugin"],homepage:"https://uppy.io",bugs:{url:"https://github.com/transloadit/uppy/issues"},repository:{type:"git",url:"git+https://github.com/transloadit/uppy.git"},files:["src","lib","dist","CHANGELOG.md"],dependencies:{"@uppy/companion-client":"^4.5.2","@uppy/utils":"^6.2.2"},devDependencies:{"@uppy/core":"^4.5.2",jsdom:"^26.1.0",nock:"^13.1.0",typescript:"^5.8.3",vitest:"^3.2.4"},peerDependencies:{"@uppy/core":"^4.5.2"}};var H={strings:{uploadStalled:"Upload has not made any progress for %{seconds} seconds. You may want to retry it."}};function G(r,t){let e=t;return e||(e=new Error("Upload error")),typeof e=="string"&&(e=new Error(e)),e instanceof Error||(e=Object.assign(new Error("Upload error"),{data:e})),L(r)?(e=new w(e,r),e):(e.request=r,e)}function j(r){return r.data.slice(0,r.data.size,r.meta.type)}var Q={formData:!0,fieldName:"file",method:"post",allowedMetaFields:!0,bundle:!1,headers:{},timeout:30*1e3,limit:5,withCredentials:!1,responseType:""},U=class extends A{static VERSION=D.version;#t;requests;uploaderEvents;constructor(t,e){if(super(t,{...Q,fieldName:e.bundle?"files[]":"file",...e}),this.type="uploader",this.id=this.opts.id||"XHRUpload",this.defaultLocale=H,this.i18nInit(),T in this.opts?this.requests=this.opts[T]:this.requests=new E(this.opts.limit),this.opts.bundle&&!this.opts.formData)throw new Error("`opts.formData` must be true when `opts.bundle` is enabled.");if(this.opts.bundle&&typeof this.opts.headers=="function")throw new Error("`opts.headers` can not be a function when the `bundle: true` option is set.");if(e?.allowedMetaFields===void 0&&"metaFields"in this.opts)throw new Error("The `metaFields` option has been renamed to `allowedMetaFields`.");this.uploaderEvents=Object.create(null),this.#t=s=>async(i,o)=>{try{let n=await P(i,{...o,onBeforeRequest:(p,u)=>this.opts.onBeforeRequest?.(p,u,s),shouldRetry:this.opts.shouldRetry,onAfterResponse:this.opts.onAfterResponse,onTimeout:p=>{let u=Math.ceil(p/1e3),c=new Error(this.i18n("uploadStalled",{seconds:u}));this.uppy.emit("upload-stalled",c,s)},onUploadProgress:p=>{if(p.lengthComputable)for(let{id:u}of s){let c=this.uppy.getFile(u);this.uppy.emit("upload-progress",c,{uploadStarted:c.progress.uploadStarted??0,bytesUploaded:p.loaded/p.total*c.size,bytesTotal:c.size})}}}),a=await this.opts.getResponseData?.(n);if(n.responseType==="json")a??=n.response;else try{a??=JSON.parse(n.responseText)}catch(p){throw new Error("@uppy/xhr-upload expects a JSON response (with a `url` property). To parse non-JSON responses, use `getResponseData` to turn your response into JSON.",{cause:p})}let d=typeof a?.url=="string"?a.url:void 0;for(let{id:p}of s)this.uppy.emit("upload-success",this.uppy.getFile(p),{status:n.status,body:a,uploadURL:d});return n}catch(n){if(n.name==="AbortError")return;let a=n.request;for(let d of s)this.uppy.emit("upload-error",this.uppy.getFile(d.id),G(a,n),a);throw n}}}getOptions(t){let e=this.uppy.getState().xhrUpload,{headers:s}=this.opts,i={...this.opts,...e||{},...t.xhrUpload||{},headers:{}};return typeof s=="function"?i.headers=s(t):Object.assign(i.headers,this.opts.headers),e&&Object.assign(i.headers,e.headers),t.xhrUpload&&Object.assign(i.headers,t.xhrUpload.headers),i}addMetadata(t,e,s){F(s.allowedMetaFields,e).forEach(o=>{let n=e[o];Array.isArray(n)?n.forEach(a=>t.append(o,a)):t.append(o,n)})}createFormDataUpload(t,e){let s=new FormData;this.addMetadata(s,t.meta,e);let i=j(t);return t.name?s.append(e.fieldName,i,t.meta.name):s.append(e.fieldName,i),s}createBundledUpload(t,e){let s=new FormData,{meta:i}=this.uppy.getState();return this.addMetadata(s,i,e),t.forEach(o=>{let n=this.getOptions(o),a=j(o);o.name?s.append(n.fieldName,a,o.name):s.append(n.fieldName,a)}),s}async#e(t){let e=new y(this.uppy),s=new AbortController,i=this.requests.wrapPromiseFunction(async()=>{let o=this.getOptions(t),n=this.#t([t]),a=o.formData?this.createFormDataUpload(t,o):t.data,d=typeof o.endpoint=="string"?o.endpoint:await o.endpoint(t);return n(d,{...o,body:a,signal:s.signal})});e.onFileRemove(t.id,()=>s.abort()),e.onCancelAll(t.id,()=>{s.abort()});try{await i().abortOn(s.signal)}catch(o){if(o.message!=="Cancelled")throw o}finally{e.remove()}}async#s(t){let e=new AbortController,s=this.requests.wrapPromiseFunction(async()=>{let o=this.uppy.getState().xhrUpload??{},n=this.#t(t),a=this.createBundledUpload(t,{...this.opts,...o}),d=typeof this.opts.endpoint=="string"?this.opts.endpoint:await this.opts.endpoint(t);return n(d,{...this.opts,body:a,signal:e.signal})});function i(){e.abort()}this.uppy.once("cancel-all",i);try{await s().abortOn(e.signal)}catch(o){if(o.message!=="Cancelled")throw o}finally{this.uppy.off("cancel-all",i)}}#i(t){let e=this.getOptions(t),s=F(e.allowedMetaFields,t.meta);return{...t.remote?.body,protocol:"multipart",endpoint:e.endpoint,size:t.data.size,fieldname:e.fieldName,metadata:Object.fromEntries(s.map(i=>[i,t.meta[i]])),httpMethod:e.method,useFormData:e.formData,headers:e.headers}}async#o(t){await Promise.allSettled(t.map(e=>{if(e.isRemote){let s=()=>this.requests,i=new AbortController,o=a=>{a.id===e.id&&i.abort()};this.uppy.on("file-removed",o);let n=this.uppy.getRequestClientForFile(e).uploadRemoteFile(e,this.#i(e),{signal:i.signal,getQueue:s});return this.requests.wrapSyncFunction(()=>{this.uppy.off("file-removed",o)},{priority:-1})(),n}return this.#e(e)}))}#r=async t=>{if(t.length===0){this.uppy.log("[XHRUpload] No files to upload!");return}this.opts.limit===0&&!this.opts[T]&&this.uppy.log("[XHRUpload] When uploading multiple files at once, consider setting the `limit` option (to `10` for example), to limit the number of concurrent uploads, which helps prevent memory and network issues: https://uppy.io/docs/xhr-upload/#limit-0","warning"),this.uppy.log("[XHRUpload] Uploading...");let e=this.uppy.getFilesByIds(t),s=N(e),i=k(s);if(this.uppy.emit("upload-start",i),this.opts.bundle){if(s.some(n=>n.isRemote))throw new Error("Can\u2019t upload remote files when the `bundle: true` option is set");if(typeof this.opts.headers=="function")throw new TypeError("`headers` may not be a function when the `bundle: true` option is set");await this.#s(s)}else await this.#o(s)};install(){if(this.opts.bundle){let{capabilities:t}=this.uppy.getState();this.uppy.setState({capabilities:{...t,individualCancellation:!1}})}this.uppy.addUploader(this.#r)}uninstall(){if(this.opts.bundle){let{capabilities:t}=this.uppy.getState();this.uppy.setState({capabilities:{...t,individualCancellation:!0}})}this.uppy.removeUploader(this.#r)}};export{U as default};
//# sourceMappingURL=xhr-upload.js.map
