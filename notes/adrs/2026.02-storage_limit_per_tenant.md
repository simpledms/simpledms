# ADR: Storage limit per tenant in SaaS mode

## Context

SimpleDMS needs tenant storage limits for SaaS operation.

Required behavior:

- Limit applies only in SaaS mode.
- Storage quota depends on the tenant's active subscription plan.
- `pro`: 5 GB per active user, pooled globally per tenant (not per-user silos).
- `trial`: 1 GB total per tenant, independent of user count.
- `unlimited`: 500 GB total per tenant, independent of user count.
- Quota accounting must use uploaded/original filesize, not compressed/encrypted storage size.

Current model already stores both sizes:

- `stored_file.size` = uploaded/original bytes.
- `stored_file.size_in_storage` = compressed/encrypted object storage bytes.

## Decision

### Quota formula

In SaaS mode:

- Determine the tenant's active subscription plan.
- `tenant_limit_bytes` is derived from that plan:
  - `pro`: `active_user_count * 5 * 1024 * 1024 * 1024`
  - `trial`: `1 * 1024 * 1024 * 1024`
  - `unlimited`: `500 * 1024 * 1024 * 1024`
- `tenant_used_bytes = SUM(stored_file.size)` over counted files (defined below)

Unit definition:

- `1 GB` in this ADR means `1 GiB = 1024 * 1024 * 1024` bytes.

In non-SaaS mode:

- Quota enforcement is disabled.

### Definition: active user count

`active_user_count` is used for the `pro` plan and is the number of tenant assignments that are:

- not soft-deleted,
- not expired (`expires_at` is NULL or in the future),
- linked to an existing account.

Owners are included.

### Definition: counted bytes

Count only files that were successfully uploaded:

- include only `stored_file` rows with `upload_succeeded_at != NULL`,
- include all such stored files in the tenant, including:
  - current versions,
  - historical versions,
  - files currently in trash.

Do not count:

- unfinished uploads,
- failed uploads.

### Enforcement points (source of truth)

Quota is enforced in central storage write paths (not only in HTTP handlers), specifically:

1. tenant upload finalization (`FinalizePreparedUpload(...)`),
2. temporary-account-file persistence into tenant storage (`PreparePersistingTemporaryAccountFile(...)`).

Optional preflight checks may be used for UX, but final quota validation is rechecked in the transactional finalize/persist path.

For archive extraction (`unzip`), partial success is not allowed:

- if quota is insufficient, extraction is rejected,
- no files from that unzip operation may remain created.

### Error behavior

If an incoming upload would exceed tenant quota:

- return HTTP `413 Request Entity Too Large`,
- return a clear user-facing message with used and limit values.

Example (`pro`, one active user):
`Storage limit reached for this organization. Used: 4.9 GB of 5.0 GB.`

## Rationale

- Plan-based quota matches the subscription model and expected billing behavior.
- `pro` keeps the existing per-user pooled quota model.
- `trial` and `unlimited` provide fixed tenant-wide caps independent of seat count.
- Using `stored_file.size` exactly matches "uploaded filesize counts".
- Centralized enforcement prevents gaps across multiple upload flows.
- Recheck-at-finalize reduces race issues during concurrent uploads near the limit.

## Behavior when user count decreases

If `pro` user count drops and current usage is above the new computed limit:

- no data is deleted automatically,
- new uploads are blocked until usage falls below the limit.

For `trial` and `unlimited`, user count changes do not affect quota.

## Implementation notes

- Introduce internal constants: `tenantQuotaProPerUserBytes`, `tenantQuotaTrialBytes`,
  and `tenantQuotaUnlimitedBytes`.
- Wrap limit calculation in a single function (`limitForTenant(...)`) that uses the active
  plan and can be extended for future tiers without changing callers.
- Use read-write transaction context for final quota validation and write, so usage check and persistence are consistent.
- For unzip flows, run a required preflight quota estimate using archive entry sizes before creating files, and keep finalize-time checks as a second guard.
- Unzip must be all-or-nothing: if quota would be exceeded, abort the operation and roll back any files/versions created by that unzip.

## Consequences

Positive:

- predictable SaaS quota behavior per subscription plan,
- consistent enforcement across upload entry points,
- no dependency on compression ratios.

Trade-offs:

- quota usage can differ from actual object storage footprint,
- unzip requires extra validation/rollback handling before and during processing,
- no automatic remediation when limits are reduced by plan changes or `pro` user-count changes.

## Alternatives considered

1. Use `size_in_storage`
   Rejected: violates requirement and creates variable quota behavior.

2. Enforce only at HTTP handlers
   Rejected: misses non-handler or alternate upload paths.

3. Keep a single 5 GB-per-user quota for all plans
   Rejected: conflicts with the new subscription plan model.

## Acceptance criteria

- In SaaS mode, `tenant_limit_bytes` is derived from the active plan (`trial`, `pro`, `unlimited`).
- In `pro`, uploads are rejected when
  `tenant_used_bytes + incoming_uploaded_bytes > active_user_count * 5 GiB`.
- In `trial`, uploads are rejected when `tenant_used_bytes + incoming_uploaded_bytes > 1 GiB`.
- In `unlimited`, uploads are rejected when
  `tenant_used_bytes + incoming_uploaded_bytes > 500 GiB`.
- In non-SaaS mode, quota checks are skipped.
- Quota accounting uses `stored_file.size` only.
- Both enforcement paths (`FinalizePreparedUpload` and `PreparePersistingTemporaryAccountFile`) apply the same rule.
- Over-limit response is HTTP 413 with a clear "used vs limit" message.
- If tenant is already over quota due to plan change or `pro` user-count decrease, further uploads are blocked but existing data remains untouched.
- Unzip is atomic regarding quota: insufficient quota causes full failure with no partial extracted files left behind.

## Test coverage required

- SaaS enabled, `trial` plan: below limit, exactly at limit, above limit.
- SaaS enabled, `pro` plan: below limit, exactly at limit, above limit.
- SaaS enabled, `unlimited` plan: below limit, exactly at limit, above limit.
- SaaS disabled: uploads proceed regardless of quota.
- Accounting correctness: compressed size changes do not affect quota (only uploaded size does).
- Both write paths enforce quota:
  - regular tenant upload finalization,
  - temporary account upload persisted into tenant.
- Plan change to a lower quota tier blocks new uploads when current usage exceeds new limit.
- Concurrent uploads near limit do not bypass final quota enforcement.
- Unzip over quota leaves no created files/versions from that unzip attempt.
