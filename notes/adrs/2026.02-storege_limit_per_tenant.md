# ADR: Storage limit per tenant in SaaS mode

## Context

SimpleDMS needs a tenant storage limit for SaaS operation.

Required behavior:

- Limit applies only in SaaS mode.
- Limit is 5 GB per user.
- Limit is pooled globally per tenant (not per-user silos).
- Quota accounting must use uploaded/original filesize, not compressed/encrypted storage size.

Current model already stores both sizes:

- `stored_file.size` = uploaded/original bytes.
- `stored_file.size_in_storage` = compressed/encrypted object storage bytes.

## Decision

### Quota formula

In SaaS mode:

- `tenant_limit_bytes = active_user_count * 5 * 1024 * 1024 * 1024`
- `tenant_used_bytes = SUM(stored_file.size)` over counted files (defined below)

Unit definition:

- `1 GB` in this ADR means `1 GiB = 1024 * 1024 * 1024` bytes.

In non-SaaS mode:

- Quota enforcement is disabled.

### Definition: active user count

`active_user_count` is the number of tenant assignments that are:

- not soft-deleted,
- not expired (`expires_at` is NULL or in the future),
- linked to an existing account.

Owners are included.

### Definition: counted bytes

Count only files that were successfully uploaded:

- include only `stored_file` rows with `upload_succeeded_at != NULL`,
- include all such stored files in the tenant, including:
  - current versions,
  - historical versions,
  - files currently in trash.

Do not count:

- unfinished uploads,
- failed uploads.

### Enforcement points (source of truth)

Quota is enforced in central storage write paths (not only in HTTP handlers), specifically:

1. tenant upload finalization (`FinalizePreparedUpload(...)`),
2. temporary-account-file persistence into tenant storage (`PreparePersistingTemporaryAccountFile(...)`).

Optional preflight checks may be used for UX, but final quota validation is rechecked in the transactional finalize/persist path.

For archive extraction (`unzip`), partial success is not allowed:

- if quota is insufficient, extraction is rejected,
- no files from that unzip operation may remain created.

### Error behavior

If an incoming upload would exceed tenant quota:

- return HTTP `413 Request Entity Too Large`,
- return a clear user-facing message with used and limit values.

Example:
`Storage limit reached for this organization. Used: 4.9 GB of 5.0 GB.`

## Rationale

- Pooled per-tenant quota matches the product rule ("5 GB per user, global").
- Using `stored_file.size` exactly matches "uploaded filesize counts".
- Centralized enforcement prevents gaps across multiple upload flows.
- Recheck-at-finalize reduces race issues during concurrent uploads near the limit.

## Behavior when user count decreases

If user count drops and current usage is above the new computed limit:

- no data is deleted automatically,
- new uploads are blocked until usage falls below the limit.

## Implementation notes

- Introduce one internal constant now: `tenantQuotaPerUserBytes = 5 * 1024 * 1024 * 1024`.
- Wrap limit calculation in a single function (`limitForTenant(...)`) so future plan tiers can replace this logic without changing callers.
- Use read-write transaction context for final quota validation and write, so usage check and persistence are consistent.
- For unzip flows, run a required preflight quota estimate using archive entry sizes before creating files, and keep finalize-time checks as a second guard.
- Unzip must be all-or-nothing: if quota would be exceeded, abort the operation and roll back any files/versions created by that unzip.

## Consequences

Positive:

- predictable SaaS quota behavior,
- consistent enforcement across upload entry points,
- no dependency on compression ratios.

Trade-offs:

- quota usage can differ from actual object storage footprint,
- unzip requires extra validation/rollback handling before and during processing,
- no automatic remediation when limits are reduced by user-count changes.

## Alternatives considered

1. Use `size_in_storage`
   Rejected: violates requirement and creates variable quota behavior.

2. Enforce only at HTTP handlers
   Rejected: misses non-handler or alternate upload paths.

3. Per-user hard caps instead of pooled tenant cap
   Rejected: conflicts with required global tenant pooling.

## Acceptance criteria

- In SaaS mode, uploads are rejected when `tenant_used_bytes + incoming_uploaded_bytes > tenant_limit_bytes`.
- In non-SaaS mode, quota checks are skipped.
- Quota accounting uses `stored_file.size` only.
- Both enforcement paths (`FinalizePreparedUpload` and `PreparePersistingTemporaryAccountFile`) apply the same rule.
- Over-limit response is HTTP 413 with a clear "used vs limit" message.
- If tenant is already over quota due to user-count decrease, further uploads are blocked but existing data remains untouched.
- Unzip is atomic regarding quota: insufficient quota causes full failure with no partial extracted files left behind.

## Test coverage required

- SaaS enabled: below limit, exactly at limit, above limit.
- SaaS disabled: uploads proceed regardless of quota.
- Accounting correctness: compressed size changes do not affect quota (only uploaded size does).
- Both write paths enforce quota:
  - regular tenant upload finalization,
  - temporary account upload persisted into tenant.
- Concurrent uploads near limit do not bypass final quota enforcement.
- Unzip over quota leaves no created files/versions from that unzip attempt.
