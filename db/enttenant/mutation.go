// Code generated by ent, DO NOT EDIT.

package enttenant

import (
	"context"
	"errors"
	"fmt"
	"sync"
	"time"

	"entgo.io/ent"
	"entgo.io/ent/dialect/sql"
	"github.com/simpledms/simpledms/db/enttenant/attribute"
	"github.com/simpledms/simpledms/db/enttenant/documenttype"
	"github.com/simpledms/simpledms/db/enttenant/file"
	"github.com/simpledms/simpledms/db/enttenant/filepropertyassignment"
	"github.com/simpledms/simpledms/db/enttenant/predicate"
	"github.com/simpledms/simpledms/db/enttenant/property"
	"github.com/simpledms/simpledms/db/enttenant/space"
	"github.com/simpledms/simpledms/db/enttenant/spaceuserassignment"
	"github.com/simpledms/simpledms/db/enttenant/storedfile"
	"github.com/simpledms/simpledms/db/enttenant/tag"
	"github.com/simpledms/simpledms/db/enttenant/tagassignment"
	"github.com/simpledms/simpledms/db/enttenant/user"
	"github.com/simpledms/simpledms/db/entx"
	"github.com/simpledms/simpledms/model/common/attributetype"
	"github.com/simpledms/simpledms/model/common/fieldtype"
	"github.com/simpledms/simpledms/model/common/spacerole"
	"github.com/simpledms/simpledms/model/common/storagetype"
	"github.com/simpledms/simpledms/model/common/tenantrole"
	"github.com/simpledms/simpledms/model/tagging/tagtype"
	"github.com/simpledms/simpledms/util/timex"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeAttribute              = "Attribute"
	TypeDocumentType           = "DocumentType"
	TypeFile                   = "File"
	TypeFileInfo               = "FileInfo"
	TypeFilePropertyAssignment = "FilePropertyAssignment"
	TypeFileSearch             = "FileSearch"
	TypeProperty               = "Property"
	TypeResolvedTagAssignment  = "ResolvedTagAssignment"
	TypeSpace                  = "Space"
	TypeSpaceUserAssignment    = "SpaceUserAssignment"
	TypeStoredFile             = "StoredFile"
	TypeTag                    = "Tag"
	TypeTagAssignment          = "TagAssignment"
	TypeUser                   = "User"
)

// AttributeMutation represents an operation that mutates the Attribute nodes in the graph.
type AttributeMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int64
	name                 *string
	is_name_giving       *bool
	is_protected         *bool
	is_disabled          *bool
	is_required          *bool
	_type                *attributetype.AttributeType
	clearedFields        map[string]struct{}
	space                *int64
	clearedspace         bool
	document_type        *int64
	cleareddocument_type bool
	tag                  *int64
	clearedtag           bool
	property             *int64
	clearedproperty      bool
	done                 bool
	oldValue             func(context.Context) (*Attribute, error)
	predicates           []predicate.Attribute
}

var _ ent.Mutation = (*AttributeMutation)(nil)

// attributeOption allows management of the mutation configuration using functional options.
type attributeOption func(*AttributeMutation)

// newAttributeMutation creates new mutation for the Attribute entity.
func newAttributeMutation(c config, op Op, opts ...attributeOption) *AttributeMutation {
	m := &AttributeMutation{
		config:        c,
		op:            op,
		typ:           TypeAttribute,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withAttributeID sets the ID field of the mutation.
func withAttributeID(id int64) attributeOption {
	return func(m *AttributeMutation) {
		var (
			err   error
			once  sync.Once
			value *Attribute
		)
		m.oldValue = func(ctx context.Context) (*Attribute, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Attribute.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withAttribute sets the old Attribute of the mutation.
func withAttribute(node *Attribute) attributeOption {
	return func(m *AttributeMutation) {
		m.oldValue = func(context.Context) (*Attribute, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m AttributeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m AttributeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("enttenant: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Attribute entities.
func (m *AttributeMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *AttributeMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *AttributeMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Attribute.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSpaceID sets the "space_id" field.
func (m *AttributeMutation) SetSpaceID(i int64) {
	m.space = &i
}

// SpaceID returns the value of the "space_id" field in the mutation.
func (m *AttributeMutation) SpaceID() (r int64, exists bool) {
	v := m.space
	if v == nil {
		return
	}
	return *v, true
}

// OldSpaceID returns the old "space_id" field's value of the Attribute entity.
// If the Attribute object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttributeMutation) OldSpaceID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSpaceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSpaceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSpaceID: %w", err)
	}
	return oldValue.SpaceID, nil
}

// ResetSpaceID resets all changes to the "space_id" field.
func (m *AttributeMutation) ResetSpaceID() {
	m.space = nil
}

// SetDocumentTypeID sets the "document_type_id" field.
func (m *AttributeMutation) SetDocumentTypeID(i int64) {
	m.document_type = &i
}

// DocumentTypeID returns the value of the "document_type_id" field in the mutation.
func (m *AttributeMutation) DocumentTypeID() (r int64, exists bool) {
	v := m.document_type
	if v == nil {
		return
	}
	return *v, true
}

// OldDocumentTypeID returns the old "document_type_id" field's value of the Attribute entity.
// If the Attribute object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttributeMutation) OldDocumentTypeID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDocumentTypeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDocumentTypeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDocumentTypeID: %w", err)
	}
	return oldValue.DocumentTypeID, nil
}

// ResetDocumentTypeID resets all changes to the "document_type_id" field.
func (m *AttributeMutation) ResetDocumentTypeID() {
	m.document_type = nil
}

// SetName sets the "name" field.
func (m *AttributeMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *AttributeMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Attribute entity.
// If the Attribute object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttributeMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *AttributeMutation) ResetName() {
	m.name = nil
}

// SetIsNameGiving sets the "is_name_giving" field.
func (m *AttributeMutation) SetIsNameGiving(b bool) {
	m.is_name_giving = &b
}

// IsNameGiving returns the value of the "is_name_giving" field in the mutation.
func (m *AttributeMutation) IsNameGiving() (r bool, exists bool) {
	v := m.is_name_giving
	if v == nil {
		return
	}
	return *v, true
}

// OldIsNameGiving returns the old "is_name_giving" field's value of the Attribute entity.
// If the Attribute object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttributeMutation) OldIsNameGiving(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsNameGiving is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsNameGiving requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsNameGiving: %w", err)
	}
	return oldValue.IsNameGiving, nil
}

// ResetIsNameGiving resets all changes to the "is_name_giving" field.
func (m *AttributeMutation) ResetIsNameGiving() {
	m.is_name_giving = nil
}

// SetIsProtected sets the "is_protected" field.
func (m *AttributeMutation) SetIsProtected(b bool) {
	m.is_protected = &b
}

// IsProtected returns the value of the "is_protected" field in the mutation.
func (m *AttributeMutation) IsProtected() (r bool, exists bool) {
	v := m.is_protected
	if v == nil {
		return
	}
	return *v, true
}

// OldIsProtected returns the old "is_protected" field's value of the Attribute entity.
// If the Attribute object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttributeMutation) OldIsProtected(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsProtected is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsProtected requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsProtected: %w", err)
	}
	return oldValue.IsProtected, nil
}

// ResetIsProtected resets all changes to the "is_protected" field.
func (m *AttributeMutation) ResetIsProtected() {
	m.is_protected = nil
}

// SetIsDisabled sets the "is_disabled" field.
func (m *AttributeMutation) SetIsDisabled(b bool) {
	m.is_disabled = &b
}

// IsDisabled returns the value of the "is_disabled" field in the mutation.
func (m *AttributeMutation) IsDisabled() (r bool, exists bool) {
	v := m.is_disabled
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDisabled returns the old "is_disabled" field's value of the Attribute entity.
// If the Attribute object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttributeMutation) OldIsDisabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDisabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDisabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDisabled: %w", err)
	}
	return oldValue.IsDisabled, nil
}

// ResetIsDisabled resets all changes to the "is_disabled" field.
func (m *AttributeMutation) ResetIsDisabled() {
	m.is_disabled = nil
}

// SetIsRequired sets the "is_required" field.
func (m *AttributeMutation) SetIsRequired(b bool) {
	m.is_required = &b
}

// IsRequired returns the value of the "is_required" field in the mutation.
func (m *AttributeMutation) IsRequired() (r bool, exists bool) {
	v := m.is_required
	if v == nil {
		return
	}
	return *v, true
}

// OldIsRequired returns the old "is_required" field's value of the Attribute entity.
// If the Attribute object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttributeMutation) OldIsRequired(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsRequired is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsRequired requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsRequired: %w", err)
	}
	return oldValue.IsRequired, nil
}

// ResetIsRequired resets all changes to the "is_required" field.
func (m *AttributeMutation) ResetIsRequired() {
	m.is_required = nil
}

// SetType sets the "type" field.
func (m *AttributeMutation) SetType(at attributetype.AttributeType) {
	m._type = &at
}

// GetType returns the value of the "type" field in the mutation.
func (m *AttributeMutation) GetType() (r attributetype.AttributeType, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Attribute entity.
// If the Attribute object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttributeMutation) OldType(ctx context.Context) (v attributetype.AttributeType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *AttributeMutation) ResetType() {
	m._type = nil
}

// SetTagID sets the "tag_id" field.
func (m *AttributeMutation) SetTagID(i int64) {
	m.tag = &i
}

// TagID returns the value of the "tag_id" field in the mutation.
func (m *AttributeMutation) TagID() (r int64, exists bool) {
	v := m.tag
	if v == nil {
		return
	}
	return *v, true
}

// OldTagID returns the old "tag_id" field's value of the Attribute entity.
// If the Attribute object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttributeMutation) OldTagID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTagID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTagID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTagID: %w", err)
	}
	return oldValue.TagID, nil
}

// ClearTagID clears the value of the "tag_id" field.
func (m *AttributeMutation) ClearTagID() {
	m.tag = nil
	m.clearedFields[attribute.FieldTagID] = struct{}{}
}

// TagIDCleared returns if the "tag_id" field was cleared in this mutation.
func (m *AttributeMutation) TagIDCleared() bool {
	_, ok := m.clearedFields[attribute.FieldTagID]
	return ok
}

// ResetTagID resets all changes to the "tag_id" field.
func (m *AttributeMutation) ResetTagID() {
	m.tag = nil
	delete(m.clearedFields, attribute.FieldTagID)
}

// SetPropertyID sets the "property_id" field.
func (m *AttributeMutation) SetPropertyID(i int64) {
	m.property = &i
}

// PropertyID returns the value of the "property_id" field in the mutation.
func (m *AttributeMutation) PropertyID() (r int64, exists bool) {
	v := m.property
	if v == nil {
		return
	}
	return *v, true
}

// OldPropertyID returns the old "property_id" field's value of the Attribute entity.
// If the Attribute object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *AttributeMutation) OldPropertyID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPropertyID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPropertyID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPropertyID: %w", err)
	}
	return oldValue.PropertyID, nil
}

// ClearPropertyID clears the value of the "property_id" field.
func (m *AttributeMutation) ClearPropertyID() {
	m.property = nil
	m.clearedFields[attribute.FieldPropertyID] = struct{}{}
}

// PropertyIDCleared returns if the "property_id" field was cleared in this mutation.
func (m *AttributeMutation) PropertyIDCleared() bool {
	_, ok := m.clearedFields[attribute.FieldPropertyID]
	return ok
}

// ResetPropertyID resets all changes to the "property_id" field.
func (m *AttributeMutation) ResetPropertyID() {
	m.property = nil
	delete(m.clearedFields, attribute.FieldPropertyID)
}

// ClearSpace clears the "space" edge to the Space entity.
func (m *AttributeMutation) ClearSpace() {
	m.clearedspace = true
	m.clearedFields[attribute.FieldSpaceID] = struct{}{}
}

// SpaceCleared reports if the "space" edge to the Space entity was cleared.
func (m *AttributeMutation) SpaceCleared() bool {
	return m.clearedspace
}

// SpaceIDs returns the "space" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SpaceID instead. It exists only for internal usage by the builders.
func (m *AttributeMutation) SpaceIDs() (ids []int64) {
	if id := m.space; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSpace resets all changes to the "space" edge.
func (m *AttributeMutation) ResetSpace() {
	m.space = nil
	m.clearedspace = false
}

// ClearDocumentType clears the "document_type" edge to the DocumentType entity.
func (m *AttributeMutation) ClearDocumentType() {
	m.cleareddocument_type = true
	m.clearedFields[attribute.FieldDocumentTypeID] = struct{}{}
}

// DocumentTypeCleared reports if the "document_type" edge to the DocumentType entity was cleared.
func (m *AttributeMutation) DocumentTypeCleared() bool {
	return m.cleareddocument_type
}

// DocumentTypeIDs returns the "document_type" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DocumentTypeID instead. It exists only for internal usage by the builders.
func (m *AttributeMutation) DocumentTypeIDs() (ids []int64) {
	if id := m.document_type; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDocumentType resets all changes to the "document_type" edge.
func (m *AttributeMutation) ResetDocumentType() {
	m.document_type = nil
	m.cleareddocument_type = false
}

// ClearTag clears the "tag" edge to the Tag entity.
func (m *AttributeMutation) ClearTag() {
	m.clearedtag = true
	m.clearedFields[attribute.FieldTagID] = struct{}{}
}

// TagCleared reports if the "tag" edge to the Tag entity was cleared.
func (m *AttributeMutation) TagCleared() bool {
	return m.TagIDCleared() || m.clearedtag
}

// TagIDs returns the "tag" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TagID instead. It exists only for internal usage by the builders.
func (m *AttributeMutation) TagIDs() (ids []int64) {
	if id := m.tag; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTag resets all changes to the "tag" edge.
func (m *AttributeMutation) ResetTag() {
	m.tag = nil
	m.clearedtag = false
}

// ClearProperty clears the "property" edge to the Property entity.
func (m *AttributeMutation) ClearProperty() {
	m.clearedproperty = true
	m.clearedFields[attribute.FieldPropertyID] = struct{}{}
}

// PropertyCleared reports if the "property" edge to the Property entity was cleared.
func (m *AttributeMutation) PropertyCleared() bool {
	return m.PropertyIDCleared() || m.clearedproperty
}

// PropertyIDs returns the "property" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PropertyID instead. It exists only for internal usage by the builders.
func (m *AttributeMutation) PropertyIDs() (ids []int64) {
	if id := m.property; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProperty resets all changes to the "property" edge.
func (m *AttributeMutation) ResetProperty() {
	m.property = nil
	m.clearedproperty = false
}

// Where appends a list predicates to the AttributeMutation builder.
func (m *AttributeMutation) Where(ps ...predicate.Attribute) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the AttributeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *AttributeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Attribute, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *AttributeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *AttributeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Attribute).
func (m *AttributeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *AttributeMutation) Fields() []string {
	fields := make([]string, 0, 10)
	if m.space != nil {
		fields = append(fields, attribute.FieldSpaceID)
	}
	if m.document_type != nil {
		fields = append(fields, attribute.FieldDocumentTypeID)
	}
	if m.name != nil {
		fields = append(fields, attribute.FieldName)
	}
	if m.is_name_giving != nil {
		fields = append(fields, attribute.FieldIsNameGiving)
	}
	if m.is_protected != nil {
		fields = append(fields, attribute.FieldIsProtected)
	}
	if m.is_disabled != nil {
		fields = append(fields, attribute.FieldIsDisabled)
	}
	if m.is_required != nil {
		fields = append(fields, attribute.FieldIsRequired)
	}
	if m._type != nil {
		fields = append(fields, attribute.FieldType)
	}
	if m.tag != nil {
		fields = append(fields, attribute.FieldTagID)
	}
	if m.property != nil {
		fields = append(fields, attribute.FieldPropertyID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *AttributeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case attribute.FieldSpaceID:
		return m.SpaceID()
	case attribute.FieldDocumentTypeID:
		return m.DocumentTypeID()
	case attribute.FieldName:
		return m.Name()
	case attribute.FieldIsNameGiving:
		return m.IsNameGiving()
	case attribute.FieldIsProtected:
		return m.IsProtected()
	case attribute.FieldIsDisabled:
		return m.IsDisabled()
	case attribute.FieldIsRequired:
		return m.IsRequired()
	case attribute.FieldType:
		return m.GetType()
	case attribute.FieldTagID:
		return m.TagID()
	case attribute.FieldPropertyID:
		return m.PropertyID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *AttributeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case attribute.FieldSpaceID:
		return m.OldSpaceID(ctx)
	case attribute.FieldDocumentTypeID:
		return m.OldDocumentTypeID(ctx)
	case attribute.FieldName:
		return m.OldName(ctx)
	case attribute.FieldIsNameGiving:
		return m.OldIsNameGiving(ctx)
	case attribute.FieldIsProtected:
		return m.OldIsProtected(ctx)
	case attribute.FieldIsDisabled:
		return m.OldIsDisabled(ctx)
	case attribute.FieldIsRequired:
		return m.OldIsRequired(ctx)
	case attribute.FieldType:
		return m.OldType(ctx)
	case attribute.FieldTagID:
		return m.OldTagID(ctx)
	case attribute.FieldPropertyID:
		return m.OldPropertyID(ctx)
	}
	return nil, fmt.Errorf("unknown Attribute field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AttributeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case attribute.FieldSpaceID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSpaceID(v)
		return nil
	case attribute.FieldDocumentTypeID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDocumentTypeID(v)
		return nil
	case attribute.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case attribute.FieldIsNameGiving:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsNameGiving(v)
		return nil
	case attribute.FieldIsProtected:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsProtected(v)
		return nil
	case attribute.FieldIsDisabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDisabled(v)
		return nil
	case attribute.FieldIsRequired:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsRequired(v)
		return nil
	case attribute.FieldType:
		v, ok := value.(attributetype.AttributeType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case attribute.FieldTagID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTagID(v)
		return nil
	case attribute.FieldPropertyID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPropertyID(v)
		return nil
	}
	return fmt.Errorf("unknown Attribute field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *AttributeMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *AttributeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *AttributeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Attribute numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *AttributeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(attribute.FieldTagID) {
		fields = append(fields, attribute.FieldTagID)
	}
	if m.FieldCleared(attribute.FieldPropertyID) {
		fields = append(fields, attribute.FieldPropertyID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *AttributeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *AttributeMutation) ClearField(name string) error {
	switch name {
	case attribute.FieldTagID:
		m.ClearTagID()
		return nil
	case attribute.FieldPropertyID:
		m.ClearPropertyID()
		return nil
	}
	return fmt.Errorf("unknown Attribute nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *AttributeMutation) ResetField(name string) error {
	switch name {
	case attribute.FieldSpaceID:
		m.ResetSpaceID()
		return nil
	case attribute.FieldDocumentTypeID:
		m.ResetDocumentTypeID()
		return nil
	case attribute.FieldName:
		m.ResetName()
		return nil
	case attribute.FieldIsNameGiving:
		m.ResetIsNameGiving()
		return nil
	case attribute.FieldIsProtected:
		m.ResetIsProtected()
		return nil
	case attribute.FieldIsDisabled:
		m.ResetIsDisabled()
		return nil
	case attribute.FieldIsRequired:
		m.ResetIsRequired()
		return nil
	case attribute.FieldType:
		m.ResetType()
		return nil
	case attribute.FieldTagID:
		m.ResetTagID()
		return nil
	case attribute.FieldPropertyID:
		m.ResetPropertyID()
		return nil
	}
	return fmt.Errorf("unknown Attribute field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *AttributeMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.space != nil {
		edges = append(edges, attribute.EdgeSpace)
	}
	if m.document_type != nil {
		edges = append(edges, attribute.EdgeDocumentType)
	}
	if m.tag != nil {
		edges = append(edges, attribute.EdgeTag)
	}
	if m.property != nil {
		edges = append(edges, attribute.EdgeProperty)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *AttributeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case attribute.EdgeSpace:
		if id := m.space; id != nil {
			return []ent.Value{*id}
		}
	case attribute.EdgeDocumentType:
		if id := m.document_type; id != nil {
			return []ent.Value{*id}
		}
	case attribute.EdgeTag:
		if id := m.tag; id != nil {
			return []ent.Value{*id}
		}
	case attribute.EdgeProperty:
		if id := m.property; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *AttributeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *AttributeMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *AttributeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedspace {
		edges = append(edges, attribute.EdgeSpace)
	}
	if m.cleareddocument_type {
		edges = append(edges, attribute.EdgeDocumentType)
	}
	if m.clearedtag {
		edges = append(edges, attribute.EdgeTag)
	}
	if m.clearedproperty {
		edges = append(edges, attribute.EdgeProperty)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *AttributeMutation) EdgeCleared(name string) bool {
	switch name {
	case attribute.EdgeSpace:
		return m.clearedspace
	case attribute.EdgeDocumentType:
		return m.cleareddocument_type
	case attribute.EdgeTag:
		return m.clearedtag
	case attribute.EdgeProperty:
		return m.clearedproperty
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *AttributeMutation) ClearEdge(name string) error {
	switch name {
	case attribute.EdgeSpace:
		m.ClearSpace()
		return nil
	case attribute.EdgeDocumentType:
		m.ClearDocumentType()
		return nil
	case attribute.EdgeTag:
		m.ClearTag()
		return nil
	case attribute.EdgeProperty:
		m.ClearProperty()
		return nil
	}
	return fmt.Errorf("unknown Attribute unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *AttributeMutation) ResetEdge(name string) error {
	switch name {
	case attribute.EdgeSpace:
		m.ResetSpace()
		return nil
	case attribute.EdgeDocumentType:
		m.ResetDocumentType()
		return nil
	case attribute.EdgeTag:
		m.ResetTag()
		return nil
	case attribute.EdgeProperty:
		m.ResetProperty()
		return nil
	}
	return fmt.Errorf("unknown Attribute edge %s", name)
}

// DocumentTypeMutation represents an operation that mutates the DocumentType nodes in the graph.
type DocumentTypeMutation struct {
	config
	op                Op
	typ               string
	id                *int64
	name              *string
	icon              *string
	is_protected      *bool
	is_disabled       *bool
	clearedFields     map[string]struct{}
	space             *int64
	clearedspace      bool
	attributes        map[int64]struct{}
	removedattributes map[int64]struct{}
	clearedattributes bool
	done              bool
	oldValue          func(context.Context) (*DocumentType, error)
	predicates        []predicate.DocumentType
}

var _ ent.Mutation = (*DocumentTypeMutation)(nil)

// documenttypeOption allows management of the mutation configuration using functional options.
type documenttypeOption func(*DocumentTypeMutation)

// newDocumentTypeMutation creates new mutation for the DocumentType entity.
func newDocumentTypeMutation(c config, op Op, opts ...documenttypeOption) *DocumentTypeMutation {
	m := &DocumentTypeMutation{
		config:        c,
		op:            op,
		typ:           TypeDocumentType,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDocumentTypeID sets the ID field of the mutation.
func withDocumentTypeID(id int64) documenttypeOption {
	return func(m *DocumentTypeMutation) {
		var (
			err   error
			once  sync.Once
			value *DocumentType
		)
		m.oldValue = func(ctx context.Context) (*DocumentType, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().DocumentType.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDocumentType sets the old DocumentType of the mutation.
func withDocumentType(node *DocumentType) documenttypeOption {
	return func(m *DocumentTypeMutation) {
		m.oldValue = func(context.Context) (*DocumentType, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DocumentTypeMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DocumentTypeMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("enttenant: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of DocumentType entities.
func (m *DocumentTypeMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *DocumentTypeMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *DocumentTypeMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().DocumentType.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSpaceID sets the "space_id" field.
func (m *DocumentTypeMutation) SetSpaceID(i int64) {
	m.space = &i
}

// SpaceID returns the value of the "space_id" field in the mutation.
func (m *DocumentTypeMutation) SpaceID() (r int64, exists bool) {
	v := m.space
	if v == nil {
		return
	}
	return *v, true
}

// OldSpaceID returns the old "space_id" field's value of the DocumentType entity.
// If the DocumentType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocumentTypeMutation) OldSpaceID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSpaceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSpaceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSpaceID: %w", err)
	}
	return oldValue.SpaceID, nil
}

// ResetSpaceID resets all changes to the "space_id" field.
func (m *DocumentTypeMutation) ResetSpaceID() {
	m.space = nil
}

// SetName sets the "name" field.
func (m *DocumentTypeMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *DocumentTypeMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the DocumentType entity.
// If the DocumentType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocumentTypeMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *DocumentTypeMutation) ResetName() {
	m.name = nil
}

// SetIcon sets the "icon" field.
func (m *DocumentTypeMutation) SetIcon(s string) {
	m.icon = &s
}

// Icon returns the value of the "icon" field in the mutation.
func (m *DocumentTypeMutation) Icon() (r string, exists bool) {
	v := m.icon
	if v == nil {
		return
	}
	return *v, true
}

// OldIcon returns the old "icon" field's value of the DocumentType entity.
// If the DocumentType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocumentTypeMutation) OldIcon(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIcon is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIcon requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIcon: %w", err)
	}
	return oldValue.Icon, nil
}

// ClearIcon clears the value of the "icon" field.
func (m *DocumentTypeMutation) ClearIcon() {
	m.icon = nil
	m.clearedFields[documenttype.FieldIcon] = struct{}{}
}

// IconCleared returns if the "icon" field was cleared in this mutation.
func (m *DocumentTypeMutation) IconCleared() bool {
	_, ok := m.clearedFields[documenttype.FieldIcon]
	return ok
}

// ResetIcon resets all changes to the "icon" field.
func (m *DocumentTypeMutation) ResetIcon() {
	m.icon = nil
	delete(m.clearedFields, documenttype.FieldIcon)
}

// SetIsProtected sets the "is_protected" field.
func (m *DocumentTypeMutation) SetIsProtected(b bool) {
	m.is_protected = &b
}

// IsProtected returns the value of the "is_protected" field in the mutation.
func (m *DocumentTypeMutation) IsProtected() (r bool, exists bool) {
	v := m.is_protected
	if v == nil {
		return
	}
	return *v, true
}

// OldIsProtected returns the old "is_protected" field's value of the DocumentType entity.
// If the DocumentType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocumentTypeMutation) OldIsProtected(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsProtected is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsProtected requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsProtected: %w", err)
	}
	return oldValue.IsProtected, nil
}

// ResetIsProtected resets all changes to the "is_protected" field.
func (m *DocumentTypeMutation) ResetIsProtected() {
	m.is_protected = nil
}

// SetIsDisabled sets the "is_disabled" field.
func (m *DocumentTypeMutation) SetIsDisabled(b bool) {
	m.is_disabled = &b
}

// IsDisabled returns the value of the "is_disabled" field in the mutation.
func (m *DocumentTypeMutation) IsDisabled() (r bool, exists bool) {
	v := m.is_disabled
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDisabled returns the old "is_disabled" field's value of the DocumentType entity.
// If the DocumentType object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *DocumentTypeMutation) OldIsDisabled(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDisabled is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDisabled requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDisabled: %w", err)
	}
	return oldValue.IsDisabled, nil
}

// ResetIsDisabled resets all changes to the "is_disabled" field.
func (m *DocumentTypeMutation) ResetIsDisabled() {
	m.is_disabled = nil
}

// ClearSpace clears the "space" edge to the Space entity.
func (m *DocumentTypeMutation) ClearSpace() {
	m.clearedspace = true
	m.clearedFields[documenttype.FieldSpaceID] = struct{}{}
}

// SpaceCleared reports if the "space" edge to the Space entity was cleared.
func (m *DocumentTypeMutation) SpaceCleared() bool {
	return m.clearedspace
}

// SpaceIDs returns the "space" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SpaceID instead. It exists only for internal usage by the builders.
func (m *DocumentTypeMutation) SpaceIDs() (ids []int64) {
	if id := m.space; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSpace resets all changes to the "space" edge.
func (m *DocumentTypeMutation) ResetSpace() {
	m.space = nil
	m.clearedspace = false
}

// AddAttributeIDs adds the "attributes" edge to the Attribute entity by ids.
func (m *DocumentTypeMutation) AddAttributeIDs(ids ...int64) {
	if m.attributes == nil {
		m.attributes = make(map[int64]struct{})
	}
	for i := range ids {
		m.attributes[ids[i]] = struct{}{}
	}
}

// ClearAttributes clears the "attributes" edge to the Attribute entity.
func (m *DocumentTypeMutation) ClearAttributes() {
	m.clearedattributes = true
}

// AttributesCleared reports if the "attributes" edge to the Attribute entity was cleared.
func (m *DocumentTypeMutation) AttributesCleared() bool {
	return m.clearedattributes
}

// RemoveAttributeIDs removes the "attributes" edge to the Attribute entity by IDs.
func (m *DocumentTypeMutation) RemoveAttributeIDs(ids ...int64) {
	if m.removedattributes == nil {
		m.removedattributes = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.attributes, ids[i])
		m.removedattributes[ids[i]] = struct{}{}
	}
}

// RemovedAttributes returns the removed IDs of the "attributes" edge to the Attribute entity.
func (m *DocumentTypeMutation) RemovedAttributesIDs() (ids []int64) {
	for id := range m.removedattributes {
		ids = append(ids, id)
	}
	return
}

// AttributesIDs returns the "attributes" edge IDs in the mutation.
func (m *DocumentTypeMutation) AttributesIDs() (ids []int64) {
	for id := range m.attributes {
		ids = append(ids, id)
	}
	return
}

// ResetAttributes resets all changes to the "attributes" edge.
func (m *DocumentTypeMutation) ResetAttributes() {
	m.attributes = nil
	m.clearedattributes = false
	m.removedattributes = nil
}

// Where appends a list predicates to the DocumentTypeMutation builder.
func (m *DocumentTypeMutation) Where(ps ...predicate.DocumentType) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the DocumentTypeMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *DocumentTypeMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.DocumentType, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *DocumentTypeMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *DocumentTypeMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (DocumentType).
func (m *DocumentTypeMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *DocumentTypeMutation) Fields() []string {
	fields := make([]string, 0, 5)
	if m.space != nil {
		fields = append(fields, documenttype.FieldSpaceID)
	}
	if m.name != nil {
		fields = append(fields, documenttype.FieldName)
	}
	if m.icon != nil {
		fields = append(fields, documenttype.FieldIcon)
	}
	if m.is_protected != nil {
		fields = append(fields, documenttype.FieldIsProtected)
	}
	if m.is_disabled != nil {
		fields = append(fields, documenttype.FieldIsDisabled)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *DocumentTypeMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case documenttype.FieldSpaceID:
		return m.SpaceID()
	case documenttype.FieldName:
		return m.Name()
	case documenttype.FieldIcon:
		return m.Icon()
	case documenttype.FieldIsProtected:
		return m.IsProtected()
	case documenttype.FieldIsDisabled:
		return m.IsDisabled()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *DocumentTypeMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case documenttype.FieldSpaceID:
		return m.OldSpaceID(ctx)
	case documenttype.FieldName:
		return m.OldName(ctx)
	case documenttype.FieldIcon:
		return m.OldIcon(ctx)
	case documenttype.FieldIsProtected:
		return m.OldIsProtected(ctx)
	case documenttype.FieldIsDisabled:
		return m.OldIsDisabled(ctx)
	}
	return nil, fmt.Errorf("unknown DocumentType field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DocumentTypeMutation) SetField(name string, value ent.Value) error {
	switch name {
	case documenttype.FieldSpaceID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSpaceID(v)
		return nil
	case documenttype.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case documenttype.FieldIcon:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIcon(v)
		return nil
	case documenttype.FieldIsProtected:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsProtected(v)
		return nil
	case documenttype.FieldIsDisabled:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDisabled(v)
		return nil
	}
	return fmt.Errorf("unknown DocumentType field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *DocumentTypeMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *DocumentTypeMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *DocumentTypeMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown DocumentType numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *DocumentTypeMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(documenttype.FieldIcon) {
		fields = append(fields, documenttype.FieldIcon)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *DocumentTypeMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *DocumentTypeMutation) ClearField(name string) error {
	switch name {
	case documenttype.FieldIcon:
		m.ClearIcon()
		return nil
	}
	return fmt.Errorf("unknown DocumentType nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *DocumentTypeMutation) ResetField(name string) error {
	switch name {
	case documenttype.FieldSpaceID:
		m.ResetSpaceID()
		return nil
	case documenttype.FieldName:
		m.ResetName()
		return nil
	case documenttype.FieldIcon:
		m.ResetIcon()
		return nil
	case documenttype.FieldIsProtected:
		m.ResetIsProtected()
		return nil
	case documenttype.FieldIsDisabled:
		m.ResetIsDisabled()
		return nil
	}
	return fmt.Errorf("unknown DocumentType field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *DocumentTypeMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.space != nil {
		edges = append(edges, documenttype.EdgeSpace)
	}
	if m.attributes != nil {
		edges = append(edges, documenttype.EdgeAttributes)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *DocumentTypeMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case documenttype.EdgeSpace:
		if id := m.space; id != nil {
			return []ent.Value{*id}
		}
	case documenttype.EdgeAttributes:
		ids := make([]ent.Value, 0, len(m.attributes))
		for id := range m.attributes {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *DocumentTypeMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedattributes != nil {
		edges = append(edges, documenttype.EdgeAttributes)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *DocumentTypeMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case documenttype.EdgeAttributes:
		ids := make([]ent.Value, 0, len(m.removedattributes))
		for id := range m.removedattributes {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *DocumentTypeMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedspace {
		edges = append(edges, documenttype.EdgeSpace)
	}
	if m.clearedattributes {
		edges = append(edges, documenttype.EdgeAttributes)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *DocumentTypeMutation) EdgeCleared(name string) bool {
	switch name {
	case documenttype.EdgeSpace:
		return m.clearedspace
	case documenttype.EdgeAttributes:
		return m.clearedattributes
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *DocumentTypeMutation) ClearEdge(name string) error {
	switch name {
	case documenttype.EdgeSpace:
		m.ClearSpace()
		return nil
	}
	return fmt.Errorf("unknown DocumentType unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *DocumentTypeMutation) ResetEdge(name string) error {
	switch name {
	case documenttype.EdgeSpace:
		m.ResetSpace()
		return nil
	case documenttype.EdgeAttributes:
		m.ResetAttributes()
		return nil
	}
	return fmt.Errorf("unknown DocumentType edge %s", name)
}

// FileMutation represents an operation that mutates the File nodes in the graph.
type FileMutation struct {
	config
	op                         Op
	typ                        string
	id                         *int64
	deleted_at                 *time.Time
	public_id                  *entx.CIText
	created_at                 *time.Time
	updated_at                 *time.Time
	name                       *string
	is_directory               *bool
	notes                      *string
	modified_at                *time.Time
	indexed_at                 *time.Time
	indexing_completed_at      *time.Time
	is_in_inbox                *bool
	is_root_dir                *bool
	ocr_content                *string
	ocr_success_at             *time.Time
	ocr_retry_count            *int
	addocr_retry_count         *int
	ocr_last_tried_at          *time.Time
	clearedFields              map[string]struct{}
	deleter                    *int64
	cleareddeleter             bool
	creator                    *int64
	clearedcreator             bool
	updater                    *int64
	clearedupdater             bool
	space                      *int64
	clearedspace               bool
	versions                   map[int64]struct{}
	removedversions            map[int64]struct{}
	clearedversions            bool
	children                   map[int64]struct{}
	removedchildren            map[int64]struct{}
	clearedchildren            bool
	parent                     *int64
	clearedparent              bool
	document_type              *int64
	cleareddocument_type       bool
	tags                       map[int64]struct{}
	removedtags                map[int64]struct{}
	clearedtags                bool
	properties                 map[int64]struct{}
	removedproperties          map[int64]struct{}
	clearedproperties          bool
	tag_assignment             map[int64]struct{}
	removedtag_assignment      map[int64]struct{}
	clearedtag_assignment      bool
	property_assignment        map[int64]struct{}
	removedproperty_assignment map[int64]struct{}
	clearedproperty_assignment bool
	done                       bool
	oldValue                   func(context.Context) (*File, error)
	predicates                 []predicate.File
}

var _ ent.Mutation = (*FileMutation)(nil)

// fileOption allows management of the mutation configuration using functional options.
type fileOption func(*FileMutation)

// newFileMutation creates new mutation for the File entity.
func newFileMutation(c config, op Op, opts ...fileOption) *FileMutation {
	m := &FileMutation{
		config:        c,
		op:            op,
		typ:           TypeFile,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFileID sets the ID field of the mutation.
func withFileID(id int64) fileOption {
	return func(m *FileMutation) {
		var (
			err   error
			once  sync.Once
			value *File
		)
		m.oldValue = func(ctx context.Context) (*File, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().File.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFile sets the old File of the mutation.
func withFile(node *File) fileOption {
	return func(m *FileMutation) {
		m.oldValue = func(context.Context) (*File, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FileMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FileMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("enttenant: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of File entities.
func (m *FileMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FileMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FileMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().File.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetDeletedBy sets the "deleted_by" field.
func (m *FileMutation) SetDeletedBy(i int64) {
	m.deleter = &i
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *FileMutation) DeletedBy() (r int64, exists bool) {
	v := m.deleter
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldDeletedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *FileMutation) ClearDeletedBy() {
	m.deleter = nil
	m.clearedFields[file.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *FileMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[file.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *FileMutation) ResetDeletedBy() {
	m.deleter = nil
	delete(m.clearedFields, file.FieldDeletedBy)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *FileMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *FileMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *FileMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[file.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *FileMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[file.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *FileMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, file.FieldDeletedAt)
}

// SetPublicID sets the "public_id" field.
func (m *FileMutation) SetPublicID(et entx.CIText) {
	m.public_id = &et
}

// PublicID returns the value of the "public_id" field in the mutation.
func (m *FileMutation) PublicID() (r entx.CIText, exists bool) {
	v := m.public_id
	if v == nil {
		return
	}
	return *v, true
}

// OldPublicID returns the old "public_id" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldPublicID(ctx context.Context) (v entx.CIText, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPublicID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPublicID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPublicID: %w", err)
	}
	return oldValue.PublicID, nil
}

// ResetPublicID resets all changes to the "public_id" field.
func (m *FileMutation) ResetPublicID() {
	m.public_id = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *FileMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *FileMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *FileMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *FileMutation) SetCreatedBy(i int64) {
	m.creator = &i
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *FileMutation) CreatedBy() (r int64, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *FileMutation) ClearCreatedBy() {
	m.creator = nil
	m.clearedFields[file.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *FileMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[file.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *FileMutation) ResetCreatedBy() {
	m.creator = nil
	delete(m.clearedFields, file.FieldCreatedBy)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *FileMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *FileMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *FileMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *FileMutation) SetUpdatedBy(i int64) {
	m.updater = &i
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *FileMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updater
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *FileMutation) ClearUpdatedBy() {
	m.updater = nil
	m.clearedFields[file.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *FileMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[file.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *FileMutation) ResetUpdatedBy() {
	m.updater = nil
	delete(m.clearedFields, file.FieldUpdatedBy)
}

// SetSpaceID sets the "space_id" field.
func (m *FileMutation) SetSpaceID(i int64) {
	m.space = &i
}

// SpaceID returns the value of the "space_id" field in the mutation.
func (m *FileMutation) SpaceID() (r int64, exists bool) {
	v := m.space
	if v == nil {
		return
	}
	return *v, true
}

// OldSpaceID returns the old "space_id" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldSpaceID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSpaceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSpaceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSpaceID: %w", err)
	}
	return oldValue.SpaceID, nil
}

// ResetSpaceID resets all changes to the "space_id" field.
func (m *FileMutation) ResetSpaceID() {
	m.space = nil
}

// SetName sets the "name" field.
func (m *FileMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *FileMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *FileMutation) ResetName() {
	m.name = nil
}

// SetIsDirectory sets the "is_directory" field.
func (m *FileMutation) SetIsDirectory(b bool) {
	m.is_directory = &b
}

// IsDirectory returns the value of the "is_directory" field in the mutation.
func (m *FileMutation) IsDirectory() (r bool, exists bool) {
	v := m.is_directory
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDirectory returns the old "is_directory" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldIsDirectory(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDirectory is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDirectory requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDirectory: %w", err)
	}
	return oldValue.IsDirectory, nil
}

// ResetIsDirectory resets all changes to the "is_directory" field.
func (m *FileMutation) ResetIsDirectory() {
	m.is_directory = nil
}

// SetNotes sets the "notes" field.
func (m *FileMutation) SetNotes(s string) {
	m.notes = &s
}

// Notes returns the value of the "notes" field in the mutation.
func (m *FileMutation) Notes() (r string, exists bool) {
	v := m.notes
	if v == nil {
		return
	}
	return *v, true
}

// OldNotes returns the old "notes" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldNotes(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNotes is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNotes requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNotes: %w", err)
	}
	return oldValue.Notes, nil
}

// ClearNotes clears the value of the "notes" field.
func (m *FileMutation) ClearNotes() {
	m.notes = nil
	m.clearedFields[file.FieldNotes] = struct{}{}
}

// NotesCleared returns if the "notes" field was cleared in this mutation.
func (m *FileMutation) NotesCleared() bool {
	_, ok := m.clearedFields[file.FieldNotes]
	return ok
}

// ResetNotes resets all changes to the "notes" field.
func (m *FileMutation) ResetNotes() {
	m.notes = nil
	delete(m.clearedFields, file.FieldNotes)
}

// SetModifiedAt sets the "modified_at" field.
func (m *FileMutation) SetModifiedAt(t time.Time) {
	m.modified_at = &t
}

// ModifiedAt returns the value of the "modified_at" field in the mutation.
func (m *FileMutation) ModifiedAt() (r time.Time, exists bool) {
	v := m.modified_at
	if v == nil {
		return
	}
	return *v, true
}

// OldModifiedAt returns the old "modified_at" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldModifiedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldModifiedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldModifiedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldModifiedAt: %w", err)
	}
	return oldValue.ModifiedAt, nil
}

// ClearModifiedAt clears the value of the "modified_at" field.
func (m *FileMutation) ClearModifiedAt() {
	m.modified_at = nil
	m.clearedFields[file.FieldModifiedAt] = struct{}{}
}

// ModifiedAtCleared returns if the "modified_at" field was cleared in this mutation.
func (m *FileMutation) ModifiedAtCleared() bool {
	_, ok := m.clearedFields[file.FieldModifiedAt]
	return ok
}

// ResetModifiedAt resets all changes to the "modified_at" field.
func (m *FileMutation) ResetModifiedAt() {
	m.modified_at = nil
	delete(m.clearedFields, file.FieldModifiedAt)
}

// SetIndexedAt sets the "indexed_at" field.
func (m *FileMutation) SetIndexedAt(t time.Time) {
	m.indexed_at = &t
}

// IndexedAt returns the value of the "indexed_at" field in the mutation.
func (m *FileMutation) IndexedAt() (r time.Time, exists bool) {
	v := m.indexed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldIndexedAt returns the old "indexed_at" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldIndexedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIndexedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIndexedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIndexedAt: %w", err)
	}
	return oldValue.IndexedAt, nil
}

// ResetIndexedAt resets all changes to the "indexed_at" field.
func (m *FileMutation) ResetIndexedAt() {
	m.indexed_at = nil
}

// SetIndexingCompletedAt sets the "indexing_completed_at" field.
func (m *FileMutation) SetIndexingCompletedAt(t time.Time) {
	m.indexing_completed_at = &t
}

// IndexingCompletedAt returns the value of the "indexing_completed_at" field in the mutation.
func (m *FileMutation) IndexingCompletedAt() (r time.Time, exists bool) {
	v := m.indexing_completed_at
	if v == nil {
		return
	}
	return *v, true
}

// OldIndexingCompletedAt returns the old "indexing_completed_at" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldIndexingCompletedAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIndexingCompletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIndexingCompletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIndexingCompletedAt: %w", err)
	}
	return oldValue.IndexingCompletedAt, nil
}

// ClearIndexingCompletedAt clears the value of the "indexing_completed_at" field.
func (m *FileMutation) ClearIndexingCompletedAt() {
	m.indexing_completed_at = nil
	m.clearedFields[file.FieldIndexingCompletedAt] = struct{}{}
}

// IndexingCompletedAtCleared returns if the "indexing_completed_at" field was cleared in this mutation.
func (m *FileMutation) IndexingCompletedAtCleared() bool {
	_, ok := m.clearedFields[file.FieldIndexingCompletedAt]
	return ok
}

// ResetIndexingCompletedAt resets all changes to the "indexing_completed_at" field.
func (m *FileMutation) ResetIndexingCompletedAt() {
	m.indexing_completed_at = nil
	delete(m.clearedFields, file.FieldIndexingCompletedAt)
}

// SetParentID sets the "parent_id" field.
func (m *FileMutation) SetParentID(i int64) {
	m.parent = &i
}

// ParentID returns the value of the "parent_id" field in the mutation.
func (m *FileMutation) ParentID() (r int64, exists bool) {
	v := m.parent
	if v == nil {
		return
	}
	return *v, true
}

// OldParentID returns the old "parent_id" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldParentID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldParentID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldParentID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldParentID: %w", err)
	}
	return oldValue.ParentID, nil
}

// ClearParentID clears the value of the "parent_id" field.
func (m *FileMutation) ClearParentID() {
	m.parent = nil
	m.clearedFields[file.FieldParentID] = struct{}{}
}

// ParentIDCleared returns if the "parent_id" field was cleared in this mutation.
func (m *FileMutation) ParentIDCleared() bool {
	_, ok := m.clearedFields[file.FieldParentID]
	return ok
}

// ResetParentID resets all changes to the "parent_id" field.
func (m *FileMutation) ResetParentID() {
	m.parent = nil
	delete(m.clearedFields, file.FieldParentID)
}

// SetDocumentTypeID sets the "document_type_id" field.
func (m *FileMutation) SetDocumentTypeID(i int64) {
	m.document_type = &i
}

// DocumentTypeID returns the value of the "document_type_id" field in the mutation.
func (m *FileMutation) DocumentTypeID() (r int64, exists bool) {
	v := m.document_type
	if v == nil {
		return
	}
	return *v, true
}

// OldDocumentTypeID returns the old "document_type_id" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldDocumentTypeID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDocumentTypeID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDocumentTypeID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDocumentTypeID: %w", err)
	}
	return oldValue.DocumentTypeID, nil
}

// ClearDocumentTypeID clears the value of the "document_type_id" field.
func (m *FileMutation) ClearDocumentTypeID() {
	m.document_type = nil
	m.clearedFields[file.FieldDocumentTypeID] = struct{}{}
}

// DocumentTypeIDCleared returns if the "document_type_id" field was cleared in this mutation.
func (m *FileMutation) DocumentTypeIDCleared() bool {
	_, ok := m.clearedFields[file.FieldDocumentTypeID]
	return ok
}

// ResetDocumentTypeID resets all changes to the "document_type_id" field.
func (m *FileMutation) ResetDocumentTypeID() {
	m.document_type = nil
	delete(m.clearedFields, file.FieldDocumentTypeID)
}

// SetIsInInbox sets the "is_in_inbox" field.
func (m *FileMutation) SetIsInInbox(b bool) {
	m.is_in_inbox = &b
}

// IsInInbox returns the value of the "is_in_inbox" field in the mutation.
func (m *FileMutation) IsInInbox() (r bool, exists bool) {
	v := m.is_in_inbox
	if v == nil {
		return
	}
	return *v, true
}

// OldIsInInbox returns the old "is_in_inbox" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldIsInInbox(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsInInbox is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsInInbox requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsInInbox: %w", err)
	}
	return oldValue.IsInInbox, nil
}

// ResetIsInInbox resets all changes to the "is_in_inbox" field.
func (m *FileMutation) ResetIsInInbox() {
	m.is_in_inbox = nil
}

// SetIsRootDir sets the "is_root_dir" field.
func (m *FileMutation) SetIsRootDir(b bool) {
	m.is_root_dir = &b
}

// IsRootDir returns the value of the "is_root_dir" field in the mutation.
func (m *FileMutation) IsRootDir() (r bool, exists bool) {
	v := m.is_root_dir
	if v == nil {
		return
	}
	return *v, true
}

// OldIsRootDir returns the old "is_root_dir" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldIsRootDir(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsRootDir is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsRootDir requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsRootDir: %w", err)
	}
	return oldValue.IsRootDir, nil
}

// ResetIsRootDir resets all changes to the "is_root_dir" field.
func (m *FileMutation) ResetIsRootDir() {
	m.is_root_dir = nil
}

// SetOcrContent sets the "ocr_content" field.
func (m *FileMutation) SetOcrContent(s string) {
	m.ocr_content = &s
}

// OcrContent returns the value of the "ocr_content" field in the mutation.
func (m *FileMutation) OcrContent() (r string, exists bool) {
	v := m.ocr_content
	if v == nil {
		return
	}
	return *v, true
}

// OldOcrContent returns the old "ocr_content" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldOcrContent(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOcrContent is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOcrContent requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOcrContent: %w", err)
	}
	return oldValue.OcrContent, nil
}

// ResetOcrContent resets all changes to the "ocr_content" field.
func (m *FileMutation) ResetOcrContent() {
	m.ocr_content = nil
}

// SetOcrSuccessAt sets the "ocr_success_at" field.
func (m *FileMutation) SetOcrSuccessAt(t time.Time) {
	m.ocr_success_at = &t
}

// OcrSuccessAt returns the value of the "ocr_success_at" field in the mutation.
func (m *FileMutation) OcrSuccessAt() (r time.Time, exists bool) {
	v := m.ocr_success_at
	if v == nil {
		return
	}
	return *v, true
}

// OldOcrSuccessAt returns the old "ocr_success_at" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldOcrSuccessAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOcrSuccessAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOcrSuccessAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOcrSuccessAt: %w", err)
	}
	return oldValue.OcrSuccessAt, nil
}

// ClearOcrSuccessAt clears the value of the "ocr_success_at" field.
func (m *FileMutation) ClearOcrSuccessAt() {
	m.ocr_success_at = nil
	m.clearedFields[file.FieldOcrSuccessAt] = struct{}{}
}

// OcrSuccessAtCleared returns if the "ocr_success_at" field was cleared in this mutation.
func (m *FileMutation) OcrSuccessAtCleared() bool {
	_, ok := m.clearedFields[file.FieldOcrSuccessAt]
	return ok
}

// ResetOcrSuccessAt resets all changes to the "ocr_success_at" field.
func (m *FileMutation) ResetOcrSuccessAt() {
	m.ocr_success_at = nil
	delete(m.clearedFields, file.FieldOcrSuccessAt)
}

// SetOcrRetryCount sets the "ocr_retry_count" field.
func (m *FileMutation) SetOcrRetryCount(i int) {
	m.ocr_retry_count = &i
	m.addocr_retry_count = nil
}

// OcrRetryCount returns the value of the "ocr_retry_count" field in the mutation.
func (m *FileMutation) OcrRetryCount() (r int, exists bool) {
	v := m.ocr_retry_count
	if v == nil {
		return
	}
	return *v, true
}

// OldOcrRetryCount returns the old "ocr_retry_count" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldOcrRetryCount(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOcrRetryCount is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOcrRetryCount requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOcrRetryCount: %w", err)
	}
	return oldValue.OcrRetryCount, nil
}

// AddOcrRetryCount adds i to the "ocr_retry_count" field.
func (m *FileMutation) AddOcrRetryCount(i int) {
	if m.addocr_retry_count != nil {
		*m.addocr_retry_count += i
	} else {
		m.addocr_retry_count = &i
	}
}

// AddedOcrRetryCount returns the value that was added to the "ocr_retry_count" field in this mutation.
func (m *FileMutation) AddedOcrRetryCount() (r int, exists bool) {
	v := m.addocr_retry_count
	if v == nil {
		return
	}
	return *v, true
}

// ResetOcrRetryCount resets all changes to the "ocr_retry_count" field.
func (m *FileMutation) ResetOcrRetryCount() {
	m.ocr_retry_count = nil
	m.addocr_retry_count = nil
}

// SetOcrLastTriedAt sets the "ocr_last_tried_at" field.
func (m *FileMutation) SetOcrLastTriedAt(t time.Time) {
	m.ocr_last_tried_at = &t
}

// OcrLastTriedAt returns the value of the "ocr_last_tried_at" field in the mutation.
func (m *FileMutation) OcrLastTriedAt() (r time.Time, exists bool) {
	v := m.ocr_last_tried_at
	if v == nil {
		return
	}
	return *v, true
}

// OldOcrLastTriedAt returns the old "ocr_last_tried_at" field's value of the File entity.
// If the File object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FileMutation) OldOcrLastTriedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldOcrLastTriedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldOcrLastTriedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOcrLastTriedAt: %w", err)
	}
	return oldValue.OcrLastTriedAt, nil
}

// ResetOcrLastTriedAt resets all changes to the "ocr_last_tried_at" field.
func (m *FileMutation) ResetOcrLastTriedAt() {
	m.ocr_last_tried_at = nil
}

// SetDeleterID sets the "deleter" edge to the User entity by id.
func (m *FileMutation) SetDeleterID(id int64) {
	m.deleter = &id
}

// ClearDeleter clears the "deleter" edge to the User entity.
func (m *FileMutation) ClearDeleter() {
	m.cleareddeleter = true
	m.clearedFields[file.FieldDeletedBy] = struct{}{}
}

// DeleterCleared reports if the "deleter" edge to the User entity was cleared.
func (m *FileMutation) DeleterCleared() bool {
	return m.DeletedByCleared() || m.cleareddeleter
}

// DeleterID returns the "deleter" edge ID in the mutation.
func (m *FileMutation) DeleterID() (id int64, exists bool) {
	if m.deleter != nil {
		return *m.deleter, true
	}
	return
}

// DeleterIDs returns the "deleter" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DeleterID instead. It exists only for internal usage by the builders.
func (m *FileMutation) DeleterIDs() (ids []int64) {
	if id := m.deleter; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDeleter resets all changes to the "deleter" edge.
func (m *FileMutation) ResetDeleter() {
	m.deleter = nil
	m.cleareddeleter = false
}

// SetCreatorID sets the "creator" edge to the User entity by id.
func (m *FileMutation) SetCreatorID(id int64) {
	m.creator = &id
}

// ClearCreator clears the "creator" edge to the User entity.
func (m *FileMutation) ClearCreator() {
	m.clearedcreator = true
	m.clearedFields[file.FieldCreatedBy] = struct{}{}
}

// CreatorCleared reports if the "creator" edge to the User entity was cleared.
func (m *FileMutation) CreatorCleared() bool {
	return m.CreatedByCleared() || m.clearedcreator
}

// CreatorID returns the "creator" edge ID in the mutation.
func (m *FileMutation) CreatorID() (id int64, exists bool) {
	if m.creator != nil {
		return *m.creator, true
	}
	return
}

// CreatorIDs returns the "creator" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreatorID instead. It exists only for internal usage by the builders.
func (m *FileMutation) CreatorIDs() (ids []int64) {
	if id := m.creator; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreator resets all changes to the "creator" edge.
func (m *FileMutation) ResetCreator() {
	m.creator = nil
	m.clearedcreator = false
}

// SetUpdaterID sets the "updater" edge to the User entity by id.
func (m *FileMutation) SetUpdaterID(id int64) {
	m.updater = &id
}

// ClearUpdater clears the "updater" edge to the User entity.
func (m *FileMutation) ClearUpdater() {
	m.clearedupdater = true
	m.clearedFields[file.FieldUpdatedBy] = struct{}{}
}

// UpdaterCleared reports if the "updater" edge to the User entity was cleared.
func (m *FileMutation) UpdaterCleared() bool {
	return m.UpdatedByCleared() || m.clearedupdater
}

// UpdaterID returns the "updater" edge ID in the mutation.
func (m *FileMutation) UpdaterID() (id int64, exists bool) {
	if m.updater != nil {
		return *m.updater, true
	}
	return
}

// UpdaterIDs returns the "updater" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UpdaterID instead. It exists only for internal usage by the builders.
func (m *FileMutation) UpdaterIDs() (ids []int64) {
	if id := m.updater; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUpdater resets all changes to the "updater" edge.
func (m *FileMutation) ResetUpdater() {
	m.updater = nil
	m.clearedupdater = false
}

// ClearSpace clears the "space" edge to the Space entity.
func (m *FileMutation) ClearSpace() {
	m.clearedspace = true
	m.clearedFields[file.FieldSpaceID] = struct{}{}
}

// SpaceCleared reports if the "space" edge to the Space entity was cleared.
func (m *FileMutation) SpaceCleared() bool {
	return m.clearedspace
}

// SpaceIDs returns the "space" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SpaceID instead. It exists only for internal usage by the builders.
func (m *FileMutation) SpaceIDs() (ids []int64) {
	if id := m.space; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSpace resets all changes to the "space" edge.
func (m *FileMutation) ResetSpace() {
	m.space = nil
	m.clearedspace = false
}

// AddVersionIDs adds the "versions" edge to the StoredFile entity by ids.
func (m *FileMutation) AddVersionIDs(ids ...int64) {
	if m.versions == nil {
		m.versions = make(map[int64]struct{})
	}
	for i := range ids {
		m.versions[ids[i]] = struct{}{}
	}
}

// ClearVersions clears the "versions" edge to the StoredFile entity.
func (m *FileMutation) ClearVersions() {
	m.clearedversions = true
}

// VersionsCleared reports if the "versions" edge to the StoredFile entity was cleared.
func (m *FileMutation) VersionsCleared() bool {
	return m.clearedversions
}

// RemoveVersionIDs removes the "versions" edge to the StoredFile entity by IDs.
func (m *FileMutation) RemoveVersionIDs(ids ...int64) {
	if m.removedversions == nil {
		m.removedversions = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.versions, ids[i])
		m.removedversions[ids[i]] = struct{}{}
	}
}

// RemovedVersions returns the removed IDs of the "versions" edge to the StoredFile entity.
func (m *FileMutation) RemovedVersionsIDs() (ids []int64) {
	for id := range m.removedversions {
		ids = append(ids, id)
	}
	return
}

// VersionsIDs returns the "versions" edge IDs in the mutation.
func (m *FileMutation) VersionsIDs() (ids []int64) {
	for id := range m.versions {
		ids = append(ids, id)
	}
	return
}

// ResetVersions resets all changes to the "versions" edge.
func (m *FileMutation) ResetVersions() {
	m.versions = nil
	m.clearedversions = false
	m.removedversions = nil
}

// AddChildIDs adds the "children" edge to the File entity by ids.
func (m *FileMutation) AddChildIDs(ids ...int64) {
	if m.children == nil {
		m.children = make(map[int64]struct{})
	}
	for i := range ids {
		m.children[ids[i]] = struct{}{}
	}
}

// ClearChildren clears the "children" edge to the File entity.
func (m *FileMutation) ClearChildren() {
	m.clearedchildren = true
}

// ChildrenCleared reports if the "children" edge to the File entity was cleared.
func (m *FileMutation) ChildrenCleared() bool {
	return m.clearedchildren
}

// RemoveChildIDs removes the "children" edge to the File entity by IDs.
func (m *FileMutation) RemoveChildIDs(ids ...int64) {
	if m.removedchildren == nil {
		m.removedchildren = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.children, ids[i])
		m.removedchildren[ids[i]] = struct{}{}
	}
}

// RemovedChildren returns the removed IDs of the "children" edge to the File entity.
func (m *FileMutation) RemovedChildrenIDs() (ids []int64) {
	for id := range m.removedchildren {
		ids = append(ids, id)
	}
	return
}

// ChildrenIDs returns the "children" edge IDs in the mutation.
func (m *FileMutation) ChildrenIDs() (ids []int64) {
	for id := range m.children {
		ids = append(ids, id)
	}
	return
}

// ResetChildren resets all changes to the "children" edge.
func (m *FileMutation) ResetChildren() {
	m.children = nil
	m.clearedchildren = false
	m.removedchildren = nil
}

// ClearParent clears the "parent" edge to the File entity.
func (m *FileMutation) ClearParent() {
	m.clearedparent = true
	m.clearedFields[file.FieldParentID] = struct{}{}
}

// ParentCleared reports if the "parent" edge to the File entity was cleared.
func (m *FileMutation) ParentCleared() bool {
	return m.ParentIDCleared() || m.clearedparent
}

// ParentIDs returns the "parent" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// ParentID instead. It exists only for internal usage by the builders.
func (m *FileMutation) ParentIDs() (ids []int64) {
	if id := m.parent; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetParent resets all changes to the "parent" edge.
func (m *FileMutation) ResetParent() {
	m.parent = nil
	m.clearedparent = false
}

// ClearDocumentType clears the "document_type" edge to the DocumentType entity.
func (m *FileMutation) ClearDocumentType() {
	m.cleareddocument_type = true
	m.clearedFields[file.FieldDocumentTypeID] = struct{}{}
}

// DocumentTypeCleared reports if the "document_type" edge to the DocumentType entity was cleared.
func (m *FileMutation) DocumentTypeCleared() bool {
	return m.DocumentTypeIDCleared() || m.cleareddocument_type
}

// DocumentTypeIDs returns the "document_type" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DocumentTypeID instead. It exists only for internal usage by the builders.
func (m *FileMutation) DocumentTypeIDs() (ids []int64) {
	if id := m.document_type; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDocumentType resets all changes to the "document_type" edge.
func (m *FileMutation) ResetDocumentType() {
	m.document_type = nil
	m.cleareddocument_type = false
}

// AddTagIDs adds the "tags" edge to the Tag entity by ids.
func (m *FileMutation) AddTagIDs(ids ...int64) {
	if m.tags == nil {
		m.tags = make(map[int64]struct{})
	}
	for i := range ids {
		m.tags[ids[i]] = struct{}{}
	}
}

// ClearTags clears the "tags" edge to the Tag entity.
func (m *FileMutation) ClearTags() {
	m.clearedtags = true
}

// TagsCleared reports if the "tags" edge to the Tag entity was cleared.
func (m *FileMutation) TagsCleared() bool {
	return m.clearedtags
}

// RemoveTagIDs removes the "tags" edge to the Tag entity by IDs.
func (m *FileMutation) RemoveTagIDs(ids ...int64) {
	if m.removedtags == nil {
		m.removedtags = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.tags, ids[i])
		m.removedtags[ids[i]] = struct{}{}
	}
}

// RemovedTags returns the removed IDs of the "tags" edge to the Tag entity.
func (m *FileMutation) RemovedTagsIDs() (ids []int64) {
	for id := range m.removedtags {
		ids = append(ids, id)
	}
	return
}

// TagsIDs returns the "tags" edge IDs in the mutation.
func (m *FileMutation) TagsIDs() (ids []int64) {
	for id := range m.tags {
		ids = append(ids, id)
	}
	return
}

// ResetTags resets all changes to the "tags" edge.
func (m *FileMutation) ResetTags() {
	m.tags = nil
	m.clearedtags = false
	m.removedtags = nil
}

// AddPropertyIDs adds the "properties" edge to the Property entity by ids.
func (m *FileMutation) AddPropertyIDs(ids ...int64) {
	if m.properties == nil {
		m.properties = make(map[int64]struct{})
	}
	for i := range ids {
		m.properties[ids[i]] = struct{}{}
	}
}

// ClearProperties clears the "properties" edge to the Property entity.
func (m *FileMutation) ClearProperties() {
	m.clearedproperties = true
}

// PropertiesCleared reports if the "properties" edge to the Property entity was cleared.
func (m *FileMutation) PropertiesCleared() bool {
	return m.clearedproperties
}

// RemovePropertyIDs removes the "properties" edge to the Property entity by IDs.
func (m *FileMutation) RemovePropertyIDs(ids ...int64) {
	if m.removedproperties == nil {
		m.removedproperties = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.properties, ids[i])
		m.removedproperties[ids[i]] = struct{}{}
	}
}

// RemovedProperties returns the removed IDs of the "properties" edge to the Property entity.
func (m *FileMutation) RemovedPropertiesIDs() (ids []int64) {
	for id := range m.removedproperties {
		ids = append(ids, id)
	}
	return
}

// PropertiesIDs returns the "properties" edge IDs in the mutation.
func (m *FileMutation) PropertiesIDs() (ids []int64) {
	for id := range m.properties {
		ids = append(ids, id)
	}
	return
}

// ResetProperties resets all changes to the "properties" edge.
func (m *FileMutation) ResetProperties() {
	m.properties = nil
	m.clearedproperties = false
	m.removedproperties = nil
}

// AddTagAssignmentIDs adds the "tag_assignment" edge to the TagAssignment entity by ids.
func (m *FileMutation) AddTagAssignmentIDs(ids ...int64) {
	if m.tag_assignment == nil {
		m.tag_assignment = make(map[int64]struct{})
	}
	for i := range ids {
		m.tag_assignment[ids[i]] = struct{}{}
	}
}

// ClearTagAssignment clears the "tag_assignment" edge to the TagAssignment entity.
func (m *FileMutation) ClearTagAssignment() {
	m.clearedtag_assignment = true
}

// TagAssignmentCleared reports if the "tag_assignment" edge to the TagAssignment entity was cleared.
func (m *FileMutation) TagAssignmentCleared() bool {
	return m.clearedtag_assignment
}

// RemoveTagAssignmentIDs removes the "tag_assignment" edge to the TagAssignment entity by IDs.
func (m *FileMutation) RemoveTagAssignmentIDs(ids ...int64) {
	if m.removedtag_assignment == nil {
		m.removedtag_assignment = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.tag_assignment, ids[i])
		m.removedtag_assignment[ids[i]] = struct{}{}
	}
}

// RemovedTagAssignment returns the removed IDs of the "tag_assignment" edge to the TagAssignment entity.
func (m *FileMutation) RemovedTagAssignmentIDs() (ids []int64) {
	for id := range m.removedtag_assignment {
		ids = append(ids, id)
	}
	return
}

// TagAssignmentIDs returns the "tag_assignment" edge IDs in the mutation.
func (m *FileMutation) TagAssignmentIDs() (ids []int64) {
	for id := range m.tag_assignment {
		ids = append(ids, id)
	}
	return
}

// ResetTagAssignment resets all changes to the "tag_assignment" edge.
func (m *FileMutation) ResetTagAssignment() {
	m.tag_assignment = nil
	m.clearedtag_assignment = false
	m.removedtag_assignment = nil
}

// AddPropertyAssignmentIDs adds the "property_assignment" edge to the FilePropertyAssignment entity by ids.
func (m *FileMutation) AddPropertyAssignmentIDs(ids ...int64) {
	if m.property_assignment == nil {
		m.property_assignment = make(map[int64]struct{})
	}
	for i := range ids {
		m.property_assignment[ids[i]] = struct{}{}
	}
}

// ClearPropertyAssignment clears the "property_assignment" edge to the FilePropertyAssignment entity.
func (m *FileMutation) ClearPropertyAssignment() {
	m.clearedproperty_assignment = true
}

// PropertyAssignmentCleared reports if the "property_assignment" edge to the FilePropertyAssignment entity was cleared.
func (m *FileMutation) PropertyAssignmentCleared() bool {
	return m.clearedproperty_assignment
}

// RemovePropertyAssignmentIDs removes the "property_assignment" edge to the FilePropertyAssignment entity by IDs.
func (m *FileMutation) RemovePropertyAssignmentIDs(ids ...int64) {
	if m.removedproperty_assignment == nil {
		m.removedproperty_assignment = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.property_assignment, ids[i])
		m.removedproperty_assignment[ids[i]] = struct{}{}
	}
}

// RemovedPropertyAssignment returns the removed IDs of the "property_assignment" edge to the FilePropertyAssignment entity.
func (m *FileMutation) RemovedPropertyAssignmentIDs() (ids []int64) {
	for id := range m.removedproperty_assignment {
		ids = append(ids, id)
	}
	return
}

// PropertyAssignmentIDs returns the "property_assignment" edge IDs in the mutation.
func (m *FileMutation) PropertyAssignmentIDs() (ids []int64) {
	for id := range m.property_assignment {
		ids = append(ids, id)
	}
	return
}

// ResetPropertyAssignment resets all changes to the "property_assignment" edge.
func (m *FileMutation) ResetPropertyAssignment() {
	m.property_assignment = nil
	m.clearedproperty_assignment = false
	m.removedproperty_assignment = nil
}

// Where appends a list predicates to the FileMutation builder.
func (m *FileMutation) Where(ps ...predicate.File) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FileMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FileMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.File, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FileMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FileMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (File).
func (m *FileMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FileMutation) Fields() []string {
	fields := make([]string, 0, 22)
	if m.deleter != nil {
		fields = append(fields, file.FieldDeletedBy)
	}
	if m.deleted_at != nil {
		fields = append(fields, file.FieldDeletedAt)
	}
	if m.public_id != nil {
		fields = append(fields, file.FieldPublicID)
	}
	if m.created_at != nil {
		fields = append(fields, file.FieldCreatedAt)
	}
	if m.creator != nil {
		fields = append(fields, file.FieldCreatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, file.FieldUpdatedAt)
	}
	if m.updater != nil {
		fields = append(fields, file.FieldUpdatedBy)
	}
	if m.space != nil {
		fields = append(fields, file.FieldSpaceID)
	}
	if m.name != nil {
		fields = append(fields, file.FieldName)
	}
	if m.is_directory != nil {
		fields = append(fields, file.FieldIsDirectory)
	}
	if m.notes != nil {
		fields = append(fields, file.FieldNotes)
	}
	if m.modified_at != nil {
		fields = append(fields, file.FieldModifiedAt)
	}
	if m.indexed_at != nil {
		fields = append(fields, file.FieldIndexedAt)
	}
	if m.indexing_completed_at != nil {
		fields = append(fields, file.FieldIndexingCompletedAt)
	}
	if m.parent != nil {
		fields = append(fields, file.FieldParentID)
	}
	if m.document_type != nil {
		fields = append(fields, file.FieldDocumentTypeID)
	}
	if m.is_in_inbox != nil {
		fields = append(fields, file.FieldIsInInbox)
	}
	if m.is_root_dir != nil {
		fields = append(fields, file.FieldIsRootDir)
	}
	if m.ocr_content != nil {
		fields = append(fields, file.FieldOcrContent)
	}
	if m.ocr_success_at != nil {
		fields = append(fields, file.FieldOcrSuccessAt)
	}
	if m.ocr_retry_count != nil {
		fields = append(fields, file.FieldOcrRetryCount)
	}
	if m.ocr_last_tried_at != nil {
		fields = append(fields, file.FieldOcrLastTriedAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FileMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case file.FieldDeletedBy:
		return m.DeletedBy()
	case file.FieldDeletedAt:
		return m.DeletedAt()
	case file.FieldPublicID:
		return m.PublicID()
	case file.FieldCreatedAt:
		return m.CreatedAt()
	case file.FieldCreatedBy:
		return m.CreatedBy()
	case file.FieldUpdatedAt:
		return m.UpdatedAt()
	case file.FieldUpdatedBy:
		return m.UpdatedBy()
	case file.FieldSpaceID:
		return m.SpaceID()
	case file.FieldName:
		return m.Name()
	case file.FieldIsDirectory:
		return m.IsDirectory()
	case file.FieldNotes:
		return m.Notes()
	case file.FieldModifiedAt:
		return m.ModifiedAt()
	case file.FieldIndexedAt:
		return m.IndexedAt()
	case file.FieldIndexingCompletedAt:
		return m.IndexingCompletedAt()
	case file.FieldParentID:
		return m.ParentID()
	case file.FieldDocumentTypeID:
		return m.DocumentTypeID()
	case file.FieldIsInInbox:
		return m.IsInInbox()
	case file.FieldIsRootDir:
		return m.IsRootDir()
	case file.FieldOcrContent:
		return m.OcrContent()
	case file.FieldOcrSuccessAt:
		return m.OcrSuccessAt()
	case file.FieldOcrRetryCount:
		return m.OcrRetryCount()
	case file.FieldOcrLastTriedAt:
		return m.OcrLastTriedAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FileMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case file.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case file.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case file.FieldPublicID:
		return m.OldPublicID(ctx)
	case file.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case file.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case file.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case file.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case file.FieldSpaceID:
		return m.OldSpaceID(ctx)
	case file.FieldName:
		return m.OldName(ctx)
	case file.FieldIsDirectory:
		return m.OldIsDirectory(ctx)
	case file.FieldNotes:
		return m.OldNotes(ctx)
	case file.FieldModifiedAt:
		return m.OldModifiedAt(ctx)
	case file.FieldIndexedAt:
		return m.OldIndexedAt(ctx)
	case file.FieldIndexingCompletedAt:
		return m.OldIndexingCompletedAt(ctx)
	case file.FieldParentID:
		return m.OldParentID(ctx)
	case file.FieldDocumentTypeID:
		return m.OldDocumentTypeID(ctx)
	case file.FieldIsInInbox:
		return m.OldIsInInbox(ctx)
	case file.FieldIsRootDir:
		return m.OldIsRootDir(ctx)
	case file.FieldOcrContent:
		return m.OldOcrContent(ctx)
	case file.FieldOcrSuccessAt:
		return m.OldOcrSuccessAt(ctx)
	case file.FieldOcrRetryCount:
		return m.OldOcrRetryCount(ctx)
	case file.FieldOcrLastTriedAt:
		return m.OldOcrLastTriedAt(ctx)
	}
	return nil, fmt.Errorf("unknown File field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FileMutation) SetField(name string, value ent.Value) error {
	switch name {
	case file.FieldDeletedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case file.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case file.FieldPublicID:
		v, ok := value.(entx.CIText)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublicID(v)
		return nil
	case file.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case file.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case file.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case file.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case file.FieldSpaceID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSpaceID(v)
		return nil
	case file.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case file.FieldIsDirectory:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDirectory(v)
		return nil
	case file.FieldNotes:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNotes(v)
		return nil
	case file.FieldModifiedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetModifiedAt(v)
		return nil
	case file.FieldIndexedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIndexedAt(v)
		return nil
	case file.FieldIndexingCompletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIndexingCompletedAt(v)
		return nil
	case file.FieldParentID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetParentID(v)
		return nil
	case file.FieldDocumentTypeID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDocumentTypeID(v)
		return nil
	case file.FieldIsInInbox:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsInInbox(v)
		return nil
	case file.FieldIsRootDir:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsRootDir(v)
		return nil
	case file.FieldOcrContent:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOcrContent(v)
		return nil
	case file.FieldOcrSuccessAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOcrSuccessAt(v)
		return nil
	case file.FieldOcrRetryCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOcrRetryCount(v)
		return nil
	case file.FieldOcrLastTriedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOcrLastTriedAt(v)
		return nil
	}
	return fmt.Errorf("unknown File field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FileMutation) AddedFields() []string {
	var fields []string
	if m.addocr_retry_count != nil {
		fields = append(fields, file.FieldOcrRetryCount)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FileMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case file.FieldOcrRetryCount:
		return m.AddedOcrRetryCount()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FileMutation) AddField(name string, value ent.Value) error {
	switch name {
	case file.FieldOcrRetryCount:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddOcrRetryCount(v)
		return nil
	}
	return fmt.Errorf("unknown File numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FileMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(file.FieldDeletedBy) {
		fields = append(fields, file.FieldDeletedBy)
	}
	if m.FieldCleared(file.FieldDeletedAt) {
		fields = append(fields, file.FieldDeletedAt)
	}
	if m.FieldCleared(file.FieldCreatedBy) {
		fields = append(fields, file.FieldCreatedBy)
	}
	if m.FieldCleared(file.FieldUpdatedBy) {
		fields = append(fields, file.FieldUpdatedBy)
	}
	if m.FieldCleared(file.FieldNotes) {
		fields = append(fields, file.FieldNotes)
	}
	if m.FieldCleared(file.FieldModifiedAt) {
		fields = append(fields, file.FieldModifiedAt)
	}
	if m.FieldCleared(file.FieldIndexingCompletedAt) {
		fields = append(fields, file.FieldIndexingCompletedAt)
	}
	if m.FieldCleared(file.FieldParentID) {
		fields = append(fields, file.FieldParentID)
	}
	if m.FieldCleared(file.FieldDocumentTypeID) {
		fields = append(fields, file.FieldDocumentTypeID)
	}
	if m.FieldCleared(file.FieldOcrSuccessAt) {
		fields = append(fields, file.FieldOcrSuccessAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FileMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FileMutation) ClearField(name string) error {
	switch name {
	case file.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case file.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case file.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case file.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case file.FieldNotes:
		m.ClearNotes()
		return nil
	case file.FieldModifiedAt:
		m.ClearModifiedAt()
		return nil
	case file.FieldIndexingCompletedAt:
		m.ClearIndexingCompletedAt()
		return nil
	case file.FieldParentID:
		m.ClearParentID()
		return nil
	case file.FieldDocumentTypeID:
		m.ClearDocumentTypeID()
		return nil
	case file.FieldOcrSuccessAt:
		m.ClearOcrSuccessAt()
		return nil
	}
	return fmt.Errorf("unknown File nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FileMutation) ResetField(name string) error {
	switch name {
	case file.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case file.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case file.FieldPublicID:
		m.ResetPublicID()
		return nil
	case file.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case file.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case file.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case file.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case file.FieldSpaceID:
		m.ResetSpaceID()
		return nil
	case file.FieldName:
		m.ResetName()
		return nil
	case file.FieldIsDirectory:
		m.ResetIsDirectory()
		return nil
	case file.FieldNotes:
		m.ResetNotes()
		return nil
	case file.FieldModifiedAt:
		m.ResetModifiedAt()
		return nil
	case file.FieldIndexedAt:
		m.ResetIndexedAt()
		return nil
	case file.FieldIndexingCompletedAt:
		m.ResetIndexingCompletedAt()
		return nil
	case file.FieldParentID:
		m.ResetParentID()
		return nil
	case file.FieldDocumentTypeID:
		m.ResetDocumentTypeID()
		return nil
	case file.FieldIsInInbox:
		m.ResetIsInInbox()
		return nil
	case file.FieldIsRootDir:
		m.ResetIsRootDir()
		return nil
	case file.FieldOcrContent:
		m.ResetOcrContent()
		return nil
	case file.FieldOcrSuccessAt:
		m.ResetOcrSuccessAt()
		return nil
	case file.FieldOcrRetryCount:
		m.ResetOcrRetryCount()
		return nil
	case file.FieldOcrLastTriedAt:
		m.ResetOcrLastTriedAt()
		return nil
	}
	return fmt.Errorf("unknown File field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FileMutation) AddedEdges() []string {
	edges := make([]string, 0, 12)
	if m.deleter != nil {
		edges = append(edges, file.EdgeDeleter)
	}
	if m.creator != nil {
		edges = append(edges, file.EdgeCreator)
	}
	if m.updater != nil {
		edges = append(edges, file.EdgeUpdater)
	}
	if m.space != nil {
		edges = append(edges, file.EdgeSpace)
	}
	if m.versions != nil {
		edges = append(edges, file.EdgeVersions)
	}
	if m.children != nil {
		edges = append(edges, file.EdgeChildren)
	}
	if m.parent != nil {
		edges = append(edges, file.EdgeParent)
	}
	if m.document_type != nil {
		edges = append(edges, file.EdgeDocumentType)
	}
	if m.tags != nil {
		edges = append(edges, file.EdgeTags)
	}
	if m.properties != nil {
		edges = append(edges, file.EdgeProperties)
	}
	if m.tag_assignment != nil {
		edges = append(edges, file.EdgeTagAssignment)
	}
	if m.property_assignment != nil {
		edges = append(edges, file.EdgePropertyAssignment)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FileMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case file.EdgeDeleter:
		if id := m.deleter; id != nil {
			return []ent.Value{*id}
		}
	case file.EdgeCreator:
		if id := m.creator; id != nil {
			return []ent.Value{*id}
		}
	case file.EdgeUpdater:
		if id := m.updater; id != nil {
			return []ent.Value{*id}
		}
	case file.EdgeSpace:
		if id := m.space; id != nil {
			return []ent.Value{*id}
		}
	case file.EdgeVersions:
		ids := make([]ent.Value, 0, len(m.versions))
		for id := range m.versions {
			ids = append(ids, id)
		}
		return ids
	case file.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.children))
		for id := range m.children {
			ids = append(ids, id)
		}
		return ids
	case file.EdgeParent:
		if id := m.parent; id != nil {
			return []ent.Value{*id}
		}
	case file.EdgeDocumentType:
		if id := m.document_type; id != nil {
			return []ent.Value{*id}
		}
	case file.EdgeTags:
		ids := make([]ent.Value, 0, len(m.tags))
		for id := range m.tags {
			ids = append(ids, id)
		}
		return ids
	case file.EdgeProperties:
		ids := make([]ent.Value, 0, len(m.properties))
		for id := range m.properties {
			ids = append(ids, id)
		}
		return ids
	case file.EdgeTagAssignment:
		ids := make([]ent.Value, 0, len(m.tag_assignment))
		for id := range m.tag_assignment {
			ids = append(ids, id)
		}
		return ids
	case file.EdgePropertyAssignment:
		ids := make([]ent.Value, 0, len(m.property_assignment))
		for id := range m.property_assignment {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FileMutation) RemovedEdges() []string {
	edges := make([]string, 0, 12)
	if m.removedversions != nil {
		edges = append(edges, file.EdgeVersions)
	}
	if m.removedchildren != nil {
		edges = append(edges, file.EdgeChildren)
	}
	if m.removedtags != nil {
		edges = append(edges, file.EdgeTags)
	}
	if m.removedproperties != nil {
		edges = append(edges, file.EdgeProperties)
	}
	if m.removedtag_assignment != nil {
		edges = append(edges, file.EdgeTagAssignment)
	}
	if m.removedproperty_assignment != nil {
		edges = append(edges, file.EdgePropertyAssignment)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FileMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case file.EdgeVersions:
		ids := make([]ent.Value, 0, len(m.removedversions))
		for id := range m.removedversions {
			ids = append(ids, id)
		}
		return ids
	case file.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.removedchildren))
		for id := range m.removedchildren {
			ids = append(ids, id)
		}
		return ids
	case file.EdgeTags:
		ids := make([]ent.Value, 0, len(m.removedtags))
		for id := range m.removedtags {
			ids = append(ids, id)
		}
		return ids
	case file.EdgeProperties:
		ids := make([]ent.Value, 0, len(m.removedproperties))
		for id := range m.removedproperties {
			ids = append(ids, id)
		}
		return ids
	case file.EdgeTagAssignment:
		ids := make([]ent.Value, 0, len(m.removedtag_assignment))
		for id := range m.removedtag_assignment {
			ids = append(ids, id)
		}
		return ids
	case file.EdgePropertyAssignment:
		ids := make([]ent.Value, 0, len(m.removedproperty_assignment))
		for id := range m.removedproperty_assignment {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FileMutation) ClearedEdges() []string {
	edges := make([]string, 0, 12)
	if m.cleareddeleter {
		edges = append(edges, file.EdgeDeleter)
	}
	if m.clearedcreator {
		edges = append(edges, file.EdgeCreator)
	}
	if m.clearedupdater {
		edges = append(edges, file.EdgeUpdater)
	}
	if m.clearedspace {
		edges = append(edges, file.EdgeSpace)
	}
	if m.clearedversions {
		edges = append(edges, file.EdgeVersions)
	}
	if m.clearedchildren {
		edges = append(edges, file.EdgeChildren)
	}
	if m.clearedparent {
		edges = append(edges, file.EdgeParent)
	}
	if m.cleareddocument_type {
		edges = append(edges, file.EdgeDocumentType)
	}
	if m.clearedtags {
		edges = append(edges, file.EdgeTags)
	}
	if m.clearedproperties {
		edges = append(edges, file.EdgeProperties)
	}
	if m.clearedtag_assignment {
		edges = append(edges, file.EdgeTagAssignment)
	}
	if m.clearedproperty_assignment {
		edges = append(edges, file.EdgePropertyAssignment)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FileMutation) EdgeCleared(name string) bool {
	switch name {
	case file.EdgeDeleter:
		return m.cleareddeleter
	case file.EdgeCreator:
		return m.clearedcreator
	case file.EdgeUpdater:
		return m.clearedupdater
	case file.EdgeSpace:
		return m.clearedspace
	case file.EdgeVersions:
		return m.clearedversions
	case file.EdgeChildren:
		return m.clearedchildren
	case file.EdgeParent:
		return m.clearedparent
	case file.EdgeDocumentType:
		return m.cleareddocument_type
	case file.EdgeTags:
		return m.clearedtags
	case file.EdgeProperties:
		return m.clearedproperties
	case file.EdgeTagAssignment:
		return m.clearedtag_assignment
	case file.EdgePropertyAssignment:
		return m.clearedproperty_assignment
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FileMutation) ClearEdge(name string) error {
	switch name {
	case file.EdgeDeleter:
		m.ClearDeleter()
		return nil
	case file.EdgeCreator:
		m.ClearCreator()
		return nil
	case file.EdgeUpdater:
		m.ClearUpdater()
		return nil
	case file.EdgeSpace:
		m.ClearSpace()
		return nil
	case file.EdgeParent:
		m.ClearParent()
		return nil
	case file.EdgeDocumentType:
		m.ClearDocumentType()
		return nil
	}
	return fmt.Errorf("unknown File unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FileMutation) ResetEdge(name string) error {
	switch name {
	case file.EdgeDeleter:
		m.ResetDeleter()
		return nil
	case file.EdgeCreator:
		m.ResetCreator()
		return nil
	case file.EdgeUpdater:
		m.ResetUpdater()
		return nil
	case file.EdgeSpace:
		m.ResetSpace()
		return nil
	case file.EdgeVersions:
		m.ResetVersions()
		return nil
	case file.EdgeChildren:
		m.ResetChildren()
		return nil
	case file.EdgeParent:
		m.ResetParent()
		return nil
	case file.EdgeDocumentType:
		m.ResetDocumentType()
		return nil
	case file.EdgeTags:
		m.ResetTags()
		return nil
	case file.EdgeProperties:
		m.ResetProperties()
		return nil
	case file.EdgeTagAssignment:
		m.ResetTagAssignment()
		return nil
	case file.EdgePropertyAssignment:
		m.ResetPropertyAssignment()
		return nil
	}
	return fmt.Errorf("unknown File edge %s", name)
}

// FilePropertyAssignmentMutation represents an operation that mutates the FilePropertyAssignment nodes in the graph.
type FilePropertyAssignmentMutation struct {
	config
	op              Op
	typ             string
	id              *int64
	text_value      *string
	number_value    *int
	addnumber_value *int
	date_value      *timex.Date
	bool_value      *bool
	clearedFields   map[string]struct{}
	space           *int64
	clearedspace    bool
	file            *int64
	clearedfile     bool
	property        *int64
	clearedproperty bool
	done            bool
	oldValue        func(context.Context) (*FilePropertyAssignment, error)
	predicates      []predicate.FilePropertyAssignment
}

var _ ent.Mutation = (*FilePropertyAssignmentMutation)(nil)

// filepropertyassignmentOption allows management of the mutation configuration using functional options.
type filepropertyassignmentOption func(*FilePropertyAssignmentMutation)

// newFilePropertyAssignmentMutation creates new mutation for the FilePropertyAssignment entity.
func newFilePropertyAssignmentMutation(c config, op Op, opts ...filepropertyassignmentOption) *FilePropertyAssignmentMutation {
	m := &FilePropertyAssignmentMutation{
		config:        c,
		op:            op,
		typ:           TypeFilePropertyAssignment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withFilePropertyAssignmentID sets the ID field of the mutation.
func withFilePropertyAssignmentID(id int64) filepropertyassignmentOption {
	return func(m *FilePropertyAssignmentMutation) {
		var (
			err   error
			once  sync.Once
			value *FilePropertyAssignment
		)
		m.oldValue = func(ctx context.Context) (*FilePropertyAssignment, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().FilePropertyAssignment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withFilePropertyAssignment sets the old FilePropertyAssignment of the mutation.
func withFilePropertyAssignment(node *FilePropertyAssignment) filepropertyassignmentOption {
	return func(m *FilePropertyAssignmentMutation) {
		m.oldValue = func(context.Context) (*FilePropertyAssignment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m FilePropertyAssignmentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m FilePropertyAssignmentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("enttenant: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of FilePropertyAssignment entities.
func (m *FilePropertyAssignmentMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *FilePropertyAssignmentMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *FilePropertyAssignmentMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().FilePropertyAssignment.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSpaceID sets the "space_id" field.
func (m *FilePropertyAssignmentMutation) SetSpaceID(i int64) {
	m.space = &i
}

// SpaceID returns the value of the "space_id" field in the mutation.
func (m *FilePropertyAssignmentMutation) SpaceID() (r int64, exists bool) {
	v := m.space
	if v == nil {
		return
	}
	return *v, true
}

// OldSpaceID returns the old "space_id" field's value of the FilePropertyAssignment entity.
// If the FilePropertyAssignment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FilePropertyAssignmentMutation) OldSpaceID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSpaceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSpaceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSpaceID: %w", err)
	}
	return oldValue.SpaceID, nil
}

// ResetSpaceID resets all changes to the "space_id" field.
func (m *FilePropertyAssignmentMutation) ResetSpaceID() {
	m.space = nil
}

// SetFileID sets the "file_id" field.
func (m *FilePropertyAssignmentMutation) SetFileID(i int64) {
	m.file = &i
}

// FileID returns the value of the "file_id" field in the mutation.
func (m *FilePropertyAssignmentMutation) FileID() (r int64, exists bool) {
	v := m.file
	if v == nil {
		return
	}
	return *v, true
}

// OldFileID returns the old "file_id" field's value of the FilePropertyAssignment entity.
// If the FilePropertyAssignment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FilePropertyAssignmentMutation) OldFileID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFileID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFileID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFileID: %w", err)
	}
	return oldValue.FileID, nil
}

// ResetFileID resets all changes to the "file_id" field.
func (m *FilePropertyAssignmentMutation) ResetFileID() {
	m.file = nil
}

// SetPropertyID sets the "property_id" field.
func (m *FilePropertyAssignmentMutation) SetPropertyID(i int64) {
	m.property = &i
}

// PropertyID returns the value of the "property_id" field in the mutation.
func (m *FilePropertyAssignmentMutation) PropertyID() (r int64, exists bool) {
	v := m.property
	if v == nil {
		return
	}
	return *v, true
}

// OldPropertyID returns the old "property_id" field's value of the FilePropertyAssignment entity.
// If the FilePropertyAssignment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FilePropertyAssignmentMutation) OldPropertyID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPropertyID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPropertyID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPropertyID: %w", err)
	}
	return oldValue.PropertyID, nil
}

// ResetPropertyID resets all changes to the "property_id" field.
func (m *FilePropertyAssignmentMutation) ResetPropertyID() {
	m.property = nil
}

// SetTextValue sets the "text_value" field.
func (m *FilePropertyAssignmentMutation) SetTextValue(s string) {
	m.text_value = &s
}

// TextValue returns the value of the "text_value" field in the mutation.
func (m *FilePropertyAssignmentMutation) TextValue() (r string, exists bool) {
	v := m.text_value
	if v == nil {
		return
	}
	return *v, true
}

// OldTextValue returns the old "text_value" field's value of the FilePropertyAssignment entity.
// If the FilePropertyAssignment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FilePropertyAssignmentMutation) OldTextValue(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTextValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTextValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTextValue: %w", err)
	}
	return oldValue.TextValue, nil
}

// ClearTextValue clears the value of the "text_value" field.
func (m *FilePropertyAssignmentMutation) ClearTextValue() {
	m.text_value = nil
	m.clearedFields[filepropertyassignment.FieldTextValue] = struct{}{}
}

// TextValueCleared returns if the "text_value" field was cleared in this mutation.
func (m *FilePropertyAssignmentMutation) TextValueCleared() bool {
	_, ok := m.clearedFields[filepropertyassignment.FieldTextValue]
	return ok
}

// ResetTextValue resets all changes to the "text_value" field.
func (m *FilePropertyAssignmentMutation) ResetTextValue() {
	m.text_value = nil
	delete(m.clearedFields, filepropertyassignment.FieldTextValue)
}

// SetNumberValue sets the "number_value" field.
func (m *FilePropertyAssignmentMutation) SetNumberValue(i int) {
	m.number_value = &i
	m.addnumber_value = nil
}

// NumberValue returns the value of the "number_value" field in the mutation.
func (m *FilePropertyAssignmentMutation) NumberValue() (r int, exists bool) {
	v := m.number_value
	if v == nil {
		return
	}
	return *v, true
}

// OldNumberValue returns the old "number_value" field's value of the FilePropertyAssignment entity.
// If the FilePropertyAssignment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FilePropertyAssignmentMutation) OldNumberValue(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldNumberValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldNumberValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNumberValue: %w", err)
	}
	return oldValue.NumberValue, nil
}

// AddNumberValue adds i to the "number_value" field.
func (m *FilePropertyAssignmentMutation) AddNumberValue(i int) {
	if m.addnumber_value != nil {
		*m.addnumber_value += i
	} else {
		m.addnumber_value = &i
	}
}

// AddedNumberValue returns the value that was added to the "number_value" field in this mutation.
func (m *FilePropertyAssignmentMutation) AddedNumberValue() (r int, exists bool) {
	v := m.addnumber_value
	if v == nil {
		return
	}
	return *v, true
}

// ClearNumberValue clears the value of the "number_value" field.
func (m *FilePropertyAssignmentMutation) ClearNumberValue() {
	m.number_value = nil
	m.addnumber_value = nil
	m.clearedFields[filepropertyassignment.FieldNumberValue] = struct{}{}
}

// NumberValueCleared returns if the "number_value" field was cleared in this mutation.
func (m *FilePropertyAssignmentMutation) NumberValueCleared() bool {
	_, ok := m.clearedFields[filepropertyassignment.FieldNumberValue]
	return ok
}

// ResetNumberValue resets all changes to the "number_value" field.
func (m *FilePropertyAssignmentMutation) ResetNumberValue() {
	m.number_value = nil
	m.addnumber_value = nil
	delete(m.clearedFields, filepropertyassignment.FieldNumberValue)
}

// SetDateValue sets the "date_value" field.
func (m *FilePropertyAssignmentMutation) SetDateValue(t timex.Date) {
	m.date_value = &t
}

// DateValue returns the value of the "date_value" field in the mutation.
func (m *FilePropertyAssignmentMutation) DateValue() (r timex.Date, exists bool) {
	v := m.date_value
	if v == nil {
		return
	}
	return *v, true
}

// OldDateValue returns the old "date_value" field's value of the FilePropertyAssignment entity.
// If the FilePropertyAssignment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FilePropertyAssignmentMutation) OldDateValue(ctx context.Context) (v timex.Date, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDateValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDateValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDateValue: %w", err)
	}
	return oldValue.DateValue, nil
}

// ClearDateValue clears the value of the "date_value" field.
func (m *FilePropertyAssignmentMutation) ClearDateValue() {
	m.date_value = nil
	m.clearedFields[filepropertyassignment.FieldDateValue] = struct{}{}
}

// DateValueCleared returns if the "date_value" field was cleared in this mutation.
func (m *FilePropertyAssignmentMutation) DateValueCleared() bool {
	_, ok := m.clearedFields[filepropertyassignment.FieldDateValue]
	return ok
}

// ResetDateValue resets all changes to the "date_value" field.
func (m *FilePropertyAssignmentMutation) ResetDateValue() {
	m.date_value = nil
	delete(m.clearedFields, filepropertyassignment.FieldDateValue)
}

// SetBoolValue sets the "bool_value" field.
func (m *FilePropertyAssignmentMutation) SetBoolValue(b bool) {
	m.bool_value = &b
}

// BoolValue returns the value of the "bool_value" field in the mutation.
func (m *FilePropertyAssignmentMutation) BoolValue() (r bool, exists bool) {
	v := m.bool_value
	if v == nil {
		return
	}
	return *v, true
}

// OldBoolValue returns the old "bool_value" field's value of the FilePropertyAssignment entity.
// If the FilePropertyAssignment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *FilePropertyAssignmentMutation) OldBoolValue(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBoolValue is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBoolValue requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBoolValue: %w", err)
	}
	return oldValue.BoolValue, nil
}

// ClearBoolValue clears the value of the "bool_value" field.
func (m *FilePropertyAssignmentMutation) ClearBoolValue() {
	m.bool_value = nil
	m.clearedFields[filepropertyassignment.FieldBoolValue] = struct{}{}
}

// BoolValueCleared returns if the "bool_value" field was cleared in this mutation.
func (m *FilePropertyAssignmentMutation) BoolValueCleared() bool {
	_, ok := m.clearedFields[filepropertyassignment.FieldBoolValue]
	return ok
}

// ResetBoolValue resets all changes to the "bool_value" field.
func (m *FilePropertyAssignmentMutation) ResetBoolValue() {
	m.bool_value = nil
	delete(m.clearedFields, filepropertyassignment.FieldBoolValue)
}

// ClearSpace clears the "space" edge to the Space entity.
func (m *FilePropertyAssignmentMutation) ClearSpace() {
	m.clearedspace = true
	m.clearedFields[filepropertyassignment.FieldSpaceID] = struct{}{}
}

// SpaceCleared reports if the "space" edge to the Space entity was cleared.
func (m *FilePropertyAssignmentMutation) SpaceCleared() bool {
	return m.clearedspace
}

// SpaceIDs returns the "space" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SpaceID instead. It exists only for internal usage by the builders.
func (m *FilePropertyAssignmentMutation) SpaceIDs() (ids []int64) {
	if id := m.space; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSpace resets all changes to the "space" edge.
func (m *FilePropertyAssignmentMutation) ResetSpace() {
	m.space = nil
	m.clearedspace = false
}

// ClearFile clears the "file" edge to the File entity.
func (m *FilePropertyAssignmentMutation) ClearFile() {
	m.clearedfile = true
	m.clearedFields[filepropertyassignment.FieldFileID] = struct{}{}
}

// FileCleared reports if the "file" edge to the File entity was cleared.
func (m *FilePropertyAssignmentMutation) FileCleared() bool {
	return m.clearedfile
}

// FileIDs returns the "file" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FileID instead. It exists only for internal usage by the builders.
func (m *FilePropertyAssignmentMutation) FileIDs() (ids []int64) {
	if id := m.file; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFile resets all changes to the "file" edge.
func (m *FilePropertyAssignmentMutation) ResetFile() {
	m.file = nil
	m.clearedfile = false
}

// ClearProperty clears the "property" edge to the Property entity.
func (m *FilePropertyAssignmentMutation) ClearProperty() {
	m.clearedproperty = true
	m.clearedFields[filepropertyassignment.FieldPropertyID] = struct{}{}
}

// PropertyCleared reports if the "property" edge to the Property entity was cleared.
func (m *FilePropertyAssignmentMutation) PropertyCleared() bool {
	return m.clearedproperty
}

// PropertyIDs returns the "property" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// PropertyID instead. It exists only for internal usage by the builders.
func (m *FilePropertyAssignmentMutation) PropertyIDs() (ids []int64) {
	if id := m.property; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetProperty resets all changes to the "property" edge.
func (m *FilePropertyAssignmentMutation) ResetProperty() {
	m.property = nil
	m.clearedproperty = false
}

// Where appends a list predicates to the FilePropertyAssignmentMutation builder.
func (m *FilePropertyAssignmentMutation) Where(ps ...predicate.FilePropertyAssignment) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the FilePropertyAssignmentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *FilePropertyAssignmentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.FilePropertyAssignment, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *FilePropertyAssignmentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *FilePropertyAssignmentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (FilePropertyAssignment).
func (m *FilePropertyAssignmentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *FilePropertyAssignmentMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.space != nil {
		fields = append(fields, filepropertyassignment.FieldSpaceID)
	}
	if m.file != nil {
		fields = append(fields, filepropertyassignment.FieldFileID)
	}
	if m.property != nil {
		fields = append(fields, filepropertyassignment.FieldPropertyID)
	}
	if m.text_value != nil {
		fields = append(fields, filepropertyassignment.FieldTextValue)
	}
	if m.number_value != nil {
		fields = append(fields, filepropertyassignment.FieldNumberValue)
	}
	if m.date_value != nil {
		fields = append(fields, filepropertyassignment.FieldDateValue)
	}
	if m.bool_value != nil {
		fields = append(fields, filepropertyassignment.FieldBoolValue)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *FilePropertyAssignmentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case filepropertyassignment.FieldSpaceID:
		return m.SpaceID()
	case filepropertyassignment.FieldFileID:
		return m.FileID()
	case filepropertyassignment.FieldPropertyID:
		return m.PropertyID()
	case filepropertyassignment.FieldTextValue:
		return m.TextValue()
	case filepropertyassignment.FieldNumberValue:
		return m.NumberValue()
	case filepropertyassignment.FieldDateValue:
		return m.DateValue()
	case filepropertyassignment.FieldBoolValue:
		return m.BoolValue()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *FilePropertyAssignmentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case filepropertyassignment.FieldSpaceID:
		return m.OldSpaceID(ctx)
	case filepropertyassignment.FieldFileID:
		return m.OldFileID(ctx)
	case filepropertyassignment.FieldPropertyID:
		return m.OldPropertyID(ctx)
	case filepropertyassignment.FieldTextValue:
		return m.OldTextValue(ctx)
	case filepropertyassignment.FieldNumberValue:
		return m.OldNumberValue(ctx)
	case filepropertyassignment.FieldDateValue:
		return m.OldDateValue(ctx)
	case filepropertyassignment.FieldBoolValue:
		return m.OldBoolValue(ctx)
	}
	return nil, fmt.Errorf("unknown FilePropertyAssignment field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FilePropertyAssignmentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case filepropertyassignment.FieldSpaceID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSpaceID(v)
		return nil
	case filepropertyassignment.FieldFileID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFileID(v)
		return nil
	case filepropertyassignment.FieldPropertyID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPropertyID(v)
		return nil
	case filepropertyassignment.FieldTextValue:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTextValue(v)
		return nil
	case filepropertyassignment.FieldNumberValue:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNumberValue(v)
		return nil
	case filepropertyassignment.FieldDateValue:
		v, ok := value.(timex.Date)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDateValue(v)
		return nil
	case filepropertyassignment.FieldBoolValue:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBoolValue(v)
		return nil
	}
	return fmt.Errorf("unknown FilePropertyAssignment field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *FilePropertyAssignmentMutation) AddedFields() []string {
	var fields []string
	if m.addnumber_value != nil {
		fields = append(fields, filepropertyassignment.FieldNumberValue)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *FilePropertyAssignmentMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case filepropertyassignment.FieldNumberValue:
		return m.AddedNumberValue()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *FilePropertyAssignmentMutation) AddField(name string, value ent.Value) error {
	switch name {
	case filepropertyassignment.FieldNumberValue:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddNumberValue(v)
		return nil
	}
	return fmt.Errorf("unknown FilePropertyAssignment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *FilePropertyAssignmentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(filepropertyassignment.FieldTextValue) {
		fields = append(fields, filepropertyassignment.FieldTextValue)
	}
	if m.FieldCleared(filepropertyassignment.FieldNumberValue) {
		fields = append(fields, filepropertyassignment.FieldNumberValue)
	}
	if m.FieldCleared(filepropertyassignment.FieldDateValue) {
		fields = append(fields, filepropertyassignment.FieldDateValue)
	}
	if m.FieldCleared(filepropertyassignment.FieldBoolValue) {
		fields = append(fields, filepropertyassignment.FieldBoolValue)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *FilePropertyAssignmentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *FilePropertyAssignmentMutation) ClearField(name string) error {
	switch name {
	case filepropertyassignment.FieldTextValue:
		m.ClearTextValue()
		return nil
	case filepropertyassignment.FieldNumberValue:
		m.ClearNumberValue()
		return nil
	case filepropertyassignment.FieldDateValue:
		m.ClearDateValue()
		return nil
	case filepropertyassignment.FieldBoolValue:
		m.ClearBoolValue()
		return nil
	}
	return fmt.Errorf("unknown FilePropertyAssignment nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *FilePropertyAssignmentMutation) ResetField(name string) error {
	switch name {
	case filepropertyassignment.FieldSpaceID:
		m.ResetSpaceID()
		return nil
	case filepropertyassignment.FieldFileID:
		m.ResetFileID()
		return nil
	case filepropertyassignment.FieldPropertyID:
		m.ResetPropertyID()
		return nil
	case filepropertyassignment.FieldTextValue:
		m.ResetTextValue()
		return nil
	case filepropertyassignment.FieldNumberValue:
		m.ResetNumberValue()
		return nil
	case filepropertyassignment.FieldDateValue:
		m.ResetDateValue()
		return nil
	case filepropertyassignment.FieldBoolValue:
		m.ResetBoolValue()
		return nil
	}
	return fmt.Errorf("unknown FilePropertyAssignment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *FilePropertyAssignmentMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.space != nil {
		edges = append(edges, filepropertyassignment.EdgeSpace)
	}
	if m.file != nil {
		edges = append(edges, filepropertyassignment.EdgeFile)
	}
	if m.property != nil {
		edges = append(edges, filepropertyassignment.EdgeProperty)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *FilePropertyAssignmentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case filepropertyassignment.EdgeSpace:
		if id := m.space; id != nil {
			return []ent.Value{*id}
		}
	case filepropertyassignment.EdgeFile:
		if id := m.file; id != nil {
			return []ent.Value{*id}
		}
	case filepropertyassignment.EdgeProperty:
		if id := m.property; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *FilePropertyAssignmentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *FilePropertyAssignmentMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *FilePropertyAssignmentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedspace {
		edges = append(edges, filepropertyassignment.EdgeSpace)
	}
	if m.clearedfile {
		edges = append(edges, filepropertyassignment.EdgeFile)
	}
	if m.clearedproperty {
		edges = append(edges, filepropertyassignment.EdgeProperty)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *FilePropertyAssignmentMutation) EdgeCleared(name string) bool {
	switch name {
	case filepropertyassignment.EdgeSpace:
		return m.clearedspace
	case filepropertyassignment.EdgeFile:
		return m.clearedfile
	case filepropertyassignment.EdgeProperty:
		return m.clearedproperty
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *FilePropertyAssignmentMutation) ClearEdge(name string) error {
	switch name {
	case filepropertyassignment.EdgeSpace:
		m.ClearSpace()
		return nil
	case filepropertyassignment.EdgeFile:
		m.ClearFile()
		return nil
	case filepropertyassignment.EdgeProperty:
		m.ClearProperty()
		return nil
	}
	return fmt.Errorf("unknown FilePropertyAssignment unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *FilePropertyAssignmentMutation) ResetEdge(name string) error {
	switch name {
	case filepropertyassignment.EdgeSpace:
		m.ResetSpace()
		return nil
	case filepropertyassignment.EdgeFile:
		m.ResetFile()
		return nil
	case filepropertyassignment.EdgeProperty:
		m.ResetProperty()
		return nil
	}
	return fmt.Errorf("unknown FilePropertyAssignment edge %s", name)
}

// PropertyMutation represents an operation that mutates the Property nodes in the graph.
type PropertyMutation struct {
	config
	op                      Op
	typ                     string
	id                      *int64
	name                    *string
	_type                   *fieldtype.FieldType
	unit                    *string
	clearedFields           map[string]struct{}
	space                   *int64
	clearedspace            bool
	files                   map[int64]struct{}
	removedfiles            map[int64]struct{}
	clearedfiles            bool
	file_assignments        map[int64]struct{}
	removedfile_assignments map[int64]struct{}
	clearedfile_assignments bool
	done                    bool
	oldValue                func(context.Context) (*Property, error)
	predicates              []predicate.Property
}

var _ ent.Mutation = (*PropertyMutation)(nil)

// propertyOption allows management of the mutation configuration using functional options.
type propertyOption func(*PropertyMutation)

// newPropertyMutation creates new mutation for the Property entity.
func newPropertyMutation(c config, op Op, opts ...propertyOption) *PropertyMutation {
	m := &PropertyMutation{
		config:        c,
		op:            op,
		typ:           TypeProperty,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPropertyID sets the ID field of the mutation.
func withPropertyID(id int64) propertyOption {
	return func(m *PropertyMutation) {
		var (
			err   error
			once  sync.Once
			value *Property
		)
		m.oldValue = func(ctx context.Context) (*Property, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Property.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withProperty sets the old Property of the mutation.
func withProperty(node *Property) propertyOption {
	return func(m *PropertyMutation) {
		m.oldValue = func(context.Context) (*Property, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PropertyMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PropertyMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("enttenant: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Property entities.
func (m *PropertyMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *PropertyMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *PropertyMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Property.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSpaceID sets the "space_id" field.
func (m *PropertyMutation) SetSpaceID(i int64) {
	m.space = &i
}

// SpaceID returns the value of the "space_id" field in the mutation.
func (m *PropertyMutation) SpaceID() (r int64, exists bool) {
	v := m.space
	if v == nil {
		return
	}
	return *v, true
}

// OldSpaceID returns the old "space_id" field's value of the Property entity.
// If the Property object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PropertyMutation) OldSpaceID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSpaceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSpaceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSpaceID: %w", err)
	}
	return oldValue.SpaceID, nil
}

// ResetSpaceID resets all changes to the "space_id" field.
func (m *PropertyMutation) ResetSpaceID() {
	m.space = nil
}

// SetName sets the "name" field.
func (m *PropertyMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *PropertyMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Property entity.
// If the Property object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PropertyMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *PropertyMutation) ResetName() {
	m.name = nil
}

// SetType sets the "type" field.
func (m *PropertyMutation) SetType(ft fieldtype.FieldType) {
	m._type = &ft
}

// GetType returns the value of the "type" field in the mutation.
func (m *PropertyMutation) GetType() (r fieldtype.FieldType, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Property entity.
// If the Property object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PropertyMutation) OldType(ctx context.Context) (v fieldtype.FieldType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *PropertyMutation) ResetType() {
	m._type = nil
}

// SetUnit sets the "unit" field.
func (m *PropertyMutation) SetUnit(s string) {
	m.unit = &s
}

// Unit returns the value of the "unit" field in the mutation.
func (m *PropertyMutation) Unit() (r string, exists bool) {
	v := m.unit
	if v == nil {
		return
	}
	return *v, true
}

// OldUnit returns the old "unit" field's value of the Property entity.
// If the Property object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *PropertyMutation) OldUnit(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUnit is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUnit requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUnit: %w", err)
	}
	return oldValue.Unit, nil
}

// ResetUnit resets all changes to the "unit" field.
func (m *PropertyMutation) ResetUnit() {
	m.unit = nil
}

// ClearSpace clears the "space" edge to the Space entity.
func (m *PropertyMutation) ClearSpace() {
	m.clearedspace = true
	m.clearedFields[property.FieldSpaceID] = struct{}{}
}

// SpaceCleared reports if the "space" edge to the Space entity was cleared.
func (m *PropertyMutation) SpaceCleared() bool {
	return m.clearedspace
}

// SpaceIDs returns the "space" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SpaceID instead. It exists only for internal usage by the builders.
func (m *PropertyMutation) SpaceIDs() (ids []int64) {
	if id := m.space; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSpace resets all changes to the "space" edge.
func (m *PropertyMutation) ResetSpace() {
	m.space = nil
	m.clearedspace = false
}

// AddFileIDs adds the "files" edge to the File entity by ids.
func (m *PropertyMutation) AddFileIDs(ids ...int64) {
	if m.files == nil {
		m.files = make(map[int64]struct{})
	}
	for i := range ids {
		m.files[ids[i]] = struct{}{}
	}
}

// ClearFiles clears the "files" edge to the File entity.
func (m *PropertyMutation) ClearFiles() {
	m.clearedfiles = true
}

// FilesCleared reports if the "files" edge to the File entity was cleared.
func (m *PropertyMutation) FilesCleared() bool {
	return m.clearedfiles
}

// RemoveFileIDs removes the "files" edge to the File entity by IDs.
func (m *PropertyMutation) RemoveFileIDs(ids ...int64) {
	if m.removedfiles == nil {
		m.removedfiles = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.files, ids[i])
		m.removedfiles[ids[i]] = struct{}{}
	}
}

// RemovedFiles returns the removed IDs of the "files" edge to the File entity.
func (m *PropertyMutation) RemovedFilesIDs() (ids []int64) {
	for id := range m.removedfiles {
		ids = append(ids, id)
	}
	return
}

// FilesIDs returns the "files" edge IDs in the mutation.
func (m *PropertyMutation) FilesIDs() (ids []int64) {
	for id := range m.files {
		ids = append(ids, id)
	}
	return
}

// ResetFiles resets all changes to the "files" edge.
func (m *PropertyMutation) ResetFiles() {
	m.files = nil
	m.clearedfiles = false
	m.removedfiles = nil
}

// AddFileAssignmentIDs adds the "file_assignments" edge to the FilePropertyAssignment entity by ids.
func (m *PropertyMutation) AddFileAssignmentIDs(ids ...int64) {
	if m.file_assignments == nil {
		m.file_assignments = make(map[int64]struct{})
	}
	for i := range ids {
		m.file_assignments[ids[i]] = struct{}{}
	}
}

// ClearFileAssignments clears the "file_assignments" edge to the FilePropertyAssignment entity.
func (m *PropertyMutation) ClearFileAssignments() {
	m.clearedfile_assignments = true
}

// FileAssignmentsCleared reports if the "file_assignments" edge to the FilePropertyAssignment entity was cleared.
func (m *PropertyMutation) FileAssignmentsCleared() bool {
	return m.clearedfile_assignments
}

// RemoveFileAssignmentIDs removes the "file_assignments" edge to the FilePropertyAssignment entity by IDs.
func (m *PropertyMutation) RemoveFileAssignmentIDs(ids ...int64) {
	if m.removedfile_assignments == nil {
		m.removedfile_assignments = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.file_assignments, ids[i])
		m.removedfile_assignments[ids[i]] = struct{}{}
	}
}

// RemovedFileAssignments returns the removed IDs of the "file_assignments" edge to the FilePropertyAssignment entity.
func (m *PropertyMutation) RemovedFileAssignmentsIDs() (ids []int64) {
	for id := range m.removedfile_assignments {
		ids = append(ids, id)
	}
	return
}

// FileAssignmentsIDs returns the "file_assignments" edge IDs in the mutation.
func (m *PropertyMutation) FileAssignmentsIDs() (ids []int64) {
	for id := range m.file_assignments {
		ids = append(ids, id)
	}
	return
}

// ResetFileAssignments resets all changes to the "file_assignments" edge.
func (m *PropertyMutation) ResetFileAssignments() {
	m.file_assignments = nil
	m.clearedfile_assignments = false
	m.removedfile_assignments = nil
}

// Where appends a list predicates to the PropertyMutation builder.
func (m *PropertyMutation) Where(ps ...predicate.Property) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the PropertyMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *PropertyMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Property, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *PropertyMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *PropertyMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Property).
func (m *PropertyMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *PropertyMutation) Fields() []string {
	fields := make([]string, 0, 4)
	if m.space != nil {
		fields = append(fields, property.FieldSpaceID)
	}
	if m.name != nil {
		fields = append(fields, property.FieldName)
	}
	if m._type != nil {
		fields = append(fields, property.FieldType)
	}
	if m.unit != nil {
		fields = append(fields, property.FieldUnit)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *PropertyMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case property.FieldSpaceID:
		return m.SpaceID()
	case property.FieldName:
		return m.Name()
	case property.FieldType:
		return m.GetType()
	case property.FieldUnit:
		return m.Unit()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *PropertyMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case property.FieldSpaceID:
		return m.OldSpaceID(ctx)
	case property.FieldName:
		return m.OldName(ctx)
	case property.FieldType:
		return m.OldType(ctx)
	case property.FieldUnit:
		return m.OldUnit(ctx)
	}
	return nil, fmt.Errorf("unknown Property field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PropertyMutation) SetField(name string, value ent.Value) error {
	switch name {
	case property.FieldSpaceID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSpaceID(v)
		return nil
	case property.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case property.FieldType:
		v, ok := value.(fieldtype.FieldType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case property.FieldUnit:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUnit(v)
		return nil
	}
	return fmt.Errorf("unknown Property field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *PropertyMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *PropertyMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *PropertyMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Property numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *PropertyMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *PropertyMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *PropertyMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Property nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *PropertyMutation) ResetField(name string) error {
	switch name {
	case property.FieldSpaceID:
		m.ResetSpaceID()
		return nil
	case property.FieldName:
		m.ResetName()
		return nil
	case property.FieldType:
		m.ResetType()
		return nil
	case property.FieldUnit:
		m.ResetUnit()
		return nil
	}
	return fmt.Errorf("unknown Property field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *PropertyMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.space != nil {
		edges = append(edges, property.EdgeSpace)
	}
	if m.files != nil {
		edges = append(edges, property.EdgeFiles)
	}
	if m.file_assignments != nil {
		edges = append(edges, property.EdgeFileAssignments)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *PropertyMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case property.EdgeSpace:
		if id := m.space; id != nil {
			return []ent.Value{*id}
		}
	case property.EdgeFiles:
		ids := make([]ent.Value, 0, len(m.files))
		for id := range m.files {
			ids = append(ids, id)
		}
		return ids
	case property.EdgeFileAssignments:
		ids := make([]ent.Value, 0, len(m.file_assignments))
		for id := range m.file_assignments {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *PropertyMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedfiles != nil {
		edges = append(edges, property.EdgeFiles)
	}
	if m.removedfile_assignments != nil {
		edges = append(edges, property.EdgeFileAssignments)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *PropertyMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case property.EdgeFiles:
		ids := make([]ent.Value, 0, len(m.removedfiles))
		for id := range m.removedfiles {
			ids = append(ids, id)
		}
		return ids
	case property.EdgeFileAssignments:
		ids := make([]ent.Value, 0, len(m.removedfile_assignments))
		for id := range m.removedfile_assignments {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *PropertyMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedspace {
		edges = append(edges, property.EdgeSpace)
	}
	if m.clearedfiles {
		edges = append(edges, property.EdgeFiles)
	}
	if m.clearedfile_assignments {
		edges = append(edges, property.EdgeFileAssignments)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *PropertyMutation) EdgeCleared(name string) bool {
	switch name {
	case property.EdgeSpace:
		return m.clearedspace
	case property.EdgeFiles:
		return m.clearedfiles
	case property.EdgeFileAssignments:
		return m.clearedfile_assignments
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *PropertyMutation) ClearEdge(name string) error {
	switch name {
	case property.EdgeSpace:
		m.ClearSpace()
		return nil
	}
	return fmt.Errorf("unknown Property unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *PropertyMutation) ResetEdge(name string) error {
	switch name {
	case property.EdgeSpace:
		m.ResetSpace()
		return nil
	case property.EdgeFiles:
		m.ResetFiles()
		return nil
	case property.EdgeFileAssignments:
		m.ResetFileAssignments()
		return nil
	}
	return fmt.Errorf("unknown Property edge %s", name)
}

// SpaceMutation represents an operation that mutates the Space nodes in the graph.
type SpaceMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int64
	public_id              *entx.CIText
	deleted_at             *time.Time
	name                   *string
	icon                   *string
	description            *string
	is_folder_mode         *bool
	clearedFields          map[string]struct{}
	deleter                *int64
	cleareddeleter         bool
	files                  map[int64]struct{}
	removedfiles           map[int64]struct{}
	clearedfiles           bool
	users                  map[int64]struct{}
	removedusers           map[int64]struct{}
	clearedusers           bool
	tags                   map[int64]struct{}
	removedtags            map[int64]struct{}
	clearedtags            bool
	document_types         map[int64]struct{}
	removeddocument_types  map[int64]struct{}
	cleareddocument_types  bool
	properties             map[int64]struct{}
	removedproperties      map[int64]struct{}
	clearedproperties      bool
	user_assignment        map[int64]struct{}
	removeduser_assignment map[int64]struct{}
	cleareduser_assignment bool
	done                   bool
	oldValue               func(context.Context) (*Space, error)
	predicates             []predicate.Space
}

var _ ent.Mutation = (*SpaceMutation)(nil)

// spaceOption allows management of the mutation configuration using functional options.
type spaceOption func(*SpaceMutation)

// newSpaceMutation creates new mutation for the Space entity.
func newSpaceMutation(c config, op Op, opts ...spaceOption) *SpaceMutation {
	m := &SpaceMutation{
		config:        c,
		op:            op,
		typ:           TypeSpace,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSpaceID sets the ID field of the mutation.
func withSpaceID(id int64) spaceOption {
	return func(m *SpaceMutation) {
		var (
			err   error
			once  sync.Once
			value *Space
		)
		m.oldValue = func(ctx context.Context) (*Space, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Space.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSpace sets the old Space of the mutation.
func withSpace(node *Space) spaceOption {
	return func(m *SpaceMutation) {
		m.oldValue = func(context.Context) (*Space, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SpaceMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SpaceMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("enttenant: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Space entities.
func (m *SpaceMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SpaceMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SpaceMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Space.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetPublicID sets the "public_id" field.
func (m *SpaceMutation) SetPublicID(et entx.CIText) {
	m.public_id = &et
}

// PublicID returns the value of the "public_id" field in the mutation.
func (m *SpaceMutation) PublicID() (r entx.CIText, exists bool) {
	v := m.public_id
	if v == nil {
		return
	}
	return *v, true
}

// OldPublicID returns the old "public_id" field's value of the Space entity.
// If the Space object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpaceMutation) OldPublicID(ctx context.Context) (v entx.CIText, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPublicID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPublicID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPublicID: %w", err)
	}
	return oldValue.PublicID, nil
}

// ResetPublicID resets all changes to the "public_id" field.
func (m *SpaceMutation) ResetPublicID() {
	m.public_id = nil
}

// SetDeletedBy sets the "deleted_by" field.
func (m *SpaceMutation) SetDeletedBy(i int64) {
	m.deleter = &i
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *SpaceMutation) DeletedBy() (r int64, exists bool) {
	v := m.deleter
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the Space entity.
// If the Space object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpaceMutation) OldDeletedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *SpaceMutation) ClearDeletedBy() {
	m.deleter = nil
	m.clearedFields[space.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *SpaceMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[space.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *SpaceMutation) ResetDeletedBy() {
	m.deleter = nil
	delete(m.clearedFields, space.FieldDeletedBy)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *SpaceMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *SpaceMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the Space entity.
// If the Space object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpaceMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *SpaceMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[space.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *SpaceMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[space.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *SpaceMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, space.FieldDeletedAt)
}

// SetName sets the "name" field.
func (m *SpaceMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *SpaceMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Space entity.
// If the Space object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpaceMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *SpaceMutation) ResetName() {
	m.name = nil
}

// SetIcon sets the "icon" field.
func (m *SpaceMutation) SetIcon(s string) {
	m.icon = &s
}

// Icon returns the value of the "icon" field in the mutation.
func (m *SpaceMutation) Icon() (r string, exists bool) {
	v := m.icon
	if v == nil {
		return
	}
	return *v, true
}

// OldIcon returns the old "icon" field's value of the Space entity.
// If the Space object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpaceMutation) OldIcon(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIcon is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIcon requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIcon: %w", err)
	}
	return oldValue.Icon, nil
}

// ClearIcon clears the value of the "icon" field.
func (m *SpaceMutation) ClearIcon() {
	m.icon = nil
	m.clearedFields[space.FieldIcon] = struct{}{}
}

// IconCleared returns if the "icon" field was cleared in this mutation.
func (m *SpaceMutation) IconCleared() bool {
	_, ok := m.clearedFields[space.FieldIcon]
	return ok
}

// ResetIcon resets all changes to the "icon" field.
func (m *SpaceMutation) ResetIcon() {
	m.icon = nil
	delete(m.clearedFields, space.FieldIcon)
}

// SetDescription sets the "description" field.
func (m *SpaceMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *SpaceMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the Space entity.
// If the Space object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpaceMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *SpaceMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[space.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *SpaceMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[space.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *SpaceMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, space.FieldDescription)
}

// SetIsFolderMode sets the "is_folder_mode" field.
func (m *SpaceMutation) SetIsFolderMode(b bool) {
	m.is_folder_mode = &b
}

// IsFolderMode returns the value of the "is_folder_mode" field in the mutation.
func (m *SpaceMutation) IsFolderMode() (r bool, exists bool) {
	v := m.is_folder_mode
	if v == nil {
		return
	}
	return *v, true
}

// OldIsFolderMode returns the old "is_folder_mode" field's value of the Space entity.
// If the Space object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpaceMutation) OldIsFolderMode(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsFolderMode is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsFolderMode requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsFolderMode: %w", err)
	}
	return oldValue.IsFolderMode, nil
}

// ResetIsFolderMode resets all changes to the "is_folder_mode" field.
func (m *SpaceMutation) ResetIsFolderMode() {
	m.is_folder_mode = nil
}

// SetDeleterID sets the "deleter" edge to the User entity by id.
func (m *SpaceMutation) SetDeleterID(id int64) {
	m.deleter = &id
}

// ClearDeleter clears the "deleter" edge to the User entity.
func (m *SpaceMutation) ClearDeleter() {
	m.cleareddeleter = true
	m.clearedFields[space.FieldDeletedBy] = struct{}{}
}

// DeleterCleared reports if the "deleter" edge to the User entity was cleared.
func (m *SpaceMutation) DeleterCleared() bool {
	return m.DeletedByCleared() || m.cleareddeleter
}

// DeleterID returns the "deleter" edge ID in the mutation.
func (m *SpaceMutation) DeleterID() (id int64, exists bool) {
	if m.deleter != nil {
		return *m.deleter, true
	}
	return
}

// DeleterIDs returns the "deleter" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// DeleterID instead. It exists only for internal usage by the builders.
func (m *SpaceMutation) DeleterIDs() (ids []int64) {
	if id := m.deleter; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDeleter resets all changes to the "deleter" edge.
func (m *SpaceMutation) ResetDeleter() {
	m.deleter = nil
	m.cleareddeleter = false
}

// AddFileIDs adds the "files" edge to the File entity by ids.
func (m *SpaceMutation) AddFileIDs(ids ...int64) {
	if m.files == nil {
		m.files = make(map[int64]struct{})
	}
	for i := range ids {
		m.files[ids[i]] = struct{}{}
	}
}

// ClearFiles clears the "files" edge to the File entity.
func (m *SpaceMutation) ClearFiles() {
	m.clearedfiles = true
}

// FilesCleared reports if the "files" edge to the File entity was cleared.
func (m *SpaceMutation) FilesCleared() bool {
	return m.clearedfiles
}

// RemoveFileIDs removes the "files" edge to the File entity by IDs.
func (m *SpaceMutation) RemoveFileIDs(ids ...int64) {
	if m.removedfiles == nil {
		m.removedfiles = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.files, ids[i])
		m.removedfiles[ids[i]] = struct{}{}
	}
}

// RemovedFiles returns the removed IDs of the "files" edge to the File entity.
func (m *SpaceMutation) RemovedFilesIDs() (ids []int64) {
	for id := range m.removedfiles {
		ids = append(ids, id)
	}
	return
}

// FilesIDs returns the "files" edge IDs in the mutation.
func (m *SpaceMutation) FilesIDs() (ids []int64) {
	for id := range m.files {
		ids = append(ids, id)
	}
	return
}

// ResetFiles resets all changes to the "files" edge.
func (m *SpaceMutation) ResetFiles() {
	m.files = nil
	m.clearedfiles = false
	m.removedfiles = nil
}

// AddUserIDs adds the "users" edge to the User entity by ids.
func (m *SpaceMutation) AddUserIDs(ids ...int64) {
	if m.users == nil {
		m.users = make(map[int64]struct{})
	}
	for i := range ids {
		m.users[ids[i]] = struct{}{}
	}
}

// ClearUsers clears the "users" edge to the User entity.
func (m *SpaceMutation) ClearUsers() {
	m.clearedusers = true
}

// UsersCleared reports if the "users" edge to the User entity was cleared.
func (m *SpaceMutation) UsersCleared() bool {
	return m.clearedusers
}

// RemoveUserIDs removes the "users" edge to the User entity by IDs.
func (m *SpaceMutation) RemoveUserIDs(ids ...int64) {
	if m.removedusers == nil {
		m.removedusers = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.users, ids[i])
		m.removedusers[ids[i]] = struct{}{}
	}
}

// RemovedUsers returns the removed IDs of the "users" edge to the User entity.
func (m *SpaceMutation) RemovedUsersIDs() (ids []int64) {
	for id := range m.removedusers {
		ids = append(ids, id)
	}
	return
}

// UsersIDs returns the "users" edge IDs in the mutation.
func (m *SpaceMutation) UsersIDs() (ids []int64) {
	for id := range m.users {
		ids = append(ids, id)
	}
	return
}

// ResetUsers resets all changes to the "users" edge.
func (m *SpaceMutation) ResetUsers() {
	m.users = nil
	m.clearedusers = false
	m.removedusers = nil
}

// AddTagIDs adds the "tags" edge to the Tag entity by ids.
func (m *SpaceMutation) AddTagIDs(ids ...int64) {
	if m.tags == nil {
		m.tags = make(map[int64]struct{})
	}
	for i := range ids {
		m.tags[ids[i]] = struct{}{}
	}
}

// ClearTags clears the "tags" edge to the Tag entity.
func (m *SpaceMutation) ClearTags() {
	m.clearedtags = true
}

// TagsCleared reports if the "tags" edge to the Tag entity was cleared.
func (m *SpaceMutation) TagsCleared() bool {
	return m.clearedtags
}

// RemoveTagIDs removes the "tags" edge to the Tag entity by IDs.
func (m *SpaceMutation) RemoveTagIDs(ids ...int64) {
	if m.removedtags == nil {
		m.removedtags = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.tags, ids[i])
		m.removedtags[ids[i]] = struct{}{}
	}
}

// RemovedTags returns the removed IDs of the "tags" edge to the Tag entity.
func (m *SpaceMutation) RemovedTagsIDs() (ids []int64) {
	for id := range m.removedtags {
		ids = append(ids, id)
	}
	return
}

// TagsIDs returns the "tags" edge IDs in the mutation.
func (m *SpaceMutation) TagsIDs() (ids []int64) {
	for id := range m.tags {
		ids = append(ids, id)
	}
	return
}

// ResetTags resets all changes to the "tags" edge.
func (m *SpaceMutation) ResetTags() {
	m.tags = nil
	m.clearedtags = false
	m.removedtags = nil
}

// AddDocumentTypeIDs adds the "document_types" edge to the DocumentType entity by ids.
func (m *SpaceMutation) AddDocumentTypeIDs(ids ...int64) {
	if m.document_types == nil {
		m.document_types = make(map[int64]struct{})
	}
	for i := range ids {
		m.document_types[ids[i]] = struct{}{}
	}
}

// ClearDocumentTypes clears the "document_types" edge to the DocumentType entity.
func (m *SpaceMutation) ClearDocumentTypes() {
	m.cleareddocument_types = true
}

// DocumentTypesCleared reports if the "document_types" edge to the DocumentType entity was cleared.
func (m *SpaceMutation) DocumentTypesCleared() bool {
	return m.cleareddocument_types
}

// RemoveDocumentTypeIDs removes the "document_types" edge to the DocumentType entity by IDs.
func (m *SpaceMutation) RemoveDocumentTypeIDs(ids ...int64) {
	if m.removeddocument_types == nil {
		m.removeddocument_types = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.document_types, ids[i])
		m.removeddocument_types[ids[i]] = struct{}{}
	}
}

// RemovedDocumentTypes returns the removed IDs of the "document_types" edge to the DocumentType entity.
func (m *SpaceMutation) RemovedDocumentTypesIDs() (ids []int64) {
	for id := range m.removeddocument_types {
		ids = append(ids, id)
	}
	return
}

// DocumentTypesIDs returns the "document_types" edge IDs in the mutation.
func (m *SpaceMutation) DocumentTypesIDs() (ids []int64) {
	for id := range m.document_types {
		ids = append(ids, id)
	}
	return
}

// ResetDocumentTypes resets all changes to the "document_types" edge.
func (m *SpaceMutation) ResetDocumentTypes() {
	m.document_types = nil
	m.cleareddocument_types = false
	m.removeddocument_types = nil
}

// AddPropertyIDs adds the "properties" edge to the Property entity by ids.
func (m *SpaceMutation) AddPropertyIDs(ids ...int64) {
	if m.properties == nil {
		m.properties = make(map[int64]struct{})
	}
	for i := range ids {
		m.properties[ids[i]] = struct{}{}
	}
}

// ClearProperties clears the "properties" edge to the Property entity.
func (m *SpaceMutation) ClearProperties() {
	m.clearedproperties = true
}

// PropertiesCleared reports if the "properties" edge to the Property entity was cleared.
func (m *SpaceMutation) PropertiesCleared() bool {
	return m.clearedproperties
}

// RemovePropertyIDs removes the "properties" edge to the Property entity by IDs.
func (m *SpaceMutation) RemovePropertyIDs(ids ...int64) {
	if m.removedproperties == nil {
		m.removedproperties = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.properties, ids[i])
		m.removedproperties[ids[i]] = struct{}{}
	}
}

// RemovedProperties returns the removed IDs of the "properties" edge to the Property entity.
func (m *SpaceMutation) RemovedPropertiesIDs() (ids []int64) {
	for id := range m.removedproperties {
		ids = append(ids, id)
	}
	return
}

// PropertiesIDs returns the "properties" edge IDs in the mutation.
func (m *SpaceMutation) PropertiesIDs() (ids []int64) {
	for id := range m.properties {
		ids = append(ids, id)
	}
	return
}

// ResetProperties resets all changes to the "properties" edge.
func (m *SpaceMutation) ResetProperties() {
	m.properties = nil
	m.clearedproperties = false
	m.removedproperties = nil
}

// AddUserAssignmentIDs adds the "user_assignment" edge to the SpaceUserAssignment entity by ids.
func (m *SpaceMutation) AddUserAssignmentIDs(ids ...int64) {
	if m.user_assignment == nil {
		m.user_assignment = make(map[int64]struct{})
	}
	for i := range ids {
		m.user_assignment[ids[i]] = struct{}{}
	}
}

// ClearUserAssignment clears the "user_assignment" edge to the SpaceUserAssignment entity.
func (m *SpaceMutation) ClearUserAssignment() {
	m.cleareduser_assignment = true
}

// UserAssignmentCleared reports if the "user_assignment" edge to the SpaceUserAssignment entity was cleared.
func (m *SpaceMutation) UserAssignmentCleared() bool {
	return m.cleareduser_assignment
}

// RemoveUserAssignmentIDs removes the "user_assignment" edge to the SpaceUserAssignment entity by IDs.
func (m *SpaceMutation) RemoveUserAssignmentIDs(ids ...int64) {
	if m.removeduser_assignment == nil {
		m.removeduser_assignment = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.user_assignment, ids[i])
		m.removeduser_assignment[ids[i]] = struct{}{}
	}
}

// RemovedUserAssignment returns the removed IDs of the "user_assignment" edge to the SpaceUserAssignment entity.
func (m *SpaceMutation) RemovedUserAssignmentIDs() (ids []int64) {
	for id := range m.removeduser_assignment {
		ids = append(ids, id)
	}
	return
}

// UserAssignmentIDs returns the "user_assignment" edge IDs in the mutation.
func (m *SpaceMutation) UserAssignmentIDs() (ids []int64) {
	for id := range m.user_assignment {
		ids = append(ids, id)
	}
	return
}

// ResetUserAssignment resets all changes to the "user_assignment" edge.
func (m *SpaceMutation) ResetUserAssignment() {
	m.user_assignment = nil
	m.cleareduser_assignment = false
	m.removeduser_assignment = nil
}

// Where appends a list predicates to the SpaceMutation builder.
func (m *SpaceMutation) Where(ps ...predicate.Space) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SpaceMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SpaceMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Space, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SpaceMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SpaceMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Space).
func (m *SpaceMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SpaceMutation) Fields() []string {
	fields := make([]string, 0, 7)
	if m.public_id != nil {
		fields = append(fields, space.FieldPublicID)
	}
	if m.deleter != nil {
		fields = append(fields, space.FieldDeletedBy)
	}
	if m.deleted_at != nil {
		fields = append(fields, space.FieldDeletedAt)
	}
	if m.name != nil {
		fields = append(fields, space.FieldName)
	}
	if m.icon != nil {
		fields = append(fields, space.FieldIcon)
	}
	if m.description != nil {
		fields = append(fields, space.FieldDescription)
	}
	if m.is_folder_mode != nil {
		fields = append(fields, space.FieldIsFolderMode)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SpaceMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case space.FieldPublicID:
		return m.PublicID()
	case space.FieldDeletedBy:
		return m.DeletedBy()
	case space.FieldDeletedAt:
		return m.DeletedAt()
	case space.FieldName:
		return m.Name()
	case space.FieldIcon:
		return m.Icon()
	case space.FieldDescription:
		return m.Description()
	case space.FieldIsFolderMode:
		return m.IsFolderMode()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SpaceMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case space.FieldPublicID:
		return m.OldPublicID(ctx)
	case space.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case space.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case space.FieldName:
		return m.OldName(ctx)
	case space.FieldIcon:
		return m.OldIcon(ctx)
	case space.FieldDescription:
		return m.OldDescription(ctx)
	case space.FieldIsFolderMode:
		return m.OldIsFolderMode(ctx)
	}
	return nil, fmt.Errorf("unknown Space field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SpaceMutation) SetField(name string, value ent.Value) error {
	switch name {
	case space.FieldPublicID:
		v, ok := value.(entx.CIText)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublicID(v)
		return nil
	case space.FieldDeletedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case space.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case space.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case space.FieldIcon:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIcon(v)
		return nil
	case space.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	case space.FieldIsFolderMode:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsFolderMode(v)
		return nil
	}
	return fmt.Errorf("unknown Space field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SpaceMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SpaceMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SpaceMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Space numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SpaceMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(space.FieldDeletedBy) {
		fields = append(fields, space.FieldDeletedBy)
	}
	if m.FieldCleared(space.FieldDeletedAt) {
		fields = append(fields, space.FieldDeletedAt)
	}
	if m.FieldCleared(space.FieldIcon) {
		fields = append(fields, space.FieldIcon)
	}
	if m.FieldCleared(space.FieldDescription) {
		fields = append(fields, space.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SpaceMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SpaceMutation) ClearField(name string) error {
	switch name {
	case space.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case space.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case space.FieldIcon:
		m.ClearIcon()
		return nil
	case space.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown Space nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SpaceMutation) ResetField(name string) error {
	switch name {
	case space.FieldPublicID:
		m.ResetPublicID()
		return nil
	case space.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case space.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case space.FieldName:
		m.ResetName()
		return nil
	case space.FieldIcon:
		m.ResetIcon()
		return nil
	case space.FieldDescription:
		m.ResetDescription()
		return nil
	case space.FieldIsFolderMode:
		m.ResetIsFolderMode()
		return nil
	}
	return fmt.Errorf("unknown Space field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SpaceMutation) AddedEdges() []string {
	edges := make([]string, 0, 7)
	if m.deleter != nil {
		edges = append(edges, space.EdgeDeleter)
	}
	if m.files != nil {
		edges = append(edges, space.EdgeFiles)
	}
	if m.users != nil {
		edges = append(edges, space.EdgeUsers)
	}
	if m.tags != nil {
		edges = append(edges, space.EdgeTags)
	}
	if m.document_types != nil {
		edges = append(edges, space.EdgeDocumentTypes)
	}
	if m.properties != nil {
		edges = append(edges, space.EdgeProperties)
	}
	if m.user_assignment != nil {
		edges = append(edges, space.EdgeUserAssignment)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SpaceMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case space.EdgeDeleter:
		if id := m.deleter; id != nil {
			return []ent.Value{*id}
		}
	case space.EdgeFiles:
		ids := make([]ent.Value, 0, len(m.files))
		for id := range m.files {
			ids = append(ids, id)
		}
		return ids
	case space.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.users))
		for id := range m.users {
			ids = append(ids, id)
		}
		return ids
	case space.EdgeTags:
		ids := make([]ent.Value, 0, len(m.tags))
		for id := range m.tags {
			ids = append(ids, id)
		}
		return ids
	case space.EdgeDocumentTypes:
		ids := make([]ent.Value, 0, len(m.document_types))
		for id := range m.document_types {
			ids = append(ids, id)
		}
		return ids
	case space.EdgeProperties:
		ids := make([]ent.Value, 0, len(m.properties))
		for id := range m.properties {
			ids = append(ids, id)
		}
		return ids
	case space.EdgeUserAssignment:
		ids := make([]ent.Value, 0, len(m.user_assignment))
		for id := range m.user_assignment {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SpaceMutation) RemovedEdges() []string {
	edges := make([]string, 0, 7)
	if m.removedfiles != nil {
		edges = append(edges, space.EdgeFiles)
	}
	if m.removedusers != nil {
		edges = append(edges, space.EdgeUsers)
	}
	if m.removedtags != nil {
		edges = append(edges, space.EdgeTags)
	}
	if m.removeddocument_types != nil {
		edges = append(edges, space.EdgeDocumentTypes)
	}
	if m.removedproperties != nil {
		edges = append(edges, space.EdgeProperties)
	}
	if m.removeduser_assignment != nil {
		edges = append(edges, space.EdgeUserAssignment)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SpaceMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case space.EdgeFiles:
		ids := make([]ent.Value, 0, len(m.removedfiles))
		for id := range m.removedfiles {
			ids = append(ids, id)
		}
		return ids
	case space.EdgeUsers:
		ids := make([]ent.Value, 0, len(m.removedusers))
		for id := range m.removedusers {
			ids = append(ids, id)
		}
		return ids
	case space.EdgeTags:
		ids := make([]ent.Value, 0, len(m.removedtags))
		for id := range m.removedtags {
			ids = append(ids, id)
		}
		return ids
	case space.EdgeDocumentTypes:
		ids := make([]ent.Value, 0, len(m.removeddocument_types))
		for id := range m.removeddocument_types {
			ids = append(ids, id)
		}
		return ids
	case space.EdgeProperties:
		ids := make([]ent.Value, 0, len(m.removedproperties))
		for id := range m.removedproperties {
			ids = append(ids, id)
		}
		return ids
	case space.EdgeUserAssignment:
		ids := make([]ent.Value, 0, len(m.removeduser_assignment))
		for id := range m.removeduser_assignment {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SpaceMutation) ClearedEdges() []string {
	edges := make([]string, 0, 7)
	if m.cleareddeleter {
		edges = append(edges, space.EdgeDeleter)
	}
	if m.clearedfiles {
		edges = append(edges, space.EdgeFiles)
	}
	if m.clearedusers {
		edges = append(edges, space.EdgeUsers)
	}
	if m.clearedtags {
		edges = append(edges, space.EdgeTags)
	}
	if m.cleareddocument_types {
		edges = append(edges, space.EdgeDocumentTypes)
	}
	if m.clearedproperties {
		edges = append(edges, space.EdgeProperties)
	}
	if m.cleareduser_assignment {
		edges = append(edges, space.EdgeUserAssignment)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SpaceMutation) EdgeCleared(name string) bool {
	switch name {
	case space.EdgeDeleter:
		return m.cleareddeleter
	case space.EdgeFiles:
		return m.clearedfiles
	case space.EdgeUsers:
		return m.clearedusers
	case space.EdgeTags:
		return m.clearedtags
	case space.EdgeDocumentTypes:
		return m.cleareddocument_types
	case space.EdgeProperties:
		return m.clearedproperties
	case space.EdgeUserAssignment:
		return m.cleareduser_assignment
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SpaceMutation) ClearEdge(name string) error {
	switch name {
	case space.EdgeDeleter:
		m.ClearDeleter()
		return nil
	}
	return fmt.Errorf("unknown Space unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SpaceMutation) ResetEdge(name string) error {
	switch name {
	case space.EdgeDeleter:
		m.ResetDeleter()
		return nil
	case space.EdgeFiles:
		m.ResetFiles()
		return nil
	case space.EdgeUsers:
		m.ResetUsers()
		return nil
	case space.EdgeTags:
		m.ResetTags()
		return nil
	case space.EdgeDocumentTypes:
		m.ResetDocumentTypes()
		return nil
	case space.EdgeProperties:
		m.ResetProperties()
		return nil
	case space.EdgeUserAssignment:
		m.ResetUserAssignment()
		return nil
	}
	return fmt.Errorf("unknown Space edge %s", name)
}

// SpaceUserAssignmentMutation represents an operation that mutates the SpaceUserAssignment nodes in the graph.
type SpaceUserAssignmentMutation struct {
	config
	op             Op
	typ            string
	id             *int64
	created_at     *time.Time
	updated_at     *time.Time
	role           *spacerole.SpaceRole
	is_default     *bool
	clearedFields  map[string]struct{}
	space          *int64
	clearedspace   bool
	creator        *int64
	clearedcreator bool
	updater        *int64
	clearedupdater bool
	user           *int64
	cleareduser    bool
	done           bool
	oldValue       func(context.Context) (*SpaceUserAssignment, error)
	predicates     []predicate.SpaceUserAssignment
}

var _ ent.Mutation = (*SpaceUserAssignmentMutation)(nil)

// spaceuserassignmentOption allows management of the mutation configuration using functional options.
type spaceuserassignmentOption func(*SpaceUserAssignmentMutation)

// newSpaceUserAssignmentMutation creates new mutation for the SpaceUserAssignment entity.
func newSpaceUserAssignmentMutation(c config, op Op, opts ...spaceuserassignmentOption) *SpaceUserAssignmentMutation {
	m := &SpaceUserAssignmentMutation{
		config:        c,
		op:            op,
		typ:           TypeSpaceUserAssignment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSpaceUserAssignmentID sets the ID field of the mutation.
func withSpaceUserAssignmentID(id int64) spaceuserassignmentOption {
	return func(m *SpaceUserAssignmentMutation) {
		var (
			err   error
			once  sync.Once
			value *SpaceUserAssignment
		)
		m.oldValue = func(ctx context.Context) (*SpaceUserAssignment, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().SpaceUserAssignment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSpaceUserAssignment sets the old SpaceUserAssignment of the mutation.
func withSpaceUserAssignment(node *SpaceUserAssignment) spaceuserassignmentOption {
	return func(m *SpaceUserAssignmentMutation) {
		m.oldValue = func(context.Context) (*SpaceUserAssignment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SpaceUserAssignmentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SpaceUserAssignmentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("enttenant: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of SpaceUserAssignment entities.
func (m *SpaceUserAssignmentMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *SpaceUserAssignmentMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *SpaceUserAssignmentMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().SpaceUserAssignment.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSpaceID sets the "space_id" field.
func (m *SpaceUserAssignmentMutation) SetSpaceID(i int64) {
	m.space = &i
}

// SpaceID returns the value of the "space_id" field in the mutation.
func (m *SpaceUserAssignmentMutation) SpaceID() (r int64, exists bool) {
	v := m.space
	if v == nil {
		return
	}
	return *v, true
}

// OldSpaceID returns the old "space_id" field's value of the SpaceUserAssignment entity.
// If the SpaceUserAssignment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpaceUserAssignmentMutation) OldSpaceID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSpaceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSpaceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSpaceID: %w", err)
	}
	return oldValue.SpaceID, nil
}

// ResetSpaceID resets all changes to the "space_id" field.
func (m *SpaceUserAssignmentMutation) ResetSpaceID() {
	m.space = nil
}

// SetCreatedAt sets the "created_at" field.
func (m *SpaceUserAssignmentMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *SpaceUserAssignmentMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the SpaceUserAssignment entity.
// If the SpaceUserAssignment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpaceUserAssignmentMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *SpaceUserAssignmentMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *SpaceUserAssignmentMutation) SetCreatedBy(i int64) {
	m.creator = &i
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *SpaceUserAssignmentMutation) CreatedBy() (r int64, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the SpaceUserAssignment entity.
// If the SpaceUserAssignment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpaceUserAssignmentMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *SpaceUserAssignmentMutation) ClearCreatedBy() {
	m.creator = nil
	m.clearedFields[spaceuserassignment.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *SpaceUserAssignmentMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[spaceuserassignment.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *SpaceUserAssignmentMutation) ResetCreatedBy() {
	m.creator = nil
	delete(m.clearedFields, spaceuserassignment.FieldCreatedBy)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *SpaceUserAssignmentMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *SpaceUserAssignmentMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the SpaceUserAssignment entity.
// If the SpaceUserAssignment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpaceUserAssignmentMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *SpaceUserAssignmentMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *SpaceUserAssignmentMutation) SetUpdatedBy(i int64) {
	m.updater = &i
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *SpaceUserAssignmentMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updater
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the SpaceUserAssignment entity.
// If the SpaceUserAssignment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpaceUserAssignmentMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *SpaceUserAssignmentMutation) ClearUpdatedBy() {
	m.updater = nil
	m.clearedFields[spaceuserassignment.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *SpaceUserAssignmentMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[spaceuserassignment.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *SpaceUserAssignmentMutation) ResetUpdatedBy() {
	m.updater = nil
	delete(m.clearedFields, spaceuserassignment.FieldUpdatedBy)
}

// SetUserID sets the "user_id" field.
func (m *SpaceUserAssignmentMutation) SetUserID(i int64) {
	m.user = &i
}

// UserID returns the value of the "user_id" field in the mutation.
func (m *SpaceUserAssignmentMutation) UserID() (r int64, exists bool) {
	v := m.user
	if v == nil {
		return
	}
	return *v, true
}

// OldUserID returns the old "user_id" field's value of the SpaceUserAssignment entity.
// If the SpaceUserAssignment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpaceUserAssignmentMutation) OldUserID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUserID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUserID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUserID: %w", err)
	}
	return oldValue.UserID, nil
}

// ResetUserID resets all changes to the "user_id" field.
func (m *SpaceUserAssignmentMutation) ResetUserID() {
	m.user = nil
}

// SetRole sets the "role" field.
func (m *SpaceUserAssignmentMutation) SetRole(sr spacerole.SpaceRole) {
	m.role = &sr
}

// Role returns the value of the "role" field in the mutation.
func (m *SpaceUserAssignmentMutation) Role() (r spacerole.SpaceRole, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRole returns the old "role" field's value of the SpaceUserAssignment entity.
// If the SpaceUserAssignment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpaceUserAssignmentMutation) OldRole(ctx context.Context) (v spacerole.SpaceRole, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRole is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRole: %w", err)
	}
	return oldValue.Role, nil
}

// ResetRole resets all changes to the "role" field.
func (m *SpaceUserAssignmentMutation) ResetRole() {
	m.role = nil
}

// SetIsDefault sets the "is_default" field.
func (m *SpaceUserAssignmentMutation) SetIsDefault(b bool) {
	m.is_default = &b
}

// IsDefault returns the value of the "is_default" field in the mutation.
func (m *SpaceUserAssignmentMutation) IsDefault() (r bool, exists bool) {
	v := m.is_default
	if v == nil {
		return
	}
	return *v, true
}

// OldIsDefault returns the old "is_default" field's value of the SpaceUserAssignment entity.
// If the SpaceUserAssignment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *SpaceUserAssignmentMutation) OldIsDefault(ctx context.Context) (v bool, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIsDefault is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIsDefault requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIsDefault: %w", err)
	}
	return oldValue.IsDefault, nil
}

// ResetIsDefault resets all changes to the "is_default" field.
func (m *SpaceUserAssignmentMutation) ResetIsDefault() {
	m.is_default = nil
}

// ClearSpace clears the "space" edge to the Space entity.
func (m *SpaceUserAssignmentMutation) ClearSpace() {
	m.clearedspace = true
	m.clearedFields[spaceuserassignment.FieldSpaceID] = struct{}{}
}

// SpaceCleared reports if the "space" edge to the Space entity was cleared.
func (m *SpaceUserAssignmentMutation) SpaceCleared() bool {
	return m.clearedspace
}

// SpaceIDs returns the "space" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SpaceID instead. It exists only for internal usage by the builders.
func (m *SpaceUserAssignmentMutation) SpaceIDs() (ids []int64) {
	if id := m.space; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSpace resets all changes to the "space" edge.
func (m *SpaceUserAssignmentMutation) ResetSpace() {
	m.space = nil
	m.clearedspace = false
}

// SetCreatorID sets the "creator" edge to the User entity by id.
func (m *SpaceUserAssignmentMutation) SetCreatorID(id int64) {
	m.creator = &id
}

// ClearCreator clears the "creator" edge to the User entity.
func (m *SpaceUserAssignmentMutation) ClearCreator() {
	m.clearedcreator = true
	m.clearedFields[spaceuserassignment.FieldCreatedBy] = struct{}{}
}

// CreatorCleared reports if the "creator" edge to the User entity was cleared.
func (m *SpaceUserAssignmentMutation) CreatorCleared() bool {
	return m.CreatedByCleared() || m.clearedcreator
}

// CreatorID returns the "creator" edge ID in the mutation.
func (m *SpaceUserAssignmentMutation) CreatorID() (id int64, exists bool) {
	if m.creator != nil {
		return *m.creator, true
	}
	return
}

// CreatorIDs returns the "creator" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreatorID instead. It exists only for internal usage by the builders.
func (m *SpaceUserAssignmentMutation) CreatorIDs() (ids []int64) {
	if id := m.creator; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreator resets all changes to the "creator" edge.
func (m *SpaceUserAssignmentMutation) ResetCreator() {
	m.creator = nil
	m.clearedcreator = false
}

// SetUpdaterID sets the "updater" edge to the User entity by id.
func (m *SpaceUserAssignmentMutation) SetUpdaterID(id int64) {
	m.updater = &id
}

// ClearUpdater clears the "updater" edge to the User entity.
func (m *SpaceUserAssignmentMutation) ClearUpdater() {
	m.clearedupdater = true
	m.clearedFields[spaceuserassignment.FieldUpdatedBy] = struct{}{}
}

// UpdaterCleared reports if the "updater" edge to the User entity was cleared.
func (m *SpaceUserAssignmentMutation) UpdaterCleared() bool {
	return m.UpdatedByCleared() || m.clearedupdater
}

// UpdaterID returns the "updater" edge ID in the mutation.
func (m *SpaceUserAssignmentMutation) UpdaterID() (id int64, exists bool) {
	if m.updater != nil {
		return *m.updater, true
	}
	return
}

// UpdaterIDs returns the "updater" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UpdaterID instead. It exists only for internal usage by the builders.
func (m *SpaceUserAssignmentMutation) UpdaterIDs() (ids []int64) {
	if id := m.updater; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUpdater resets all changes to the "updater" edge.
func (m *SpaceUserAssignmentMutation) ResetUpdater() {
	m.updater = nil
	m.clearedupdater = false
}

// ClearUser clears the "user" edge to the User entity.
func (m *SpaceUserAssignmentMutation) ClearUser() {
	m.cleareduser = true
	m.clearedFields[spaceuserassignment.FieldUserID] = struct{}{}
}

// UserCleared reports if the "user" edge to the User entity was cleared.
func (m *SpaceUserAssignmentMutation) UserCleared() bool {
	return m.cleareduser
}

// UserIDs returns the "user" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *SpaceUserAssignmentMutation) UserIDs() (ids []int64) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser resets all changes to the "user" edge.
func (m *SpaceUserAssignmentMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Where appends a list predicates to the SpaceUserAssignmentMutation builder.
func (m *SpaceUserAssignmentMutation) Where(ps ...predicate.SpaceUserAssignment) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the SpaceUserAssignmentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *SpaceUserAssignmentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.SpaceUserAssignment, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *SpaceUserAssignmentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *SpaceUserAssignmentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (SpaceUserAssignment).
func (m *SpaceUserAssignmentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *SpaceUserAssignmentMutation) Fields() []string {
	fields := make([]string, 0, 8)
	if m.space != nil {
		fields = append(fields, spaceuserassignment.FieldSpaceID)
	}
	if m.created_at != nil {
		fields = append(fields, spaceuserassignment.FieldCreatedAt)
	}
	if m.creator != nil {
		fields = append(fields, spaceuserassignment.FieldCreatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, spaceuserassignment.FieldUpdatedAt)
	}
	if m.updater != nil {
		fields = append(fields, spaceuserassignment.FieldUpdatedBy)
	}
	if m.user != nil {
		fields = append(fields, spaceuserassignment.FieldUserID)
	}
	if m.role != nil {
		fields = append(fields, spaceuserassignment.FieldRole)
	}
	if m.is_default != nil {
		fields = append(fields, spaceuserassignment.FieldIsDefault)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *SpaceUserAssignmentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case spaceuserassignment.FieldSpaceID:
		return m.SpaceID()
	case spaceuserassignment.FieldCreatedAt:
		return m.CreatedAt()
	case spaceuserassignment.FieldCreatedBy:
		return m.CreatedBy()
	case spaceuserassignment.FieldUpdatedAt:
		return m.UpdatedAt()
	case spaceuserassignment.FieldUpdatedBy:
		return m.UpdatedBy()
	case spaceuserassignment.FieldUserID:
		return m.UserID()
	case spaceuserassignment.FieldRole:
		return m.Role()
	case spaceuserassignment.FieldIsDefault:
		return m.IsDefault()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *SpaceUserAssignmentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case spaceuserassignment.FieldSpaceID:
		return m.OldSpaceID(ctx)
	case spaceuserassignment.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case spaceuserassignment.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case spaceuserassignment.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case spaceuserassignment.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case spaceuserassignment.FieldUserID:
		return m.OldUserID(ctx)
	case spaceuserassignment.FieldRole:
		return m.OldRole(ctx)
	case spaceuserassignment.FieldIsDefault:
		return m.OldIsDefault(ctx)
	}
	return nil, fmt.Errorf("unknown SpaceUserAssignment field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SpaceUserAssignmentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case spaceuserassignment.FieldSpaceID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSpaceID(v)
		return nil
	case spaceuserassignment.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case spaceuserassignment.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case spaceuserassignment.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case spaceuserassignment.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case spaceuserassignment.FieldUserID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUserID(v)
		return nil
	case spaceuserassignment.FieldRole:
		v, ok := value.(spacerole.SpaceRole)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRole(v)
		return nil
	case spaceuserassignment.FieldIsDefault:
		v, ok := value.(bool)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIsDefault(v)
		return nil
	}
	return fmt.Errorf("unknown SpaceUserAssignment field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *SpaceUserAssignmentMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *SpaceUserAssignmentMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *SpaceUserAssignmentMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown SpaceUserAssignment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *SpaceUserAssignmentMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(spaceuserassignment.FieldCreatedBy) {
		fields = append(fields, spaceuserassignment.FieldCreatedBy)
	}
	if m.FieldCleared(spaceuserassignment.FieldUpdatedBy) {
		fields = append(fields, spaceuserassignment.FieldUpdatedBy)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *SpaceUserAssignmentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *SpaceUserAssignmentMutation) ClearField(name string) error {
	switch name {
	case spaceuserassignment.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case spaceuserassignment.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	}
	return fmt.Errorf("unknown SpaceUserAssignment nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *SpaceUserAssignmentMutation) ResetField(name string) error {
	switch name {
	case spaceuserassignment.FieldSpaceID:
		m.ResetSpaceID()
		return nil
	case spaceuserassignment.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case spaceuserassignment.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case spaceuserassignment.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case spaceuserassignment.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case spaceuserassignment.FieldUserID:
		m.ResetUserID()
		return nil
	case spaceuserassignment.FieldRole:
		m.ResetRole()
		return nil
	case spaceuserassignment.FieldIsDefault:
		m.ResetIsDefault()
		return nil
	}
	return fmt.Errorf("unknown SpaceUserAssignment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *SpaceUserAssignmentMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.space != nil {
		edges = append(edges, spaceuserassignment.EdgeSpace)
	}
	if m.creator != nil {
		edges = append(edges, spaceuserassignment.EdgeCreator)
	}
	if m.updater != nil {
		edges = append(edges, spaceuserassignment.EdgeUpdater)
	}
	if m.user != nil {
		edges = append(edges, spaceuserassignment.EdgeUser)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *SpaceUserAssignmentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case spaceuserassignment.EdgeSpace:
		if id := m.space; id != nil {
			return []ent.Value{*id}
		}
	case spaceuserassignment.EdgeCreator:
		if id := m.creator; id != nil {
			return []ent.Value{*id}
		}
	case spaceuserassignment.EdgeUpdater:
		if id := m.updater; id != nil {
			return []ent.Value{*id}
		}
	case spaceuserassignment.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *SpaceUserAssignmentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *SpaceUserAssignmentMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *SpaceUserAssignmentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearedspace {
		edges = append(edges, spaceuserassignment.EdgeSpace)
	}
	if m.clearedcreator {
		edges = append(edges, spaceuserassignment.EdgeCreator)
	}
	if m.clearedupdater {
		edges = append(edges, spaceuserassignment.EdgeUpdater)
	}
	if m.cleareduser {
		edges = append(edges, spaceuserassignment.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *SpaceUserAssignmentMutation) EdgeCleared(name string) bool {
	switch name {
	case spaceuserassignment.EdgeSpace:
		return m.clearedspace
	case spaceuserassignment.EdgeCreator:
		return m.clearedcreator
	case spaceuserassignment.EdgeUpdater:
		return m.clearedupdater
	case spaceuserassignment.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *SpaceUserAssignmentMutation) ClearEdge(name string) error {
	switch name {
	case spaceuserassignment.EdgeSpace:
		m.ClearSpace()
		return nil
	case spaceuserassignment.EdgeCreator:
		m.ClearCreator()
		return nil
	case spaceuserassignment.EdgeUpdater:
		m.ClearUpdater()
		return nil
	case spaceuserassignment.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown SpaceUserAssignment unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *SpaceUserAssignmentMutation) ResetEdge(name string) error {
	switch name {
	case spaceuserassignment.EdgeSpace:
		m.ResetSpace()
		return nil
	case spaceuserassignment.EdgeCreator:
		m.ResetCreator()
		return nil
	case spaceuserassignment.EdgeUpdater:
		m.ResetUpdater()
		return nil
	case spaceuserassignment.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown SpaceUserAssignment edge %s", name)
}

// StoredFileMutation represents an operation that mutates the StoredFile nodes in the graph.
type StoredFileMutation struct {
	config
	op                             Op
	typ                            string
	id                             *int64
	created_at                     *time.Time
	updated_at                     *time.Time
	filename                       *string
	size                           *int64
	addsize                        *int64
	size_in_storage                *int64
	addsize_in_storage             *int64
	sha256                         *string
	mime_type                      *string
	storage_type                   *storagetype.StorageType
	bucket_name                    *string
	storage_path                   *string
	storage_filename               *string
	temporary_storage_path         *string
	temporary_storage_filename     *string
	copied_to_final_destination_at *time.Time
	deleted_temporary_file_at      *time.Time
	clearedFields                  map[string]struct{}
	creator                        *int64
	clearedcreator                 bool
	updater                        *int64
	clearedupdater                 bool
	files                          map[int64]struct{}
	removedfiles                   map[int64]struct{}
	clearedfiles                   bool
	done                           bool
	oldValue                       func(context.Context) (*StoredFile, error)
	predicates                     []predicate.StoredFile
}

var _ ent.Mutation = (*StoredFileMutation)(nil)

// storedfileOption allows management of the mutation configuration using functional options.
type storedfileOption func(*StoredFileMutation)

// newStoredFileMutation creates new mutation for the StoredFile entity.
func newStoredFileMutation(c config, op Op, opts ...storedfileOption) *StoredFileMutation {
	m := &StoredFileMutation{
		config:        c,
		op:            op,
		typ:           TypeStoredFile,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withStoredFileID sets the ID field of the mutation.
func withStoredFileID(id int64) storedfileOption {
	return func(m *StoredFileMutation) {
		var (
			err   error
			once  sync.Once
			value *StoredFile
		)
		m.oldValue = func(ctx context.Context) (*StoredFile, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().StoredFile.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withStoredFile sets the old StoredFile of the mutation.
func withStoredFile(node *StoredFile) storedfileOption {
	return func(m *StoredFileMutation) {
		m.oldValue = func(context.Context) (*StoredFile, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m StoredFileMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m StoredFileMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("enttenant: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of StoredFile entities.
func (m *StoredFileMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *StoredFileMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *StoredFileMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().StoredFile.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *StoredFileMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *StoredFileMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the StoredFile entity.
// If the StoredFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoredFileMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *StoredFileMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *StoredFileMutation) SetCreatedBy(i int64) {
	m.creator = &i
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *StoredFileMutation) CreatedBy() (r int64, exists bool) {
	v := m.creator
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the StoredFile entity.
// If the StoredFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoredFileMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *StoredFileMutation) ClearCreatedBy() {
	m.creator = nil
	m.clearedFields[storedfile.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *StoredFileMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[storedfile.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *StoredFileMutation) ResetCreatedBy() {
	m.creator = nil
	delete(m.clearedFields, storedfile.FieldCreatedBy)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *StoredFileMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *StoredFileMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the StoredFile entity.
// If the StoredFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoredFileMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *StoredFileMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *StoredFileMutation) SetUpdatedBy(i int64) {
	m.updater = &i
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *StoredFileMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updater
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the StoredFile entity.
// If the StoredFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoredFileMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *StoredFileMutation) ClearUpdatedBy() {
	m.updater = nil
	m.clearedFields[storedfile.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *StoredFileMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[storedfile.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *StoredFileMutation) ResetUpdatedBy() {
	m.updater = nil
	delete(m.clearedFields, storedfile.FieldUpdatedBy)
}

// SetFilename sets the "filename" field.
func (m *StoredFileMutation) SetFilename(s string) {
	m.filename = &s
}

// Filename returns the value of the "filename" field in the mutation.
func (m *StoredFileMutation) Filename() (r string, exists bool) {
	v := m.filename
	if v == nil {
		return
	}
	return *v, true
}

// OldFilename returns the old "filename" field's value of the StoredFile entity.
// If the StoredFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoredFileMutation) OldFilename(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFilename is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFilename requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFilename: %w", err)
	}
	return oldValue.Filename, nil
}

// ResetFilename resets all changes to the "filename" field.
func (m *StoredFileMutation) ResetFilename() {
	m.filename = nil
}

// SetSize sets the "size" field.
func (m *StoredFileMutation) SetSize(i int64) {
	m.size = &i
	m.addsize = nil
}

// Size returns the value of the "size" field in the mutation.
func (m *StoredFileMutation) Size() (r int64, exists bool) {
	v := m.size
	if v == nil {
		return
	}
	return *v, true
}

// OldSize returns the old "size" field's value of the StoredFile entity.
// If the StoredFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoredFileMutation) OldSize(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSize is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSize requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSize: %w", err)
	}
	return oldValue.Size, nil
}

// AddSize adds i to the "size" field.
func (m *StoredFileMutation) AddSize(i int64) {
	if m.addsize != nil {
		*m.addsize += i
	} else {
		m.addsize = &i
	}
}

// AddedSize returns the value that was added to the "size" field in this mutation.
func (m *StoredFileMutation) AddedSize() (r int64, exists bool) {
	v := m.addsize
	if v == nil {
		return
	}
	return *v, true
}

// ClearSize clears the value of the "size" field.
func (m *StoredFileMutation) ClearSize() {
	m.size = nil
	m.addsize = nil
	m.clearedFields[storedfile.FieldSize] = struct{}{}
}

// SizeCleared returns if the "size" field was cleared in this mutation.
func (m *StoredFileMutation) SizeCleared() bool {
	_, ok := m.clearedFields[storedfile.FieldSize]
	return ok
}

// ResetSize resets all changes to the "size" field.
func (m *StoredFileMutation) ResetSize() {
	m.size = nil
	m.addsize = nil
	delete(m.clearedFields, storedfile.FieldSize)
}

// SetSizeInStorage sets the "size_in_storage" field.
func (m *StoredFileMutation) SetSizeInStorage(i int64) {
	m.size_in_storage = &i
	m.addsize_in_storage = nil
}

// SizeInStorage returns the value of the "size_in_storage" field in the mutation.
func (m *StoredFileMutation) SizeInStorage() (r int64, exists bool) {
	v := m.size_in_storage
	if v == nil {
		return
	}
	return *v, true
}

// OldSizeInStorage returns the old "size_in_storage" field's value of the StoredFile entity.
// If the StoredFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoredFileMutation) OldSizeInStorage(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSizeInStorage is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSizeInStorage requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSizeInStorage: %w", err)
	}
	return oldValue.SizeInStorage, nil
}

// AddSizeInStorage adds i to the "size_in_storage" field.
func (m *StoredFileMutation) AddSizeInStorage(i int64) {
	if m.addsize_in_storage != nil {
		*m.addsize_in_storage += i
	} else {
		m.addsize_in_storage = &i
	}
}

// AddedSizeInStorage returns the value that was added to the "size_in_storage" field in this mutation.
func (m *StoredFileMutation) AddedSizeInStorage() (r int64, exists bool) {
	v := m.addsize_in_storage
	if v == nil {
		return
	}
	return *v, true
}

// ResetSizeInStorage resets all changes to the "size_in_storage" field.
func (m *StoredFileMutation) ResetSizeInStorage() {
	m.size_in_storage = nil
	m.addsize_in_storage = nil
}

// SetSha256 sets the "sha256" field.
func (m *StoredFileMutation) SetSha256(s string) {
	m.sha256 = &s
}

// Sha256 returns the value of the "sha256" field in the mutation.
func (m *StoredFileMutation) Sha256() (r string, exists bool) {
	v := m.sha256
	if v == nil {
		return
	}
	return *v, true
}

// OldSha256 returns the old "sha256" field's value of the StoredFile entity.
// If the StoredFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoredFileMutation) OldSha256(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSha256 is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSha256 requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSha256: %w", err)
	}
	return oldValue.Sha256, nil
}

// ClearSha256 clears the value of the "sha256" field.
func (m *StoredFileMutation) ClearSha256() {
	m.sha256 = nil
	m.clearedFields[storedfile.FieldSha256] = struct{}{}
}

// Sha256Cleared returns if the "sha256" field was cleared in this mutation.
func (m *StoredFileMutation) Sha256Cleared() bool {
	_, ok := m.clearedFields[storedfile.FieldSha256]
	return ok
}

// ResetSha256 resets all changes to the "sha256" field.
func (m *StoredFileMutation) ResetSha256() {
	m.sha256 = nil
	delete(m.clearedFields, storedfile.FieldSha256)
}

// SetMimeType sets the "mime_type" field.
func (m *StoredFileMutation) SetMimeType(s string) {
	m.mime_type = &s
}

// MimeType returns the value of the "mime_type" field in the mutation.
func (m *StoredFileMutation) MimeType() (r string, exists bool) {
	v := m.mime_type
	if v == nil {
		return
	}
	return *v, true
}

// OldMimeType returns the old "mime_type" field's value of the StoredFile entity.
// If the StoredFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoredFileMutation) OldMimeType(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldMimeType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldMimeType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldMimeType: %w", err)
	}
	return oldValue.MimeType, nil
}

// ClearMimeType clears the value of the "mime_type" field.
func (m *StoredFileMutation) ClearMimeType() {
	m.mime_type = nil
	m.clearedFields[storedfile.FieldMimeType] = struct{}{}
}

// MimeTypeCleared returns if the "mime_type" field was cleared in this mutation.
func (m *StoredFileMutation) MimeTypeCleared() bool {
	_, ok := m.clearedFields[storedfile.FieldMimeType]
	return ok
}

// ResetMimeType resets all changes to the "mime_type" field.
func (m *StoredFileMutation) ResetMimeType() {
	m.mime_type = nil
	delete(m.clearedFields, storedfile.FieldMimeType)
}

// SetStorageType sets the "storage_type" field.
func (m *StoredFileMutation) SetStorageType(st storagetype.StorageType) {
	m.storage_type = &st
}

// StorageType returns the value of the "storage_type" field in the mutation.
func (m *StoredFileMutation) StorageType() (r storagetype.StorageType, exists bool) {
	v := m.storage_type
	if v == nil {
		return
	}
	return *v, true
}

// OldStorageType returns the old "storage_type" field's value of the StoredFile entity.
// If the StoredFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoredFileMutation) OldStorageType(ctx context.Context) (v storagetype.StorageType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStorageType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStorageType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStorageType: %w", err)
	}
	return oldValue.StorageType, nil
}

// ResetStorageType resets all changes to the "storage_type" field.
func (m *StoredFileMutation) ResetStorageType() {
	m.storage_type = nil
}

// SetBucketName sets the "bucket_name" field.
func (m *StoredFileMutation) SetBucketName(s string) {
	m.bucket_name = &s
}

// BucketName returns the value of the "bucket_name" field in the mutation.
func (m *StoredFileMutation) BucketName() (r string, exists bool) {
	v := m.bucket_name
	if v == nil {
		return
	}
	return *v, true
}

// OldBucketName returns the old "bucket_name" field's value of the StoredFile entity.
// If the StoredFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoredFileMutation) OldBucketName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldBucketName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldBucketName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBucketName: %w", err)
	}
	return oldValue.BucketName, nil
}

// ClearBucketName clears the value of the "bucket_name" field.
func (m *StoredFileMutation) ClearBucketName() {
	m.bucket_name = nil
	m.clearedFields[storedfile.FieldBucketName] = struct{}{}
}

// BucketNameCleared returns if the "bucket_name" field was cleared in this mutation.
func (m *StoredFileMutation) BucketNameCleared() bool {
	_, ok := m.clearedFields[storedfile.FieldBucketName]
	return ok
}

// ResetBucketName resets all changes to the "bucket_name" field.
func (m *StoredFileMutation) ResetBucketName() {
	m.bucket_name = nil
	delete(m.clearedFields, storedfile.FieldBucketName)
}

// SetStoragePath sets the "storage_path" field.
func (m *StoredFileMutation) SetStoragePath(s string) {
	m.storage_path = &s
}

// StoragePath returns the value of the "storage_path" field in the mutation.
func (m *StoredFileMutation) StoragePath() (r string, exists bool) {
	v := m.storage_path
	if v == nil {
		return
	}
	return *v, true
}

// OldStoragePath returns the old "storage_path" field's value of the StoredFile entity.
// If the StoredFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoredFileMutation) OldStoragePath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStoragePath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStoragePath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStoragePath: %w", err)
	}
	return oldValue.StoragePath, nil
}

// ResetStoragePath resets all changes to the "storage_path" field.
func (m *StoredFileMutation) ResetStoragePath() {
	m.storage_path = nil
}

// SetStorageFilename sets the "storage_filename" field.
func (m *StoredFileMutation) SetStorageFilename(s string) {
	m.storage_filename = &s
}

// StorageFilename returns the value of the "storage_filename" field in the mutation.
func (m *StoredFileMutation) StorageFilename() (r string, exists bool) {
	v := m.storage_filename
	if v == nil {
		return
	}
	return *v, true
}

// OldStorageFilename returns the old "storage_filename" field's value of the StoredFile entity.
// If the StoredFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoredFileMutation) OldStorageFilename(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldStorageFilename is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldStorageFilename requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldStorageFilename: %w", err)
	}
	return oldValue.StorageFilename, nil
}

// ResetStorageFilename resets all changes to the "storage_filename" field.
func (m *StoredFileMutation) ResetStorageFilename() {
	m.storage_filename = nil
}

// SetTemporaryStoragePath sets the "temporary_storage_path" field.
func (m *StoredFileMutation) SetTemporaryStoragePath(s string) {
	m.temporary_storage_path = &s
}

// TemporaryStoragePath returns the value of the "temporary_storage_path" field in the mutation.
func (m *StoredFileMutation) TemporaryStoragePath() (r string, exists bool) {
	v := m.temporary_storage_path
	if v == nil {
		return
	}
	return *v, true
}

// OldTemporaryStoragePath returns the old "temporary_storage_path" field's value of the StoredFile entity.
// If the StoredFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoredFileMutation) OldTemporaryStoragePath(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTemporaryStoragePath is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTemporaryStoragePath requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTemporaryStoragePath: %w", err)
	}
	return oldValue.TemporaryStoragePath, nil
}

// ResetTemporaryStoragePath resets all changes to the "temporary_storage_path" field.
func (m *StoredFileMutation) ResetTemporaryStoragePath() {
	m.temporary_storage_path = nil
}

// SetTemporaryStorageFilename sets the "temporary_storage_filename" field.
func (m *StoredFileMutation) SetTemporaryStorageFilename(s string) {
	m.temporary_storage_filename = &s
}

// TemporaryStorageFilename returns the value of the "temporary_storage_filename" field in the mutation.
func (m *StoredFileMutation) TemporaryStorageFilename() (r string, exists bool) {
	v := m.temporary_storage_filename
	if v == nil {
		return
	}
	return *v, true
}

// OldTemporaryStorageFilename returns the old "temporary_storage_filename" field's value of the StoredFile entity.
// If the StoredFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoredFileMutation) OldTemporaryStorageFilename(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTemporaryStorageFilename is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTemporaryStorageFilename requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTemporaryStorageFilename: %w", err)
	}
	return oldValue.TemporaryStorageFilename, nil
}

// ResetTemporaryStorageFilename resets all changes to the "temporary_storage_filename" field.
func (m *StoredFileMutation) ResetTemporaryStorageFilename() {
	m.temporary_storage_filename = nil
}

// SetCopiedToFinalDestinationAt sets the "copied_to_final_destination_at" field.
func (m *StoredFileMutation) SetCopiedToFinalDestinationAt(t time.Time) {
	m.copied_to_final_destination_at = &t
}

// CopiedToFinalDestinationAt returns the value of the "copied_to_final_destination_at" field in the mutation.
func (m *StoredFileMutation) CopiedToFinalDestinationAt() (r time.Time, exists bool) {
	v := m.copied_to_final_destination_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCopiedToFinalDestinationAt returns the old "copied_to_final_destination_at" field's value of the StoredFile entity.
// If the StoredFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoredFileMutation) OldCopiedToFinalDestinationAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCopiedToFinalDestinationAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCopiedToFinalDestinationAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCopiedToFinalDestinationAt: %w", err)
	}
	return oldValue.CopiedToFinalDestinationAt, nil
}

// ClearCopiedToFinalDestinationAt clears the value of the "copied_to_final_destination_at" field.
func (m *StoredFileMutation) ClearCopiedToFinalDestinationAt() {
	m.copied_to_final_destination_at = nil
	m.clearedFields[storedfile.FieldCopiedToFinalDestinationAt] = struct{}{}
}

// CopiedToFinalDestinationAtCleared returns if the "copied_to_final_destination_at" field was cleared in this mutation.
func (m *StoredFileMutation) CopiedToFinalDestinationAtCleared() bool {
	_, ok := m.clearedFields[storedfile.FieldCopiedToFinalDestinationAt]
	return ok
}

// ResetCopiedToFinalDestinationAt resets all changes to the "copied_to_final_destination_at" field.
func (m *StoredFileMutation) ResetCopiedToFinalDestinationAt() {
	m.copied_to_final_destination_at = nil
	delete(m.clearedFields, storedfile.FieldCopiedToFinalDestinationAt)
}

// SetDeletedTemporaryFileAt sets the "deleted_temporary_file_at" field.
func (m *StoredFileMutation) SetDeletedTemporaryFileAt(t time.Time) {
	m.deleted_temporary_file_at = &t
}

// DeletedTemporaryFileAt returns the value of the "deleted_temporary_file_at" field in the mutation.
func (m *StoredFileMutation) DeletedTemporaryFileAt() (r time.Time, exists bool) {
	v := m.deleted_temporary_file_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedTemporaryFileAt returns the old "deleted_temporary_file_at" field's value of the StoredFile entity.
// If the StoredFile object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *StoredFileMutation) OldDeletedTemporaryFileAt(ctx context.Context) (v *time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedTemporaryFileAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedTemporaryFileAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedTemporaryFileAt: %w", err)
	}
	return oldValue.DeletedTemporaryFileAt, nil
}

// ClearDeletedTemporaryFileAt clears the value of the "deleted_temporary_file_at" field.
func (m *StoredFileMutation) ClearDeletedTemporaryFileAt() {
	m.deleted_temporary_file_at = nil
	m.clearedFields[storedfile.FieldDeletedTemporaryFileAt] = struct{}{}
}

// DeletedTemporaryFileAtCleared returns if the "deleted_temporary_file_at" field was cleared in this mutation.
func (m *StoredFileMutation) DeletedTemporaryFileAtCleared() bool {
	_, ok := m.clearedFields[storedfile.FieldDeletedTemporaryFileAt]
	return ok
}

// ResetDeletedTemporaryFileAt resets all changes to the "deleted_temporary_file_at" field.
func (m *StoredFileMutation) ResetDeletedTemporaryFileAt() {
	m.deleted_temporary_file_at = nil
	delete(m.clearedFields, storedfile.FieldDeletedTemporaryFileAt)
}

// SetCreatorID sets the "creator" edge to the User entity by id.
func (m *StoredFileMutation) SetCreatorID(id int64) {
	m.creator = &id
}

// ClearCreator clears the "creator" edge to the User entity.
func (m *StoredFileMutation) ClearCreator() {
	m.clearedcreator = true
	m.clearedFields[storedfile.FieldCreatedBy] = struct{}{}
}

// CreatorCleared reports if the "creator" edge to the User entity was cleared.
func (m *StoredFileMutation) CreatorCleared() bool {
	return m.CreatedByCleared() || m.clearedcreator
}

// CreatorID returns the "creator" edge ID in the mutation.
func (m *StoredFileMutation) CreatorID() (id int64, exists bool) {
	if m.creator != nil {
		return *m.creator, true
	}
	return
}

// CreatorIDs returns the "creator" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// CreatorID instead. It exists only for internal usage by the builders.
func (m *StoredFileMutation) CreatorIDs() (ids []int64) {
	if id := m.creator; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetCreator resets all changes to the "creator" edge.
func (m *StoredFileMutation) ResetCreator() {
	m.creator = nil
	m.clearedcreator = false
}

// SetUpdaterID sets the "updater" edge to the User entity by id.
func (m *StoredFileMutation) SetUpdaterID(id int64) {
	m.updater = &id
}

// ClearUpdater clears the "updater" edge to the User entity.
func (m *StoredFileMutation) ClearUpdater() {
	m.clearedupdater = true
	m.clearedFields[storedfile.FieldUpdatedBy] = struct{}{}
}

// UpdaterCleared reports if the "updater" edge to the User entity was cleared.
func (m *StoredFileMutation) UpdaterCleared() bool {
	return m.UpdatedByCleared() || m.clearedupdater
}

// UpdaterID returns the "updater" edge ID in the mutation.
func (m *StoredFileMutation) UpdaterID() (id int64, exists bool) {
	if m.updater != nil {
		return *m.updater, true
	}
	return
}

// UpdaterIDs returns the "updater" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// UpdaterID instead. It exists only for internal usage by the builders.
func (m *StoredFileMutation) UpdaterIDs() (ids []int64) {
	if id := m.updater; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUpdater resets all changes to the "updater" edge.
func (m *StoredFileMutation) ResetUpdater() {
	m.updater = nil
	m.clearedupdater = false
}

// AddFileIDs adds the "files" edge to the File entity by ids.
func (m *StoredFileMutation) AddFileIDs(ids ...int64) {
	if m.files == nil {
		m.files = make(map[int64]struct{})
	}
	for i := range ids {
		m.files[ids[i]] = struct{}{}
	}
}

// ClearFiles clears the "files" edge to the File entity.
func (m *StoredFileMutation) ClearFiles() {
	m.clearedfiles = true
}

// FilesCleared reports if the "files" edge to the File entity was cleared.
func (m *StoredFileMutation) FilesCleared() bool {
	return m.clearedfiles
}

// RemoveFileIDs removes the "files" edge to the File entity by IDs.
func (m *StoredFileMutation) RemoveFileIDs(ids ...int64) {
	if m.removedfiles == nil {
		m.removedfiles = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.files, ids[i])
		m.removedfiles[ids[i]] = struct{}{}
	}
}

// RemovedFiles returns the removed IDs of the "files" edge to the File entity.
func (m *StoredFileMutation) RemovedFilesIDs() (ids []int64) {
	for id := range m.removedfiles {
		ids = append(ids, id)
	}
	return
}

// FilesIDs returns the "files" edge IDs in the mutation.
func (m *StoredFileMutation) FilesIDs() (ids []int64) {
	for id := range m.files {
		ids = append(ids, id)
	}
	return
}

// ResetFiles resets all changes to the "files" edge.
func (m *StoredFileMutation) ResetFiles() {
	m.files = nil
	m.clearedfiles = false
	m.removedfiles = nil
}

// Where appends a list predicates to the StoredFileMutation builder.
func (m *StoredFileMutation) Where(ps ...predicate.StoredFile) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the StoredFileMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *StoredFileMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.StoredFile, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *StoredFileMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *StoredFileMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (StoredFile).
func (m *StoredFileMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *StoredFileMutation) Fields() []string {
	fields := make([]string, 0, 17)
	if m.created_at != nil {
		fields = append(fields, storedfile.FieldCreatedAt)
	}
	if m.creator != nil {
		fields = append(fields, storedfile.FieldCreatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, storedfile.FieldUpdatedAt)
	}
	if m.updater != nil {
		fields = append(fields, storedfile.FieldUpdatedBy)
	}
	if m.filename != nil {
		fields = append(fields, storedfile.FieldFilename)
	}
	if m.size != nil {
		fields = append(fields, storedfile.FieldSize)
	}
	if m.size_in_storage != nil {
		fields = append(fields, storedfile.FieldSizeInStorage)
	}
	if m.sha256 != nil {
		fields = append(fields, storedfile.FieldSha256)
	}
	if m.mime_type != nil {
		fields = append(fields, storedfile.FieldMimeType)
	}
	if m.storage_type != nil {
		fields = append(fields, storedfile.FieldStorageType)
	}
	if m.bucket_name != nil {
		fields = append(fields, storedfile.FieldBucketName)
	}
	if m.storage_path != nil {
		fields = append(fields, storedfile.FieldStoragePath)
	}
	if m.storage_filename != nil {
		fields = append(fields, storedfile.FieldStorageFilename)
	}
	if m.temporary_storage_path != nil {
		fields = append(fields, storedfile.FieldTemporaryStoragePath)
	}
	if m.temporary_storage_filename != nil {
		fields = append(fields, storedfile.FieldTemporaryStorageFilename)
	}
	if m.copied_to_final_destination_at != nil {
		fields = append(fields, storedfile.FieldCopiedToFinalDestinationAt)
	}
	if m.deleted_temporary_file_at != nil {
		fields = append(fields, storedfile.FieldDeletedTemporaryFileAt)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *StoredFileMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case storedfile.FieldCreatedAt:
		return m.CreatedAt()
	case storedfile.FieldCreatedBy:
		return m.CreatedBy()
	case storedfile.FieldUpdatedAt:
		return m.UpdatedAt()
	case storedfile.FieldUpdatedBy:
		return m.UpdatedBy()
	case storedfile.FieldFilename:
		return m.Filename()
	case storedfile.FieldSize:
		return m.Size()
	case storedfile.FieldSizeInStorage:
		return m.SizeInStorage()
	case storedfile.FieldSha256:
		return m.Sha256()
	case storedfile.FieldMimeType:
		return m.MimeType()
	case storedfile.FieldStorageType:
		return m.StorageType()
	case storedfile.FieldBucketName:
		return m.BucketName()
	case storedfile.FieldStoragePath:
		return m.StoragePath()
	case storedfile.FieldStorageFilename:
		return m.StorageFilename()
	case storedfile.FieldTemporaryStoragePath:
		return m.TemporaryStoragePath()
	case storedfile.FieldTemporaryStorageFilename:
		return m.TemporaryStorageFilename()
	case storedfile.FieldCopiedToFinalDestinationAt:
		return m.CopiedToFinalDestinationAt()
	case storedfile.FieldDeletedTemporaryFileAt:
		return m.DeletedTemporaryFileAt()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *StoredFileMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case storedfile.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case storedfile.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case storedfile.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case storedfile.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case storedfile.FieldFilename:
		return m.OldFilename(ctx)
	case storedfile.FieldSize:
		return m.OldSize(ctx)
	case storedfile.FieldSizeInStorage:
		return m.OldSizeInStorage(ctx)
	case storedfile.FieldSha256:
		return m.OldSha256(ctx)
	case storedfile.FieldMimeType:
		return m.OldMimeType(ctx)
	case storedfile.FieldStorageType:
		return m.OldStorageType(ctx)
	case storedfile.FieldBucketName:
		return m.OldBucketName(ctx)
	case storedfile.FieldStoragePath:
		return m.OldStoragePath(ctx)
	case storedfile.FieldStorageFilename:
		return m.OldStorageFilename(ctx)
	case storedfile.FieldTemporaryStoragePath:
		return m.OldTemporaryStoragePath(ctx)
	case storedfile.FieldTemporaryStorageFilename:
		return m.OldTemporaryStorageFilename(ctx)
	case storedfile.FieldCopiedToFinalDestinationAt:
		return m.OldCopiedToFinalDestinationAt(ctx)
	case storedfile.FieldDeletedTemporaryFileAt:
		return m.OldDeletedTemporaryFileAt(ctx)
	}
	return nil, fmt.Errorf("unknown StoredFile field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StoredFileMutation) SetField(name string, value ent.Value) error {
	switch name {
	case storedfile.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case storedfile.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case storedfile.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case storedfile.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case storedfile.FieldFilename:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFilename(v)
		return nil
	case storedfile.FieldSize:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSize(v)
		return nil
	case storedfile.FieldSizeInStorage:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSizeInStorage(v)
		return nil
	case storedfile.FieldSha256:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSha256(v)
		return nil
	case storedfile.FieldMimeType:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetMimeType(v)
		return nil
	case storedfile.FieldStorageType:
		v, ok := value.(storagetype.StorageType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStorageType(v)
		return nil
	case storedfile.FieldBucketName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBucketName(v)
		return nil
	case storedfile.FieldStoragePath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStoragePath(v)
		return nil
	case storedfile.FieldStorageFilename:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetStorageFilename(v)
		return nil
	case storedfile.FieldTemporaryStoragePath:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTemporaryStoragePath(v)
		return nil
	case storedfile.FieldTemporaryStorageFilename:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTemporaryStorageFilename(v)
		return nil
	case storedfile.FieldCopiedToFinalDestinationAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCopiedToFinalDestinationAt(v)
		return nil
	case storedfile.FieldDeletedTemporaryFileAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedTemporaryFileAt(v)
		return nil
	}
	return fmt.Errorf("unknown StoredFile field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *StoredFileMutation) AddedFields() []string {
	var fields []string
	if m.addsize != nil {
		fields = append(fields, storedfile.FieldSize)
	}
	if m.addsize_in_storage != nil {
		fields = append(fields, storedfile.FieldSizeInStorage)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *StoredFileMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case storedfile.FieldSize:
		return m.AddedSize()
	case storedfile.FieldSizeInStorage:
		return m.AddedSizeInStorage()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *StoredFileMutation) AddField(name string, value ent.Value) error {
	switch name {
	case storedfile.FieldSize:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSize(v)
		return nil
	case storedfile.FieldSizeInStorage:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddSizeInStorage(v)
		return nil
	}
	return fmt.Errorf("unknown StoredFile numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *StoredFileMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(storedfile.FieldCreatedBy) {
		fields = append(fields, storedfile.FieldCreatedBy)
	}
	if m.FieldCleared(storedfile.FieldUpdatedBy) {
		fields = append(fields, storedfile.FieldUpdatedBy)
	}
	if m.FieldCleared(storedfile.FieldSize) {
		fields = append(fields, storedfile.FieldSize)
	}
	if m.FieldCleared(storedfile.FieldSha256) {
		fields = append(fields, storedfile.FieldSha256)
	}
	if m.FieldCleared(storedfile.FieldMimeType) {
		fields = append(fields, storedfile.FieldMimeType)
	}
	if m.FieldCleared(storedfile.FieldBucketName) {
		fields = append(fields, storedfile.FieldBucketName)
	}
	if m.FieldCleared(storedfile.FieldCopiedToFinalDestinationAt) {
		fields = append(fields, storedfile.FieldCopiedToFinalDestinationAt)
	}
	if m.FieldCleared(storedfile.FieldDeletedTemporaryFileAt) {
		fields = append(fields, storedfile.FieldDeletedTemporaryFileAt)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *StoredFileMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *StoredFileMutation) ClearField(name string) error {
	switch name {
	case storedfile.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case storedfile.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case storedfile.FieldSize:
		m.ClearSize()
		return nil
	case storedfile.FieldSha256:
		m.ClearSha256()
		return nil
	case storedfile.FieldMimeType:
		m.ClearMimeType()
		return nil
	case storedfile.FieldBucketName:
		m.ClearBucketName()
		return nil
	case storedfile.FieldCopiedToFinalDestinationAt:
		m.ClearCopiedToFinalDestinationAt()
		return nil
	case storedfile.FieldDeletedTemporaryFileAt:
		m.ClearDeletedTemporaryFileAt()
		return nil
	}
	return fmt.Errorf("unknown StoredFile nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *StoredFileMutation) ResetField(name string) error {
	switch name {
	case storedfile.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case storedfile.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case storedfile.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case storedfile.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case storedfile.FieldFilename:
		m.ResetFilename()
		return nil
	case storedfile.FieldSize:
		m.ResetSize()
		return nil
	case storedfile.FieldSizeInStorage:
		m.ResetSizeInStorage()
		return nil
	case storedfile.FieldSha256:
		m.ResetSha256()
		return nil
	case storedfile.FieldMimeType:
		m.ResetMimeType()
		return nil
	case storedfile.FieldStorageType:
		m.ResetStorageType()
		return nil
	case storedfile.FieldBucketName:
		m.ResetBucketName()
		return nil
	case storedfile.FieldStoragePath:
		m.ResetStoragePath()
		return nil
	case storedfile.FieldStorageFilename:
		m.ResetStorageFilename()
		return nil
	case storedfile.FieldTemporaryStoragePath:
		m.ResetTemporaryStoragePath()
		return nil
	case storedfile.FieldTemporaryStorageFilename:
		m.ResetTemporaryStorageFilename()
		return nil
	case storedfile.FieldCopiedToFinalDestinationAt:
		m.ResetCopiedToFinalDestinationAt()
		return nil
	case storedfile.FieldDeletedTemporaryFileAt:
		m.ResetDeletedTemporaryFileAt()
		return nil
	}
	return fmt.Errorf("unknown StoredFile field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *StoredFileMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.creator != nil {
		edges = append(edges, storedfile.EdgeCreator)
	}
	if m.updater != nil {
		edges = append(edges, storedfile.EdgeUpdater)
	}
	if m.files != nil {
		edges = append(edges, storedfile.EdgeFiles)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *StoredFileMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case storedfile.EdgeCreator:
		if id := m.creator; id != nil {
			return []ent.Value{*id}
		}
	case storedfile.EdgeUpdater:
		if id := m.updater; id != nil {
			return []ent.Value{*id}
		}
	case storedfile.EdgeFiles:
		ids := make([]ent.Value, 0, len(m.files))
		for id := range m.files {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *StoredFileMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	if m.removedfiles != nil {
		edges = append(edges, storedfile.EdgeFiles)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *StoredFileMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case storedfile.EdgeFiles:
		ids := make([]ent.Value, 0, len(m.removedfiles))
		for id := range m.removedfiles {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *StoredFileMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedcreator {
		edges = append(edges, storedfile.EdgeCreator)
	}
	if m.clearedupdater {
		edges = append(edges, storedfile.EdgeUpdater)
	}
	if m.clearedfiles {
		edges = append(edges, storedfile.EdgeFiles)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *StoredFileMutation) EdgeCleared(name string) bool {
	switch name {
	case storedfile.EdgeCreator:
		return m.clearedcreator
	case storedfile.EdgeUpdater:
		return m.clearedupdater
	case storedfile.EdgeFiles:
		return m.clearedfiles
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *StoredFileMutation) ClearEdge(name string) error {
	switch name {
	case storedfile.EdgeCreator:
		m.ClearCreator()
		return nil
	case storedfile.EdgeUpdater:
		m.ClearUpdater()
		return nil
	}
	return fmt.Errorf("unknown StoredFile unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *StoredFileMutation) ResetEdge(name string) error {
	switch name {
	case storedfile.EdgeCreator:
		m.ResetCreator()
		return nil
	case storedfile.EdgeUpdater:
		m.ResetUpdater()
		return nil
	case storedfile.EdgeFiles:
		m.ResetFiles()
		return nil
	}
	return fmt.Errorf("unknown StoredFile edge %s", name)
}

// TagMutation represents an operation that mutates the Tag nodes in the graph.
type TagMutation struct {
	config
	op                    Op
	typ                   string
	id                    *int64
	name                  *string
	color                 *string
	icon                  *string
	_type                 *tagtype.TagType
	clearedFields         map[string]struct{}
	space                 *int64
	clearedspace          bool
	children              map[int64]struct{}
	removedchildren       map[int64]struct{}
	clearedchildren       bool
	group                 *int64
	clearedgroup          bool
	super_tags            map[int64]struct{}
	removedsuper_tags     map[int64]struct{}
	clearedsuper_tags     bool
	sub_tags              map[int64]struct{}
	removedsub_tags       map[int64]struct{}
	clearedsub_tags       bool
	files                 map[int64]struct{}
	removedfiles          map[int64]struct{}
	clearedfiles          bool
	tag_assignment        map[int64]struct{}
	removedtag_assignment map[int64]struct{}
	clearedtag_assignment bool
	done                  bool
	oldValue              func(context.Context) (*Tag, error)
	predicates            []predicate.Tag
}

var _ ent.Mutation = (*TagMutation)(nil)

// tagOption allows management of the mutation configuration using functional options.
type tagOption func(*TagMutation)

// newTagMutation creates new mutation for the Tag entity.
func newTagMutation(c config, op Op, opts ...tagOption) *TagMutation {
	m := &TagMutation{
		config:        c,
		op:            op,
		typ:           TypeTag,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTagID sets the ID field of the mutation.
func withTagID(id int64) tagOption {
	return func(m *TagMutation) {
		var (
			err   error
			once  sync.Once
			value *Tag
		)
		m.oldValue = func(ctx context.Context) (*Tag, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Tag.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTag sets the old Tag of the mutation.
func withTag(node *Tag) tagOption {
	return func(m *TagMutation) {
		m.oldValue = func(context.Context) (*Tag, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TagMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TagMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("enttenant: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of Tag entities.
func (m *TagMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TagMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TagMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().Tag.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSpaceID sets the "space_id" field.
func (m *TagMutation) SetSpaceID(i int64) {
	m.space = &i
}

// SpaceID returns the value of the "space_id" field in the mutation.
func (m *TagMutation) SpaceID() (r int64, exists bool) {
	v := m.space
	if v == nil {
		return
	}
	return *v, true
}

// OldSpaceID returns the old "space_id" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldSpaceID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSpaceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSpaceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSpaceID: %w", err)
	}
	return oldValue.SpaceID, nil
}

// ResetSpaceID resets all changes to the "space_id" field.
func (m *TagMutation) ResetSpaceID() {
	m.space = nil
}

// SetName sets the "name" field.
func (m *TagMutation) SetName(s string) {
	m.name = &s
}

// Name returns the value of the "name" field in the mutation.
func (m *TagMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old "name" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName resets all changes to the "name" field.
func (m *TagMutation) ResetName() {
	m.name = nil
}

// SetColor sets the "color" field.
func (m *TagMutation) SetColor(s string) {
	m.color = &s
}

// Color returns the value of the "color" field in the mutation.
func (m *TagMutation) Color() (r string, exists bool) {
	v := m.color
	if v == nil {
		return
	}
	return *v, true
}

// OldColor returns the old "color" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldColor(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldColor is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldColor requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldColor: %w", err)
	}
	return oldValue.Color, nil
}

// ClearColor clears the value of the "color" field.
func (m *TagMutation) ClearColor() {
	m.color = nil
	m.clearedFields[tag.FieldColor] = struct{}{}
}

// ColorCleared returns if the "color" field was cleared in this mutation.
func (m *TagMutation) ColorCleared() bool {
	_, ok := m.clearedFields[tag.FieldColor]
	return ok
}

// ResetColor resets all changes to the "color" field.
func (m *TagMutation) ResetColor() {
	m.color = nil
	delete(m.clearedFields, tag.FieldColor)
}

// SetIcon sets the "icon" field.
func (m *TagMutation) SetIcon(s string) {
	m.icon = &s
}

// Icon returns the value of the "icon" field in the mutation.
func (m *TagMutation) Icon() (r string, exists bool) {
	v := m.icon
	if v == nil {
		return
	}
	return *v, true
}

// OldIcon returns the old "icon" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldIcon(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldIcon is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldIcon requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldIcon: %w", err)
	}
	return oldValue.Icon, nil
}

// ClearIcon clears the value of the "icon" field.
func (m *TagMutation) ClearIcon() {
	m.icon = nil
	m.clearedFields[tag.FieldIcon] = struct{}{}
}

// IconCleared returns if the "icon" field was cleared in this mutation.
func (m *TagMutation) IconCleared() bool {
	_, ok := m.clearedFields[tag.FieldIcon]
	return ok
}

// ResetIcon resets all changes to the "icon" field.
func (m *TagMutation) ResetIcon() {
	m.icon = nil
	delete(m.clearedFields, tag.FieldIcon)
}

// SetType sets the "type" field.
func (m *TagMutation) SetType(tt tagtype.TagType) {
	m._type = &tt
}

// GetType returns the value of the "type" field in the mutation.
func (m *TagMutation) GetType() (r tagtype.TagType, exists bool) {
	v := m._type
	if v == nil {
		return
	}
	return *v, true
}

// OldType returns the old "type" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldType(ctx context.Context) (v tagtype.TagType, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldType is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldType requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldType: %w", err)
	}
	return oldValue.Type, nil
}

// ResetType resets all changes to the "type" field.
func (m *TagMutation) ResetType() {
	m._type = nil
}

// SetGroupID sets the "group_id" field.
func (m *TagMutation) SetGroupID(i int64) {
	m.group = &i
}

// GroupID returns the value of the "group_id" field in the mutation.
func (m *TagMutation) GroupID() (r int64, exists bool) {
	v := m.group
	if v == nil {
		return
	}
	return *v, true
}

// OldGroupID returns the old "group_id" field's value of the Tag entity.
// If the Tag object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagMutation) OldGroupID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldGroupID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldGroupID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldGroupID: %w", err)
	}
	return oldValue.GroupID, nil
}

// ClearGroupID clears the value of the "group_id" field.
func (m *TagMutation) ClearGroupID() {
	m.group = nil
	m.clearedFields[tag.FieldGroupID] = struct{}{}
}

// GroupIDCleared returns if the "group_id" field was cleared in this mutation.
func (m *TagMutation) GroupIDCleared() bool {
	_, ok := m.clearedFields[tag.FieldGroupID]
	return ok
}

// ResetGroupID resets all changes to the "group_id" field.
func (m *TagMutation) ResetGroupID() {
	m.group = nil
	delete(m.clearedFields, tag.FieldGroupID)
}

// ClearSpace clears the "space" edge to the Space entity.
func (m *TagMutation) ClearSpace() {
	m.clearedspace = true
	m.clearedFields[tag.FieldSpaceID] = struct{}{}
}

// SpaceCleared reports if the "space" edge to the Space entity was cleared.
func (m *TagMutation) SpaceCleared() bool {
	return m.clearedspace
}

// SpaceIDs returns the "space" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SpaceID instead. It exists only for internal usage by the builders.
func (m *TagMutation) SpaceIDs() (ids []int64) {
	if id := m.space; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSpace resets all changes to the "space" edge.
func (m *TagMutation) ResetSpace() {
	m.space = nil
	m.clearedspace = false
}

// AddChildIDs adds the "children" edge to the Tag entity by ids.
func (m *TagMutation) AddChildIDs(ids ...int64) {
	if m.children == nil {
		m.children = make(map[int64]struct{})
	}
	for i := range ids {
		m.children[ids[i]] = struct{}{}
	}
}

// ClearChildren clears the "children" edge to the Tag entity.
func (m *TagMutation) ClearChildren() {
	m.clearedchildren = true
}

// ChildrenCleared reports if the "children" edge to the Tag entity was cleared.
func (m *TagMutation) ChildrenCleared() bool {
	return m.clearedchildren
}

// RemoveChildIDs removes the "children" edge to the Tag entity by IDs.
func (m *TagMutation) RemoveChildIDs(ids ...int64) {
	if m.removedchildren == nil {
		m.removedchildren = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.children, ids[i])
		m.removedchildren[ids[i]] = struct{}{}
	}
}

// RemovedChildren returns the removed IDs of the "children" edge to the Tag entity.
func (m *TagMutation) RemovedChildrenIDs() (ids []int64) {
	for id := range m.removedchildren {
		ids = append(ids, id)
	}
	return
}

// ChildrenIDs returns the "children" edge IDs in the mutation.
func (m *TagMutation) ChildrenIDs() (ids []int64) {
	for id := range m.children {
		ids = append(ids, id)
	}
	return
}

// ResetChildren resets all changes to the "children" edge.
func (m *TagMutation) ResetChildren() {
	m.children = nil
	m.clearedchildren = false
	m.removedchildren = nil
}

// ClearGroup clears the "group" edge to the Tag entity.
func (m *TagMutation) ClearGroup() {
	m.clearedgroup = true
	m.clearedFields[tag.FieldGroupID] = struct{}{}
}

// GroupCleared reports if the "group" edge to the Tag entity was cleared.
func (m *TagMutation) GroupCleared() bool {
	return m.GroupIDCleared() || m.clearedgroup
}

// GroupIDs returns the "group" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// GroupID instead. It exists only for internal usage by the builders.
func (m *TagMutation) GroupIDs() (ids []int64) {
	if id := m.group; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetGroup resets all changes to the "group" edge.
func (m *TagMutation) ResetGroup() {
	m.group = nil
	m.clearedgroup = false
}

// AddSuperTagIDs adds the "super_tags" edge to the Tag entity by ids.
func (m *TagMutation) AddSuperTagIDs(ids ...int64) {
	if m.super_tags == nil {
		m.super_tags = make(map[int64]struct{})
	}
	for i := range ids {
		m.super_tags[ids[i]] = struct{}{}
	}
}

// ClearSuperTags clears the "super_tags" edge to the Tag entity.
func (m *TagMutation) ClearSuperTags() {
	m.clearedsuper_tags = true
}

// SuperTagsCleared reports if the "super_tags" edge to the Tag entity was cleared.
func (m *TagMutation) SuperTagsCleared() bool {
	return m.clearedsuper_tags
}

// RemoveSuperTagIDs removes the "super_tags" edge to the Tag entity by IDs.
func (m *TagMutation) RemoveSuperTagIDs(ids ...int64) {
	if m.removedsuper_tags == nil {
		m.removedsuper_tags = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.super_tags, ids[i])
		m.removedsuper_tags[ids[i]] = struct{}{}
	}
}

// RemovedSuperTags returns the removed IDs of the "super_tags" edge to the Tag entity.
func (m *TagMutation) RemovedSuperTagsIDs() (ids []int64) {
	for id := range m.removedsuper_tags {
		ids = append(ids, id)
	}
	return
}

// SuperTagsIDs returns the "super_tags" edge IDs in the mutation.
func (m *TagMutation) SuperTagsIDs() (ids []int64) {
	for id := range m.super_tags {
		ids = append(ids, id)
	}
	return
}

// ResetSuperTags resets all changes to the "super_tags" edge.
func (m *TagMutation) ResetSuperTags() {
	m.super_tags = nil
	m.clearedsuper_tags = false
	m.removedsuper_tags = nil
}

// AddSubTagIDs adds the "sub_tags" edge to the Tag entity by ids.
func (m *TagMutation) AddSubTagIDs(ids ...int64) {
	if m.sub_tags == nil {
		m.sub_tags = make(map[int64]struct{})
	}
	for i := range ids {
		m.sub_tags[ids[i]] = struct{}{}
	}
}

// ClearSubTags clears the "sub_tags" edge to the Tag entity.
func (m *TagMutation) ClearSubTags() {
	m.clearedsub_tags = true
}

// SubTagsCleared reports if the "sub_tags" edge to the Tag entity was cleared.
func (m *TagMutation) SubTagsCleared() bool {
	return m.clearedsub_tags
}

// RemoveSubTagIDs removes the "sub_tags" edge to the Tag entity by IDs.
func (m *TagMutation) RemoveSubTagIDs(ids ...int64) {
	if m.removedsub_tags == nil {
		m.removedsub_tags = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.sub_tags, ids[i])
		m.removedsub_tags[ids[i]] = struct{}{}
	}
}

// RemovedSubTags returns the removed IDs of the "sub_tags" edge to the Tag entity.
func (m *TagMutation) RemovedSubTagsIDs() (ids []int64) {
	for id := range m.removedsub_tags {
		ids = append(ids, id)
	}
	return
}

// SubTagsIDs returns the "sub_tags" edge IDs in the mutation.
func (m *TagMutation) SubTagsIDs() (ids []int64) {
	for id := range m.sub_tags {
		ids = append(ids, id)
	}
	return
}

// ResetSubTags resets all changes to the "sub_tags" edge.
func (m *TagMutation) ResetSubTags() {
	m.sub_tags = nil
	m.clearedsub_tags = false
	m.removedsub_tags = nil
}

// AddFileIDs adds the "files" edge to the File entity by ids.
func (m *TagMutation) AddFileIDs(ids ...int64) {
	if m.files == nil {
		m.files = make(map[int64]struct{})
	}
	for i := range ids {
		m.files[ids[i]] = struct{}{}
	}
}

// ClearFiles clears the "files" edge to the File entity.
func (m *TagMutation) ClearFiles() {
	m.clearedfiles = true
}

// FilesCleared reports if the "files" edge to the File entity was cleared.
func (m *TagMutation) FilesCleared() bool {
	return m.clearedfiles
}

// RemoveFileIDs removes the "files" edge to the File entity by IDs.
func (m *TagMutation) RemoveFileIDs(ids ...int64) {
	if m.removedfiles == nil {
		m.removedfiles = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.files, ids[i])
		m.removedfiles[ids[i]] = struct{}{}
	}
}

// RemovedFiles returns the removed IDs of the "files" edge to the File entity.
func (m *TagMutation) RemovedFilesIDs() (ids []int64) {
	for id := range m.removedfiles {
		ids = append(ids, id)
	}
	return
}

// FilesIDs returns the "files" edge IDs in the mutation.
func (m *TagMutation) FilesIDs() (ids []int64) {
	for id := range m.files {
		ids = append(ids, id)
	}
	return
}

// ResetFiles resets all changes to the "files" edge.
func (m *TagMutation) ResetFiles() {
	m.files = nil
	m.clearedfiles = false
	m.removedfiles = nil
}

// AddTagAssignmentIDs adds the "tag_assignment" edge to the TagAssignment entity by ids.
func (m *TagMutation) AddTagAssignmentIDs(ids ...int64) {
	if m.tag_assignment == nil {
		m.tag_assignment = make(map[int64]struct{})
	}
	for i := range ids {
		m.tag_assignment[ids[i]] = struct{}{}
	}
}

// ClearTagAssignment clears the "tag_assignment" edge to the TagAssignment entity.
func (m *TagMutation) ClearTagAssignment() {
	m.clearedtag_assignment = true
}

// TagAssignmentCleared reports if the "tag_assignment" edge to the TagAssignment entity was cleared.
func (m *TagMutation) TagAssignmentCleared() bool {
	return m.clearedtag_assignment
}

// RemoveTagAssignmentIDs removes the "tag_assignment" edge to the TagAssignment entity by IDs.
func (m *TagMutation) RemoveTagAssignmentIDs(ids ...int64) {
	if m.removedtag_assignment == nil {
		m.removedtag_assignment = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.tag_assignment, ids[i])
		m.removedtag_assignment[ids[i]] = struct{}{}
	}
}

// RemovedTagAssignment returns the removed IDs of the "tag_assignment" edge to the TagAssignment entity.
func (m *TagMutation) RemovedTagAssignmentIDs() (ids []int64) {
	for id := range m.removedtag_assignment {
		ids = append(ids, id)
	}
	return
}

// TagAssignmentIDs returns the "tag_assignment" edge IDs in the mutation.
func (m *TagMutation) TagAssignmentIDs() (ids []int64) {
	for id := range m.tag_assignment {
		ids = append(ids, id)
	}
	return
}

// ResetTagAssignment resets all changes to the "tag_assignment" edge.
func (m *TagMutation) ResetTagAssignment() {
	m.tag_assignment = nil
	m.clearedtag_assignment = false
	m.removedtag_assignment = nil
}

// Where appends a list predicates to the TagMutation builder.
func (m *TagMutation) Where(ps ...predicate.Tag) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TagMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TagMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.Tag, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TagMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TagMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (Tag).
func (m *TagMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TagMutation) Fields() []string {
	fields := make([]string, 0, 6)
	if m.space != nil {
		fields = append(fields, tag.FieldSpaceID)
	}
	if m.name != nil {
		fields = append(fields, tag.FieldName)
	}
	if m.color != nil {
		fields = append(fields, tag.FieldColor)
	}
	if m.icon != nil {
		fields = append(fields, tag.FieldIcon)
	}
	if m._type != nil {
		fields = append(fields, tag.FieldType)
	}
	if m.group != nil {
		fields = append(fields, tag.FieldGroupID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TagMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tag.FieldSpaceID:
		return m.SpaceID()
	case tag.FieldName:
		return m.Name()
	case tag.FieldColor:
		return m.Color()
	case tag.FieldIcon:
		return m.Icon()
	case tag.FieldType:
		return m.GetType()
	case tag.FieldGroupID:
		return m.GroupID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TagMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tag.FieldSpaceID:
		return m.OldSpaceID(ctx)
	case tag.FieldName:
		return m.OldName(ctx)
	case tag.FieldColor:
		return m.OldColor(ctx)
	case tag.FieldIcon:
		return m.OldIcon(ctx)
	case tag.FieldType:
		return m.OldType(ctx)
	case tag.FieldGroupID:
		return m.OldGroupID(ctx)
	}
	return nil, fmt.Errorf("unknown Tag field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TagMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tag.FieldSpaceID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSpaceID(v)
		return nil
	case tag.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case tag.FieldColor:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetColor(v)
		return nil
	case tag.FieldIcon:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetIcon(v)
		return nil
	case tag.FieldType:
		v, ok := value.(tagtype.TagType)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetType(v)
		return nil
	case tag.FieldGroupID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetGroupID(v)
		return nil
	}
	return fmt.Errorf("unknown Tag field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TagMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TagMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TagMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Tag numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TagMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(tag.FieldColor) {
		fields = append(fields, tag.FieldColor)
	}
	if m.FieldCleared(tag.FieldIcon) {
		fields = append(fields, tag.FieldIcon)
	}
	if m.FieldCleared(tag.FieldGroupID) {
		fields = append(fields, tag.FieldGroupID)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TagMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TagMutation) ClearField(name string) error {
	switch name {
	case tag.FieldColor:
		m.ClearColor()
		return nil
	case tag.FieldIcon:
		m.ClearIcon()
		return nil
	case tag.FieldGroupID:
		m.ClearGroupID()
		return nil
	}
	return fmt.Errorf("unknown Tag nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TagMutation) ResetField(name string) error {
	switch name {
	case tag.FieldSpaceID:
		m.ResetSpaceID()
		return nil
	case tag.FieldName:
		m.ResetName()
		return nil
	case tag.FieldColor:
		m.ResetColor()
		return nil
	case tag.FieldIcon:
		m.ResetIcon()
		return nil
	case tag.FieldType:
		m.ResetType()
		return nil
	case tag.FieldGroupID:
		m.ResetGroupID()
		return nil
	}
	return fmt.Errorf("unknown Tag field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TagMutation) AddedEdges() []string {
	edges := make([]string, 0, 7)
	if m.space != nil {
		edges = append(edges, tag.EdgeSpace)
	}
	if m.children != nil {
		edges = append(edges, tag.EdgeChildren)
	}
	if m.group != nil {
		edges = append(edges, tag.EdgeGroup)
	}
	if m.super_tags != nil {
		edges = append(edges, tag.EdgeSuperTags)
	}
	if m.sub_tags != nil {
		edges = append(edges, tag.EdgeSubTags)
	}
	if m.files != nil {
		edges = append(edges, tag.EdgeFiles)
	}
	if m.tag_assignment != nil {
		edges = append(edges, tag.EdgeTagAssignment)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TagMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case tag.EdgeSpace:
		if id := m.space; id != nil {
			return []ent.Value{*id}
		}
	case tag.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.children))
		for id := range m.children {
			ids = append(ids, id)
		}
		return ids
	case tag.EdgeGroup:
		if id := m.group; id != nil {
			return []ent.Value{*id}
		}
	case tag.EdgeSuperTags:
		ids := make([]ent.Value, 0, len(m.super_tags))
		for id := range m.super_tags {
			ids = append(ids, id)
		}
		return ids
	case tag.EdgeSubTags:
		ids := make([]ent.Value, 0, len(m.sub_tags))
		for id := range m.sub_tags {
			ids = append(ids, id)
		}
		return ids
	case tag.EdgeFiles:
		ids := make([]ent.Value, 0, len(m.files))
		for id := range m.files {
			ids = append(ids, id)
		}
		return ids
	case tag.EdgeTagAssignment:
		ids := make([]ent.Value, 0, len(m.tag_assignment))
		for id := range m.tag_assignment {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TagMutation) RemovedEdges() []string {
	edges := make([]string, 0, 7)
	if m.removedchildren != nil {
		edges = append(edges, tag.EdgeChildren)
	}
	if m.removedsuper_tags != nil {
		edges = append(edges, tag.EdgeSuperTags)
	}
	if m.removedsub_tags != nil {
		edges = append(edges, tag.EdgeSubTags)
	}
	if m.removedfiles != nil {
		edges = append(edges, tag.EdgeFiles)
	}
	if m.removedtag_assignment != nil {
		edges = append(edges, tag.EdgeTagAssignment)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TagMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case tag.EdgeChildren:
		ids := make([]ent.Value, 0, len(m.removedchildren))
		for id := range m.removedchildren {
			ids = append(ids, id)
		}
		return ids
	case tag.EdgeSuperTags:
		ids := make([]ent.Value, 0, len(m.removedsuper_tags))
		for id := range m.removedsuper_tags {
			ids = append(ids, id)
		}
		return ids
	case tag.EdgeSubTags:
		ids := make([]ent.Value, 0, len(m.removedsub_tags))
		for id := range m.removedsub_tags {
			ids = append(ids, id)
		}
		return ids
	case tag.EdgeFiles:
		ids := make([]ent.Value, 0, len(m.removedfiles))
		for id := range m.removedfiles {
			ids = append(ids, id)
		}
		return ids
	case tag.EdgeTagAssignment:
		ids := make([]ent.Value, 0, len(m.removedtag_assignment))
		for id := range m.removedtag_assignment {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TagMutation) ClearedEdges() []string {
	edges := make([]string, 0, 7)
	if m.clearedspace {
		edges = append(edges, tag.EdgeSpace)
	}
	if m.clearedchildren {
		edges = append(edges, tag.EdgeChildren)
	}
	if m.clearedgroup {
		edges = append(edges, tag.EdgeGroup)
	}
	if m.clearedsuper_tags {
		edges = append(edges, tag.EdgeSuperTags)
	}
	if m.clearedsub_tags {
		edges = append(edges, tag.EdgeSubTags)
	}
	if m.clearedfiles {
		edges = append(edges, tag.EdgeFiles)
	}
	if m.clearedtag_assignment {
		edges = append(edges, tag.EdgeTagAssignment)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TagMutation) EdgeCleared(name string) bool {
	switch name {
	case tag.EdgeSpace:
		return m.clearedspace
	case tag.EdgeChildren:
		return m.clearedchildren
	case tag.EdgeGroup:
		return m.clearedgroup
	case tag.EdgeSuperTags:
		return m.clearedsuper_tags
	case tag.EdgeSubTags:
		return m.clearedsub_tags
	case tag.EdgeFiles:
		return m.clearedfiles
	case tag.EdgeTagAssignment:
		return m.clearedtag_assignment
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TagMutation) ClearEdge(name string) error {
	switch name {
	case tag.EdgeSpace:
		m.ClearSpace()
		return nil
	case tag.EdgeGroup:
		m.ClearGroup()
		return nil
	}
	return fmt.Errorf("unknown Tag unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TagMutation) ResetEdge(name string) error {
	switch name {
	case tag.EdgeSpace:
		m.ResetSpace()
		return nil
	case tag.EdgeChildren:
		m.ResetChildren()
		return nil
	case tag.EdgeGroup:
		m.ResetGroup()
		return nil
	case tag.EdgeSuperTags:
		m.ResetSuperTags()
		return nil
	case tag.EdgeSubTags:
		m.ResetSubTags()
		return nil
	case tag.EdgeFiles:
		m.ResetFiles()
		return nil
	case tag.EdgeTagAssignment:
		m.ResetTagAssignment()
		return nil
	}
	return fmt.Errorf("unknown Tag edge %s", name)
}

// TagAssignmentMutation represents an operation that mutates the TagAssignment nodes in the graph.
type TagAssignmentMutation struct {
	config
	op            Op
	typ           string
	id            *int64
	clearedFields map[string]struct{}
	space         *int64
	clearedspace  bool
	tag           *int64
	clearedtag    bool
	file          *int64
	clearedfile   bool
	done          bool
	oldValue      func(context.Context) (*TagAssignment, error)
	predicates    []predicate.TagAssignment
}

var _ ent.Mutation = (*TagAssignmentMutation)(nil)

// tagassignmentOption allows management of the mutation configuration using functional options.
type tagassignmentOption func(*TagAssignmentMutation)

// newTagAssignmentMutation creates new mutation for the TagAssignment entity.
func newTagAssignmentMutation(c config, op Op, opts ...tagassignmentOption) *TagAssignmentMutation {
	m := &TagAssignmentMutation{
		config:        c,
		op:            op,
		typ:           TypeTagAssignment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withTagAssignmentID sets the ID field of the mutation.
func withTagAssignmentID(id int64) tagassignmentOption {
	return func(m *TagAssignmentMutation) {
		var (
			err   error
			once  sync.Once
			value *TagAssignment
		)
		m.oldValue = func(ctx context.Context) (*TagAssignment, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().TagAssignment.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withTagAssignment sets the old TagAssignment of the mutation.
func withTagAssignment(node *TagAssignment) tagassignmentOption {
	return func(m *TagAssignmentMutation) {
		m.oldValue = func(context.Context) (*TagAssignment, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m TagAssignmentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m TagAssignmentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("enttenant: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of TagAssignment entities.
func (m *TagAssignmentMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *TagAssignmentMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *TagAssignmentMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().TagAssignment.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetSpaceID sets the "space_id" field.
func (m *TagAssignmentMutation) SetSpaceID(i int64) {
	m.space = &i
}

// SpaceID returns the value of the "space_id" field in the mutation.
func (m *TagAssignmentMutation) SpaceID() (r int64, exists bool) {
	v := m.space
	if v == nil {
		return
	}
	return *v, true
}

// OldSpaceID returns the old "space_id" field's value of the TagAssignment entity.
// If the TagAssignment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagAssignmentMutation) OldSpaceID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldSpaceID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldSpaceID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSpaceID: %w", err)
	}
	return oldValue.SpaceID, nil
}

// ResetSpaceID resets all changes to the "space_id" field.
func (m *TagAssignmentMutation) ResetSpaceID() {
	m.space = nil
}

// SetFileID sets the "file_id" field.
func (m *TagAssignmentMutation) SetFileID(i int64) {
	m.file = &i
}

// FileID returns the value of the "file_id" field in the mutation.
func (m *TagAssignmentMutation) FileID() (r int64, exists bool) {
	v := m.file
	if v == nil {
		return
	}
	return *v, true
}

// OldFileID returns the old "file_id" field's value of the TagAssignment entity.
// If the TagAssignment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagAssignmentMutation) OldFileID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFileID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFileID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFileID: %w", err)
	}
	return oldValue.FileID, nil
}

// ResetFileID resets all changes to the "file_id" field.
func (m *TagAssignmentMutation) ResetFileID() {
	m.file = nil
}

// SetTagID sets the "tag_id" field.
func (m *TagAssignmentMutation) SetTagID(i int64) {
	m.tag = &i
}

// TagID returns the value of the "tag_id" field in the mutation.
func (m *TagAssignmentMutation) TagID() (r int64, exists bool) {
	v := m.tag
	if v == nil {
		return
	}
	return *v, true
}

// OldTagID returns the old "tag_id" field's value of the TagAssignment entity.
// If the TagAssignment object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *TagAssignmentMutation) OldTagID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldTagID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldTagID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTagID: %w", err)
	}
	return oldValue.TagID, nil
}

// ResetTagID resets all changes to the "tag_id" field.
func (m *TagAssignmentMutation) ResetTagID() {
	m.tag = nil
}

// ClearSpace clears the "space" edge to the Space entity.
func (m *TagAssignmentMutation) ClearSpace() {
	m.clearedspace = true
	m.clearedFields[tagassignment.FieldSpaceID] = struct{}{}
}

// SpaceCleared reports if the "space" edge to the Space entity was cleared.
func (m *TagAssignmentMutation) SpaceCleared() bool {
	return m.clearedspace
}

// SpaceIDs returns the "space" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// SpaceID instead. It exists only for internal usage by the builders.
func (m *TagAssignmentMutation) SpaceIDs() (ids []int64) {
	if id := m.space; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSpace resets all changes to the "space" edge.
func (m *TagAssignmentMutation) ResetSpace() {
	m.space = nil
	m.clearedspace = false
}

// ClearTag clears the "tag" edge to the Tag entity.
func (m *TagAssignmentMutation) ClearTag() {
	m.clearedtag = true
	m.clearedFields[tagassignment.FieldTagID] = struct{}{}
}

// TagCleared reports if the "tag" edge to the Tag entity was cleared.
func (m *TagAssignmentMutation) TagCleared() bool {
	return m.clearedtag
}

// TagIDs returns the "tag" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// TagID instead. It exists only for internal usage by the builders.
func (m *TagAssignmentMutation) TagIDs() (ids []int64) {
	if id := m.tag; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetTag resets all changes to the "tag" edge.
func (m *TagAssignmentMutation) ResetTag() {
	m.tag = nil
	m.clearedtag = false
}

// ClearFile clears the "file" edge to the File entity.
func (m *TagAssignmentMutation) ClearFile() {
	m.clearedfile = true
	m.clearedFields[tagassignment.FieldFileID] = struct{}{}
}

// FileCleared reports if the "file" edge to the File entity was cleared.
func (m *TagAssignmentMutation) FileCleared() bool {
	return m.clearedfile
}

// FileIDs returns the "file" edge IDs in the mutation.
// Note that IDs always returns len(IDs) <= 1 for unique edges, and you should use
// FileID instead. It exists only for internal usage by the builders.
func (m *TagAssignmentMutation) FileIDs() (ids []int64) {
	if id := m.file; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetFile resets all changes to the "file" edge.
func (m *TagAssignmentMutation) ResetFile() {
	m.file = nil
	m.clearedfile = false
}

// Where appends a list predicates to the TagAssignmentMutation builder.
func (m *TagAssignmentMutation) Where(ps ...predicate.TagAssignment) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the TagAssignmentMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *TagAssignmentMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.TagAssignment, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *TagAssignmentMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *TagAssignmentMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (TagAssignment).
func (m *TagAssignmentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *TagAssignmentMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.space != nil {
		fields = append(fields, tagassignment.FieldSpaceID)
	}
	if m.file != nil {
		fields = append(fields, tagassignment.FieldFileID)
	}
	if m.tag != nil {
		fields = append(fields, tagassignment.FieldTagID)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *TagAssignmentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case tagassignment.FieldSpaceID:
		return m.SpaceID()
	case tagassignment.FieldFileID:
		return m.FileID()
	case tagassignment.FieldTagID:
		return m.TagID()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *TagAssignmentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case tagassignment.FieldSpaceID:
		return m.OldSpaceID(ctx)
	case tagassignment.FieldFileID:
		return m.OldFileID(ctx)
	case tagassignment.FieldTagID:
		return m.OldTagID(ctx)
	}
	return nil, fmt.Errorf("unknown TagAssignment field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TagAssignmentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case tagassignment.FieldSpaceID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSpaceID(v)
		return nil
	case tagassignment.FieldFileID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFileID(v)
		return nil
	case tagassignment.FieldTagID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTagID(v)
		return nil
	}
	return fmt.Errorf("unknown TagAssignment field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *TagAssignmentMutation) AddedFields() []string {
	var fields []string
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *TagAssignmentMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *TagAssignmentMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown TagAssignment numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *TagAssignmentMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *TagAssignmentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *TagAssignmentMutation) ClearField(name string) error {
	return fmt.Errorf("unknown TagAssignment nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *TagAssignmentMutation) ResetField(name string) error {
	switch name {
	case tagassignment.FieldSpaceID:
		m.ResetSpaceID()
		return nil
	case tagassignment.FieldFileID:
		m.ResetFileID()
		return nil
	case tagassignment.FieldTagID:
		m.ResetTagID()
		return nil
	}
	return fmt.Errorf("unknown TagAssignment field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *TagAssignmentMutation) AddedEdges() []string {
	edges := make([]string, 0, 3)
	if m.space != nil {
		edges = append(edges, tagassignment.EdgeSpace)
	}
	if m.tag != nil {
		edges = append(edges, tagassignment.EdgeTag)
	}
	if m.file != nil {
		edges = append(edges, tagassignment.EdgeFile)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *TagAssignmentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case tagassignment.EdgeSpace:
		if id := m.space; id != nil {
			return []ent.Value{*id}
		}
	case tagassignment.EdgeTag:
		if id := m.tag; id != nil {
			return []ent.Value{*id}
		}
	case tagassignment.EdgeFile:
		if id := m.file; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *TagAssignmentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 3)
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *TagAssignmentMutation) RemovedIDs(name string) []ent.Value {
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *TagAssignmentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 3)
	if m.clearedspace {
		edges = append(edges, tagassignment.EdgeSpace)
	}
	if m.clearedtag {
		edges = append(edges, tagassignment.EdgeTag)
	}
	if m.clearedfile {
		edges = append(edges, tagassignment.EdgeFile)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *TagAssignmentMutation) EdgeCleared(name string) bool {
	switch name {
	case tagassignment.EdgeSpace:
		return m.clearedspace
	case tagassignment.EdgeTag:
		return m.clearedtag
	case tagassignment.EdgeFile:
		return m.clearedfile
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *TagAssignmentMutation) ClearEdge(name string) error {
	switch name {
	case tagassignment.EdgeSpace:
		m.ClearSpace()
		return nil
	case tagassignment.EdgeTag:
		m.ClearTag()
		return nil
	case tagassignment.EdgeFile:
		m.ClearFile()
		return nil
	}
	return fmt.Errorf("unknown TagAssignment unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *TagAssignmentMutation) ResetEdge(name string) error {
	switch name {
	case tagassignment.EdgeSpace:
		m.ResetSpace()
		return nil
	case tagassignment.EdgeTag:
		m.ResetTag()
		return nil
	case tagassignment.EdgeFile:
		m.ResetFile()
		return nil
	}
	return fmt.Errorf("unknown TagAssignment edge %s", name)
}

// UserMutation represents an operation that mutates the User nodes in the graph.
type UserMutation struct {
	config
	op                      Op
	typ                     string
	id                      *int64
	created_at              *time.Time
	created_by              *int64
	addcreated_by           *int64
	updated_at              *time.Time
	updated_by              *int64
	addupdated_by           *int64
	deleted_by              *int64
	adddeleted_by           *int64
	deleted_at              *time.Time
	public_id               *entx.CIText
	account_id              *int64
	addaccount_id           *int64
	role                    *tenantrole.TenantRole
	email                   *entx.CIText
	first_name              *string
	last_name               *string
	avatar                  *string
	description             *string
	clearedFields           map[string]struct{}
	spaces                  map[int64]struct{}
	removedspaces           map[int64]struct{}
	clearedspaces           bool
	space_assignment        map[int64]struct{}
	removedspace_assignment map[int64]struct{}
	clearedspace_assignment bool
	done                    bool
	oldValue                func(context.Context) (*User, error)
	predicates              []predicate.User
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows management of the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for the User entity.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the ID field of the mutation.
func withUserID(id int64) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = errors.New("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, errors.New("enttenant: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// SetID sets the value of the id field. Note that this
// operation is only accepted on creation of User entities.
func (m *UserMutation) SetID(id int64) {
	m.id = &id
}

// ID returns the ID value in the mutation. Note that the ID is only available
// if it was provided to the builder or after it was returned from the database.
func (m *UserMutation) ID() (id int64, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// IDs queries the database and returns the entity ids that match the mutation's predicate.
// That means, if the mutation is applied within a transaction with an isolation level such
// as sql.LevelSerializable, the returned ids match the ids of the rows that will be updated
// or updated by the mutation.
func (m *UserMutation) IDs(ctx context.Context) ([]int64, error) {
	switch {
	case m.op.Is(OpUpdateOne | OpDeleteOne):
		id, exists := m.ID()
		if exists {
			return []int64{id}, nil
		}
		fallthrough
	case m.op.Is(OpUpdate | OpDelete):
		return m.Client().User.Query().Where(m.predicates...).IDs(ctx)
	default:
		return nil, fmt.Errorf("IDs is not allowed on %s operations", m.op)
	}
}

// SetCreatedAt sets the "created_at" field.
func (m *UserMutation) SetCreatedAt(t time.Time) {
	m.created_at = &t
}

// CreatedAt returns the value of the "created_at" field in the mutation.
func (m *UserMutation) CreatedAt() (r time.Time, exists bool) {
	v := m.created_at
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedAt returns the old "created_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedAt: %w", err)
	}
	return oldValue.CreatedAt, nil
}

// ResetCreatedAt resets all changes to the "created_at" field.
func (m *UserMutation) ResetCreatedAt() {
	m.created_at = nil
}

// SetCreatedBy sets the "created_by" field.
func (m *UserMutation) SetCreatedBy(i int64) {
	m.created_by = &i
	m.addcreated_by = nil
}

// CreatedBy returns the value of the "created_by" field in the mutation.
func (m *UserMutation) CreatedBy() (r int64, exists bool) {
	v := m.created_by
	if v == nil {
		return
	}
	return *v, true
}

// OldCreatedBy returns the old "created_by" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldCreatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldCreatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldCreatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldCreatedBy: %w", err)
	}
	return oldValue.CreatedBy, nil
}

// AddCreatedBy adds i to the "created_by" field.
func (m *UserMutation) AddCreatedBy(i int64) {
	if m.addcreated_by != nil {
		*m.addcreated_by += i
	} else {
		m.addcreated_by = &i
	}
}

// AddedCreatedBy returns the value that was added to the "created_by" field in this mutation.
func (m *UserMutation) AddedCreatedBy() (r int64, exists bool) {
	v := m.addcreated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearCreatedBy clears the value of the "created_by" field.
func (m *UserMutation) ClearCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
	m.clearedFields[user.FieldCreatedBy] = struct{}{}
}

// CreatedByCleared returns if the "created_by" field was cleared in this mutation.
func (m *UserMutation) CreatedByCleared() bool {
	_, ok := m.clearedFields[user.FieldCreatedBy]
	return ok
}

// ResetCreatedBy resets all changes to the "created_by" field.
func (m *UserMutation) ResetCreatedBy() {
	m.created_by = nil
	m.addcreated_by = nil
	delete(m.clearedFields, user.FieldCreatedBy)
}

// SetUpdatedAt sets the "updated_at" field.
func (m *UserMutation) SetUpdatedAt(t time.Time) {
	m.updated_at = &t
}

// UpdatedAt returns the value of the "updated_at" field in the mutation.
func (m *UserMutation) UpdatedAt() (r time.Time, exists bool) {
	v := m.updated_at
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedAt returns the old "updated_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedAt: %w", err)
	}
	return oldValue.UpdatedAt, nil
}

// ResetUpdatedAt resets all changes to the "updated_at" field.
func (m *UserMutation) ResetUpdatedAt() {
	m.updated_at = nil
}

// SetUpdatedBy sets the "updated_by" field.
func (m *UserMutation) SetUpdatedBy(i int64) {
	m.updated_by = &i
	m.addupdated_by = nil
}

// UpdatedBy returns the value of the "updated_by" field in the mutation.
func (m *UserMutation) UpdatedBy() (r int64, exists bool) {
	v := m.updated_by
	if v == nil {
		return
	}
	return *v, true
}

// OldUpdatedBy returns the old "updated_by" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldUpdatedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldUpdatedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldUpdatedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldUpdatedBy: %w", err)
	}
	return oldValue.UpdatedBy, nil
}

// AddUpdatedBy adds i to the "updated_by" field.
func (m *UserMutation) AddUpdatedBy(i int64) {
	if m.addupdated_by != nil {
		*m.addupdated_by += i
	} else {
		m.addupdated_by = &i
	}
}

// AddedUpdatedBy returns the value that was added to the "updated_by" field in this mutation.
func (m *UserMutation) AddedUpdatedBy() (r int64, exists bool) {
	v := m.addupdated_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearUpdatedBy clears the value of the "updated_by" field.
func (m *UserMutation) ClearUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	m.clearedFields[user.FieldUpdatedBy] = struct{}{}
}

// UpdatedByCleared returns if the "updated_by" field was cleared in this mutation.
func (m *UserMutation) UpdatedByCleared() bool {
	_, ok := m.clearedFields[user.FieldUpdatedBy]
	return ok
}

// ResetUpdatedBy resets all changes to the "updated_by" field.
func (m *UserMutation) ResetUpdatedBy() {
	m.updated_by = nil
	m.addupdated_by = nil
	delete(m.clearedFields, user.FieldUpdatedBy)
}

// SetDeletedBy sets the "deleted_by" field.
func (m *UserMutation) SetDeletedBy(i int64) {
	m.deleted_by = &i
	m.adddeleted_by = nil
}

// DeletedBy returns the value of the "deleted_by" field in the mutation.
func (m *UserMutation) DeletedBy() (r int64, exists bool) {
	v := m.deleted_by
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedBy returns the old "deleted_by" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldDeletedBy(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedBy is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedBy requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedBy: %w", err)
	}
	return oldValue.DeletedBy, nil
}

// AddDeletedBy adds i to the "deleted_by" field.
func (m *UserMutation) AddDeletedBy(i int64) {
	if m.adddeleted_by != nil {
		*m.adddeleted_by += i
	} else {
		m.adddeleted_by = &i
	}
}

// AddedDeletedBy returns the value that was added to the "deleted_by" field in this mutation.
func (m *UserMutation) AddedDeletedBy() (r int64, exists bool) {
	v := m.adddeleted_by
	if v == nil {
		return
	}
	return *v, true
}

// ClearDeletedBy clears the value of the "deleted_by" field.
func (m *UserMutation) ClearDeletedBy() {
	m.deleted_by = nil
	m.adddeleted_by = nil
	m.clearedFields[user.FieldDeletedBy] = struct{}{}
}

// DeletedByCleared returns if the "deleted_by" field was cleared in this mutation.
func (m *UserMutation) DeletedByCleared() bool {
	_, ok := m.clearedFields[user.FieldDeletedBy]
	return ok
}

// ResetDeletedBy resets all changes to the "deleted_by" field.
func (m *UserMutation) ResetDeletedBy() {
	m.deleted_by = nil
	m.adddeleted_by = nil
	delete(m.clearedFields, user.FieldDeletedBy)
}

// SetDeletedAt sets the "deleted_at" field.
func (m *UserMutation) SetDeletedAt(t time.Time) {
	m.deleted_at = &t
}

// DeletedAt returns the value of the "deleted_at" field in the mutation.
func (m *UserMutation) DeletedAt() (r time.Time, exists bool) {
	v := m.deleted_at
	if v == nil {
		return
	}
	return *v, true
}

// OldDeletedAt returns the old "deleted_at" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldDeletedAt(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDeletedAt is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDeletedAt requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDeletedAt: %w", err)
	}
	return oldValue.DeletedAt, nil
}

// ClearDeletedAt clears the value of the "deleted_at" field.
func (m *UserMutation) ClearDeletedAt() {
	m.deleted_at = nil
	m.clearedFields[user.FieldDeletedAt] = struct{}{}
}

// DeletedAtCleared returns if the "deleted_at" field was cleared in this mutation.
func (m *UserMutation) DeletedAtCleared() bool {
	_, ok := m.clearedFields[user.FieldDeletedAt]
	return ok
}

// ResetDeletedAt resets all changes to the "deleted_at" field.
func (m *UserMutation) ResetDeletedAt() {
	m.deleted_at = nil
	delete(m.clearedFields, user.FieldDeletedAt)
}

// SetPublicID sets the "public_id" field.
func (m *UserMutation) SetPublicID(et entx.CIText) {
	m.public_id = &et
}

// PublicID returns the value of the "public_id" field in the mutation.
func (m *UserMutation) PublicID() (r entx.CIText, exists bool) {
	v := m.public_id
	if v == nil {
		return
	}
	return *v, true
}

// OldPublicID returns the old "public_id" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldPublicID(ctx context.Context) (v entx.CIText, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldPublicID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldPublicID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPublicID: %w", err)
	}
	return oldValue.PublicID, nil
}

// ResetPublicID resets all changes to the "public_id" field.
func (m *UserMutation) ResetPublicID() {
	m.public_id = nil
}

// SetAccountID sets the "account_id" field.
func (m *UserMutation) SetAccountID(i int64) {
	m.account_id = &i
	m.addaccount_id = nil
}

// AccountID returns the value of the "account_id" field in the mutation.
func (m *UserMutation) AccountID() (r int64, exists bool) {
	v := m.account_id
	if v == nil {
		return
	}
	return *v, true
}

// OldAccountID returns the old "account_id" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldAccountID(ctx context.Context) (v int64, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAccountID is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAccountID requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAccountID: %w", err)
	}
	return oldValue.AccountID, nil
}

// AddAccountID adds i to the "account_id" field.
func (m *UserMutation) AddAccountID(i int64) {
	if m.addaccount_id != nil {
		*m.addaccount_id += i
	} else {
		m.addaccount_id = &i
	}
}

// AddedAccountID returns the value that was added to the "account_id" field in this mutation.
func (m *UserMutation) AddedAccountID() (r int64, exists bool) {
	v := m.addaccount_id
	if v == nil {
		return
	}
	return *v, true
}

// ResetAccountID resets all changes to the "account_id" field.
func (m *UserMutation) ResetAccountID() {
	m.account_id = nil
	m.addaccount_id = nil
}

// SetRole sets the "role" field.
func (m *UserMutation) SetRole(tr tenantrole.TenantRole) {
	m.role = &tr
}

// Role returns the value of the "role" field in the mutation.
func (m *UserMutation) Role() (r tenantrole.TenantRole, exists bool) {
	v := m.role
	if v == nil {
		return
	}
	return *v, true
}

// OldRole returns the old "role" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldRole(ctx context.Context) (v tenantrole.TenantRole, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldRole is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldRole requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRole: %w", err)
	}
	return oldValue.Role, nil
}

// ResetRole resets all changes to the "role" field.
func (m *UserMutation) ResetRole() {
	m.role = nil
}

// SetEmail sets the "email" field.
func (m *UserMutation) SetEmail(et entx.CIText) {
	m.email = &et
}

// Email returns the value of the "email" field in the mutation.
func (m *UserMutation) Email() (r entx.CIText, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old "email" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v entx.CIText, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldEmail is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail resets all changes to the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// SetFirstName sets the "first_name" field.
func (m *UserMutation) SetFirstName(s string) {
	m.first_name = &s
}

// FirstName returns the value of the "first_name" field in the mutation.
func (m *UserMutation) FirstName() (r string, exists bool) {
	v := m.first_name
	if v == nil {
		return
	}
	return *v, true
}

// OldFirstName returns the old "first_name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldFirstName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldFirstName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldFirstName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldFirstName: %w", err)
	}
	return oldValue.FirstName, nil
}

// ResetFirstName resets all changes to the "first_name" field.
func (m *UserMutation) ResetFirstName() {
	m.first_name = nil
}

// SetLastName sets the "last_name" field.
func (m *UserMutation) SetLastName(s string) {
	m.last_name = &s
}

// LastName returns the value of the "last_name" field in the mutation.
func (m *UserMutation) LastName() (r string, exists bool) {
	v := m.last_name
	if v == nil {
		return
	}
	return *v, true
}

// OldLastName returns the old "last_name" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldLastName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldLastName is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldLastName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldLastName: %w", err)
	}
	return oldValue.LastName, nil
}

// ClearLastName clears the value of the "last_name" field.
func (m *UserMutation) ClearLastName() {
	m.last_name = nil
	m.clearedFields[user.FieldLastName] = struct{}{}
}

// LastNameCleared returns if the "last_name" field was cleared in this mutation.
func (m *UserMutation) LastNameCleared() bool {
	_, ok := m.clearedFields[user.FieldLastName]
	return ok
}

// ResetLastName resets all changes to the "last_name" field.
func (m *UserMutation) ResetLastName() {
	m.last_name = nil
	delete(m.clearedFields, user.FieldLastName)
}

// SetAvatar sets the "avatar" field.
func (m *UserMutation) SetAvatar(s string) {
	m.avatar = &s
}

// Avatar returns the value of the "avatar" field in the mutation.
func (m *UserMutation) Avatar() (r string, exists bool) {
	v := m.avatar
	if v == nil {
		return
	}
	return *v, true
}

// OldAvatar returns the old "avatar" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldAvatar(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldAvatar is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldAvatar requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldAvatar: %w", err)
	}
	return oldValue.Avatar, nil
}

// ClearAvatar clears the value of the "avatar" field.
func (m *UserMutation) ClearAvatar() {
	m.avatar = nil
	m.clearedFields[user.FieldAvatar] = struct{}{}
}

// AvatarCleared returns if the "avatar" field was cleared in this mutation.
func (m *UserMutation) AvatarCleared() bool {
	_, ok := m.clearedFields[user.FieldAvatar]
	return ok
}

// ResetAvatar resets all changes to the "avatar" field.
func (m *UserMutation) ResetAvatar() {
	m.avatar = nil
	delete(m.clearedFields, user.FieldAvatar)
}

// SetDescription sets the "description" field.
func (m *UserMutation) SetDescription(s string) {
	m.description = &s
}

// Description returns the value of the "description" field in the mutation.
func (m *UserMutation) Description() (r string, exists bool) {
	v := m.description
	if v == nil {
		return
	}
	return *v, true
}

// OldDescription returns the old "description" field's value of the User entity.
// If the User object wasn't provided to the builder, the object is fetched from the database.
// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
func (m *UserMutation) OldDescription(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, errors.New("OldDescription is only allowed on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, errors.New("OldDescription requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDescription: %w", err)
	}
	return oldValue.Description, nil
}

// ClearDescription clears the value of the "description" field.
func (m *UserMutation) ClearDescription() {
	m.description = nil
	m.clearedFields[user.FieldDescription] = struct{}{}
}

// DescriptionCleared returns if the "description" field was cleared in this mutation.
func (m *UserMutation) DescriptionCleared() bool {
	_, ok := m.clearedFields[user.FieldDescription]
	return ok
}

// ResetDescription resets all changes to the "description" field.
func (m *UserMutation) ResetDescription() {
	m.description = nil
	delete(m.clearedFields, user.FieldDescription)
}

// AddSpaceIDs adds the "spaces" edge to the Space entity by ids.
func (m *UserMutation) AddSpaceIDs(ids ...int64) {
	if m.spaces == nil {
		m.spaces = make(map[int64]struct{})
	}
	for i := range ids {
		m.spaces[ids[i]] = struct{}{}
	}
}

// ClearSpaces clears the "spaces" edge to the Space entity.
func (m *UserMutation) ClearSpaces() {
	m.clearedspaces = true
}

// SpacesCleared reports if the "spaces" edge to the Space entity was cleared.
func (m *UserMutation) SpacesCleared() bool {
	return m.clearedspaces
}

// RemoveSpaceIDs removes the "spaces" edge to the Space entity by IDs.
func (m *UserMutation) RemoveSpaceIDs(ids ...int64) {
	if m.removedspaces == nil {
		m.removedspaces = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.spaces, ids[i])
		m.removedspaces[ids[i]] = struct{}{}
	}
}

// RemovedSpaces returns the removed IDs of the "spaces" edge to the Space entity.
func (m *UserMutation) RemovedSpacesIDs() (ids []int64) {
	for id := range m.removedspaces {
		ids = append(ids, id)
	}
	return
}

// SpacesIDs returns the "spaces" edge IDs in the mutation.
func (m *UserMutation) SpacesIDs() (ids []int64) {
	for id := range m.spaces {
		ids = append(ids, id)
	}
	return
}

// ResetSpaces resets all changes to the "spaces" edge.
func (m *UserMutation) ResetSpaces() {
	m.spaces = nil
	m.clearedspaces = false
	m.removedspaces = nil
}

// AddSpaceAssignmentIDs adds the "space_assignment" edge to the SpaceUserAssignment entity by ids.
func (m *UserMutation) AddSpaceAssignmentIDs(ids ...int64) {
	if m.space_assignment == nil {
		m.space_assignment = make(map[int64]struct{})
	}
	for i := range ids {
		m.space_assignment[ids[i]] = struct{}{}
	}
}

// ClearSpaceAssignment clears the "space_assignment" edge to the SpaceUserAssignment entity.
func (m *UserMutation) ClearSpaceAssignment() {
	m.clearedspace_assignment = true
}

// SpaceAssignmentCleared reports if the "space_assignment" edge to the SpaceUserAssignment entity was cleared.
func (m *UserMutation) SpaceAssignmentCleared() bool {
	return m.clearedspace_assignment
}

// RemoveSpaceAssignmentIDs removes the "space_assignment" edge to the SpaceUserAssignment entity by IDs.
func (m *UserMutation) RemoveSpaceAssignmentIDs(ids ...int64) {
	if m.removedspace_assignment == nil {
		m.removedspace_assignment = make(map[int64]struct{})
	}
	for i := range ids {
		delete(m.space_assignment, ids[i])
		m.removedspace_assignment[ids[i]] = struct{}{}
	}
}

// RemovedSpaceAssignment returns the removed IDs of the "space_assignment" edge to the SpaceUserAssignment entity.
func (m *UserMutation) RemovedSpaceAssignmentIDs() (ids []int64) {
	for id := range m.removedspace_assignment {
		ids = append(ids, id)
	}
	return
}

// SpaceAssignmentIDs returns the "space_assignment" edge IDs in the mutation.
func (m *UserMutation) SpaceAssignmentIDs() (ids []int64) {
	for id := range m.space_assignment {
		ids = append(ids, id)
	}
	return
}

// ResetSpaceAssignment resets all changes to the "space_assignment" edge.
func (m *UserMutation) ResetSpaceAssignment() {
	m.space_assignment = nil
	m.clearedspace_assignment = false
	m.removedspace_assignment = nil
}

// Where appends a list predicates to the UserMutation builder.
func (m *UserMutation) Where(ps ...predicate.User) {
	m.predicates = append(m.predicates, ps...)
}

// WhereP appends storage-level predicates to the UserMutation builder. Using this method,
// users can use type-assertion to append predicates that do not depend on any generated package.
func (m *UserMutation) WhereP(ps ...func(*sql.Selector)) {
	p := make([]predicate.User, len(ps))
	for i := range ps {
		p[i] = ps[i]
	}
	m.Where(p...)
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// SetOp allows setting the mutation operation.
func (m *UserMutation) SetOp(op Op) {
	m.op = op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during this mutation. Note that in
// order to get all numeric fields that were incremented/decremented, call
// AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 14)
	if m.created_at != nil {
		fields = append(fields, user.FieldCreatedAt)
	}
	if m.created_by != nil {
		fields = append(fields, user.FieldCreatedBy)
	}
	if m.updated_at != nil {
		fields = append(fields, user.FieldUpdatedAt)
	}
	if m.updated_by != nil {
		fields = append(fields, user.FieldUpdatedBy)
	}
	if m.deleted_by != nil {
		fields = append(fields, user.FieldDeletedBy)
	}
	if m.deleted_at != nil {
		fields = append(fields, user.FieldDeletedAt)
	}
	if m.public_id != nil {
		fields = append(fields, user.FieldPublicID)
	}
	if m.account_id != nil {
		fields = append(fields, user.FieldAccountID)
	}
	if m.role != nil {
		fields = append(fields, user.FieldRole)
	}
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.first_name != nil {
		fields = append(fields, user.FieldFirstName)
	}
	if m.last_name != nil {
		fields = append(fields, user.FieldLastName)
	}
	if m.avatar != nil {
		fields = append(fields, user.FieldAvatar)
	}
	if m.description != nil {
		fields = append(fields, user.FieldDescription)
	}
	return fields
}

// Field returns the value of a field with the given name. The second boolean
// return value indicates that this field was not set, or was not defined in the
// schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldCreatedAt:
		return m.CreatedAt()
	case user.FieldCreatedBy:
		return m.CreatedBy()
	case user.FieldUpdatedAt:
		return m.UpdatedAt()
	case user.FieldUpdatedBy:
		return m.UpdatedBy()
	case user.FieldDeletedBy:
		return m.DeletedBy()
	case user.FieldDeletedAt:
		return m.DeletedAt()
	case user.FieldPublicID:
		return m.PublicID()
	case user.FieldAccountID:
		return m.AccountID()
	case user.FieldRole:
		return m.Role()
	case user.FieldEmail:
		return m.Email()
	case user.FieldFirstName:
		return m.FirstName()
	case user.FieldLastName:
		return m.LastName()
	case user.FieldAvatar:
		return m.Avatar()
	case user.FieldDescription:
		return m.Description()
	}
	return nil, false
}

// OldField returns the old value of the field from the database. An error is
// returned if the mutation operation is not UpdateOne, or the query to the
// database failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldCreatedAt:
		return m.OldCreatedAt(ctx)
	case user.FieldCreatedBy:
		return m.OldCreatedBy(ctx)
	case user.FieldUpdatedAt:
		return m.OldUpdatedAt(ctx)
	case user.FieldUpdatedBy:
		return m.OldUpdatedBy(ctx)
	case user.FieldDeletedBy:
		return m.OldDeletedBy(ctx)
	case user.FieldDeletedAt:
		return m.OldDeletedAt(ctx)
	case user.FieldPublicID:
		return m.OldPublicID(ctx)
	case user.FieldAccountID:
		return m.OldAccountID(ctx)
	case user.FieldRole:
		return m.OldRole(ctx)
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldFirstName:
		return m.OldFirstName(ctx)
	case user.FieldLastName:
		return m.OldLastName(ctx)
	case user.FieldAvatar:
		return m.OldAvatar(ctx)
	case user.FieldDescription:
		return m.OldDescription(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value of a field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldCreatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedAt(v)
		return nil
	case user.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetCreatedBy(v)
		return nil
	case user.FieldUpdatedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedAt(v)
		return nil
	case user.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetUpdatedBy(v)
		return nil
	case user.FieldDeletedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedBy(v)
		return nil
	case user.FieldDeletedAt:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDeletedAt(v)
		return nil
	case user.FieldPublicID:
		v, ok := value.(entx.CIText)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPublicID(v)
		return nil
	case user.FieldAccountID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAccountID(v)
		return nil
	case user.FieldRole:
		v, ok := value.(tenantrole.TenantRole)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRole(v)
		return nil
	case user.FieldEmail:
		v, ok := value.(entx.CIText)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldFirstName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetFirstName(v)
		return nil
	case user.FieldLastName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetLastName(v)
		return nil
	case user.FieldAvatar:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetAvatar(v)
		return nil
	case user.FieldDescription:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDescription(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented/decremented during
// this mutation.
func (m *UserMutation) AddedFields() []string {
	var fields []string
	if m.addcreated_by != nil {
		fields = append(fields, user.FieldCreatedBy)
	}
	if m.addupdated_by != nil {
		fields = append(fields, user.FieldUpdatedBy)
	}
	if m.adddeleted_by != nil {
		fields = append(fields, user.FieldDeletedBy)
	}
	if m.addaccount_id != nil {
		fields = append(fields, user.FieldAccountID)
	}
	return fields
}

// AddedField returns the numeric value that was incremented/decremented on a field
// with the given name. The second boolean return value indicates that this field
// was not set, or was not defined in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case user.FieldCreatedBy:
		return m.AddedCreatedBy()
	case user.FieldUpdatedBy:
		return m.AddedUpdatedBy()
	case user.FieldDeletedBy:
		return m.AddedDeletedBy()
	case user.FieldAccountID:
		return m.AddedAccountID()
	}
	return nil, false
}

// AddField adds the value to the field with the given name. It returns an error if
// the field is not defined in the schema, or if the type mismatched the field
// type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	case user.FieldCreatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddCreatedBy(v)
		return nil
	case user.FieldUpdatedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddUpdatedBy(v)
		return nil
	case user.FieldDeletedBy:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddDeletedBy(v)
		return nil
	case user.FieldAccountID:
		v, ok := value.(int64)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddAccountID(v)
		return nil
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared during this
// mutation.
func (m *UserMutation) ClearedFields() []string {
	var fields []string
	if m.FieldCleared(user.FieldCreatedBy) {
		fields = append(fields, user.FieldCreatedBy)
	}
	if m.FieldCleared(user.FieldUpdatedBy) {
		fields = append(fields, user.FieldUpdatedBy)
	}
	if m.FieldCleared(user.FieldDeletedBy) {
		fields = append(fields, user.FieldDeletedBy)
	}
	if m.FieldCleared(user.FieldDeletedAt) {
		fields = append(fields, user.FieldDeletedAt)
	}
	if m.FieldCleared(user.FieldLastName) {
		fields = append(fields, user.FieldLastName)
	}
	if m.FieldCleared(user.FieldAvatar) {
		fields = append(fields, user.FieldAvatar)
	}
	if m.FieldCleared(user.FieldDescription) {
		fields = append(fields, user.FieldDescription)
	}
	return fields
}

// FieldCleared returns a boolean indicating if a field with the given name was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value of the field with the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	switch name {
	case user.FieldCreatedBy:
		m.ClearCreatedBy()
		return nil
	case user.FieldUpdatedBy:
		m.ClearUpdatedBy()
		return nil
	case user.FieldDeletedBy:
		m.ClearDeletedBy()
		return nil
	case user.FieldDeletedAt:
		m.ClearDeletedAt()
		return nil
	case user.FieldLastName:
		m.ClearLastName()
		return nil
	case user.FieldAvatar:
		m.ClearAvatar()
		return nil
	case user.FieldDescription:
		m.ClearDescription()
		return nil
	}
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation for the field with the given name.
// It returns an error if the field is not defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldCreatedAt:
		m.ResetCreatedAt()
		return nil
	case user.FieldCreatedBy:
		m.ResetCreatedBy()
		return nil
	case user.FieldUpdatedAt:
		m.ResetUpdatedAt()
		return nil
	case user.FieldUpdatedBy:
		m.ResetUpdatedBy()
		return nil
	case user.FieldDeletedBy:
		m.ResetDeletedBy()
		return nil
	case user.FieldDeletedAt:
		m.ResetDeletedAt()
		return nil
	case user.FieldPublicID:
		m.ResetPublicID()
		return nil
	case user.FieldAccountID:
		m.ResetAccountID()
		return nil
	case user.FieldRole:
		m.ResetRole()
		return nil
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldFirstName:
		m.ResetFirstName()
		return nil
	case user.FieldLastName:
		m.ResetLastName()
		return nil
	case user.FieldAvatar:
		m.ResetAvatar()
		return nil
	case user.FieldDescription:
		m.ResetDescription()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.spaces != nil {
		edges = append(edges, user.EdgeSpaces)
	}
	if m.space_assignment != nil {
		edges = append(edges, user.EdgeSpaceAssignment)
	}
	return edges
}

// AddedIDs returns all IDs (to other nodes) that were added for the given edge
// name in this mutation.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeSpaces:
		ids := make([]ent.Value, 0, len(m.spaces))
		for id := range m.spaces {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeSpaceAssignment:
		ids := make([]ent.Value, 0, len(m.space_assignment))
		for id := range m.space_assignment {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedspaces != nil {
		edges = append(edges, user.EdgeSpaces)
	}
	if m.removedspace_assignment != nil {
		edges = append(edges, user.EdgeSpaceAssignment)
	}
	return edges
}

// RemovedIDs returns all IDs (to other nodes) that were removed for the edge with
// the given name in this mutation.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeSpaces:
		ids := make([]ent.Value, 0, len(m.removedspaces))
		for id := range m.removedspaces {
			ids = append(ids, id)
		}
		return ids
	case user.EdgeSpaceAssignment:
		ids := make([]ent.Value, 0, len(m.removedspace_assignment))
		for id := range m.removedspace_assignment {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.clearedspaces {
		edges = append(edges, user.EdgeSpaces)
	}
	if m.clearedspace_assignment {
		edges = append(edges, user.EdgeSpaceAssignment)
	}
	return edges
}

// EdgeCleared returns a boolean which indicates if the edge with the given name
// was cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeSpaces:
		return m.clearedspaces
	case user.EdgeSpaceAssignment:
		return m.clearedspace_assignment
	}
	return false
}

// ClearEdge clears the value of the edge with the given name. It returns an error
// if that edge is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes to the edge with the given name in this mutation.
// It returns an error if the edge is not defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeSpaces:
		m.ResetSpaces()
		return nil
	case user.EdgeSpaceAssignment:
		m.ResetSpaceAssignment()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}
